/// <reference types="msfstypes/js/simplane" />
/// <reference types="msfstypes/js/types" />
/// <reference types="msfstypes/pages/vcockpit/instruments/shared/baseinstrument" />
/// <reference types="msfstypes/pages/vcockpit/instruments/shared/utils/xmllogic" />
/// <reference types="msfstypes/js/netbingmap" />
/// <reference types="msfstypes/js/common" />
/**
 * A subscription to a source of notifications.
 *
 * Subscriptions can be freely paused and resumed. Paused subscriptions do not receive notifications from its source.
 *
 * Subscriptions that have reached the end of their useful life can be destroyed, after which they will no longer
 * receive notifications and cannot be paused or resumed.
 */
interface Subscription {
    /**
     * Whether this subscription is alive. Live subscriptions can be freely paused and resumed. Dead subscriptions no
     * longer receive notifications from their sources and will throw an error when attempting to pause or resume them.
     */
    readonly isAlive: boolean;
    /**
     * Whether this subscription is paused. Paused subscriptions do not receive notifications from their sources until
     * they are resumed.
     */
    readonly isPaused: boolean;
    /**
     * Whether this subscription supports initial notifications on resume.
     */
    readonly canInitialNotify: boolean;
    /**
     * Pauses this subscription. Once paused, this subscription will not receive notifications from its source until it
     * is resumed.
     * @throws Error if this subscription is not alive.
     */
    pause(): void;
    /**
     * Resumes this subscription. Once resumed, this subscription will receive notifications from its source.
     * @param initialNotify Whether to immediately send a notification to this subscription's handler when it is resumed
     * if this subscription supports initial notifications. Defaults to `false`.
     * @throws Error if this subscription is not alive.
     */
    resume(initialNotify?: boolean): void;
    /**
     * Destroys this subscription. Once destroyed, this subscription will no longer receive notifications from its
     * source and will throw an error when attempting to pause or resume it.
     */
    destroy(): void;
}

/**
 * A {@link Subscription} which executes a handler function every time it receives a notification.
 */
declare class HandlerSubscription<HandlerType extends (...args: any[]) => void> implements Subscription {
    readonly handler: HandlerType;
    private readonly initialNotifyFunc?;
    private readonly onDestroy?;
    private _isAlive;
    /** @inheritdoc */
    get isAlive(): boolean;
    private _isPaused;
    /** @inheritdoc */
    get isPaused(): boolean;
    /** @inheritdoc */
    readonly canInitialNotify: boolean;
    /**
     * Constructor.
     * @param handler This subscription's handler. The handler will be called each time this subscription receives a
     * notification from its source.
     * @param initialNotifyFunc A function which sends initial notifications to this subscription. If not defined, this
     * subscription will not support initial notifications.
     * @param onDestroy A function which is called when this subscription is destroyed.
     */
    constructor(handler: HandlerType, initialNotifyFunc?: ((sub: HandlerSubscription<HandlerType>) => void) | undefined, onDestroy?: ((sub: HandlerSubscription<HandlerType>) => void) | undefined);
    /**
     * Sends an initial notification to this subscription.
     * @throws Error if this subscription is not alive.
     */
    initialNotify(): void;
    /** @inheritdoc */
    pause(): void;
    /** @inheritdoc */
    resume(initialNotify?: boolean): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * An item which allows others to subscribe to be notified of changes in its state.
 */
interface Subscribable<T> {
    /** Flags this object as a Subscribable. */
    readonly isSubscribable: true;
    /**
     * Gets the state of this subscribable.
     * @returns the state of this subscribable.
     */
    get(): T;
    /**
     * Subscribes to changes in this subscribable's state.
     * @param handler A function which is called when this subscribable's state changes.
     * @param initialNotify Whether to immediately invoke the callback function with this subscribable's current state.
     * Defaults to `false`. This argument is ignored if the subscription is initialized as paused.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    sub(handler: (value: T) => void, initialNotify?: boolean, paused?: boolean): Subscription;
    /**
     * Unsubscribes a callback function from this subscribable.
     * @param handler The function to unsubscribe.
     * @deprecated This method has been deprecated in favor of using the {@link Subscription} object returned by `.sub()`
     * to manage subscriptions.
     */
    unsub(handler: (value: T) => void): void;
    /**
     * Maps this subscribable to a new subscribable.
     * @param fn The function to use to map to the new subscribable.
     * @param equalityFunc The function to use to check for equality between mapped values. Defaults to the strict
     * equality comparison (`===`).
     * @returns The mapped subscribable.
     */
    map<M>(fn: (input: T, previousVal?: M) => M, equalityFunc?: ((a: M, b: M) => boolean)): MappedSubscribable<M>;
    /**
     * Maps this subscribable to a new subscribable with a persistent, cached value which is mutated when it changes.
     * @param fn The function to use to map to the new subscribable.
     * @param equalityFunc The function to use to check for equality between mapped values.
     * @param mutateFunc The function to use to change the value of the mapped subscribable.
     * @param initialVal The initial value of the mapped subscribable.
     * @returns The mapped subscribable.
     */
    map<M>(fn: (input: T, previousVal?: M) => M, equalityFunc: ((a: M, b: M) => boolean), mutateFunc: ((oldVal: M, newVal: M) => void), initialVal: M): MappedSubscribable<M>;
    /**
     * Subscribes to and pipes this subscribable's state to a mutable subscribable. Whenever an update of this
     * subscribable's state is received through the subscription, it will be used as an input to change the other
     * subscribable's state.
     * @param to The mutable subscribable to which to pipe this subscribable's state.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    pipe(to: MutableSubscribable<any, T>, paused?: boolean): Subscription;
    /**
     * Subscribes to this subscribable's state and pipes a mapped version to a mutable subscribable. Whenever an update
     * of this subscribable's state is received through the subscription, it will be transformed by the specified mapping
     * function, and the transformed state will be used as an input to change the other subscribable's state.
     * @param to The mutable subscribable to which to pipe this subscribable's mapped state.
     * @param map The function to use to transform inputs.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    pipe<M>(to: MutableSubscribable<any, M>, map: (input: T) => M, paused?: boolean): Subscription;
}
/**
 * A subscribable which is mapped from another subscribable.
 */
interface MappedSubscribable<T> extends Subscribable<T> {
    /**
     * Whether the subscription to the parent subscribable is alive. While alive, this subscribable will update its state
     * based on its parent's state, unless it is paused. Once dead, this subscribable will no longer update its state,
     * and cannot be resumed again.
     */
    readonly isAlive: boolean;
    /**
     * Whether the subscription to the parent subscribable is paused. While paused, this subscribable will not update its
     * state until it is resumed.
     */
    readonly isPaused: boolean;
    /**
     * Pauses the subscription to the parent subscribable. Once paused, this subscribable will not update its state until
     * it is resumed.
     * @throws Error if the subscription to the parent subscribable is not alive.
     */
    pause(): void;
    /**
     * Resumes the subscription to the parent subscribable. Once resumed, this subscribable will immediately begin to
     * update its state based its parent's state.
     * @throws Error if the subscription to the parent subscribable is not alive.
     */
    resume(): void;
    /**
     * Destroys the subscription to the parent subscribable.
     */
    destroy(): void;
}
/**
 * A subscribable which can accept inputs to change its state. The state of the subscribable may be derived from the
 * inputs directly or from transformed versions of the inputs.
 */
interface MutableSubscribable<T, I = T> extends Subscribable<T> {
    /** Flags this object as a MutableSubscribable. */
    readonly isMutableSubscribable: true;
    /**
     * Sets the state of this subscribable.
     * @param value The input used to change the state.
     */
    set(value: I): void;
}
/**
 * Utility type to retrieve the value type of a {@link Subscribable}.
 */
declare type SubscribableType<S> = S extends Subscribable<infer T> ? T : never;
/**
 * Utility class for generating common mapping functions.
 */
declare class SubscribableMapFunctions {
    /**
     * Generates a function which maps an input to itself.
     * @returns A function which maps an input to itself.
     */
    static identity<T>(): (input: T) => T;
    /**
     * Generates a function which maps an input boolean to its negation.
     * @returns A function which maps an input boolean to its negation.
     */
    static not<T extends boolean>(): (input: T, currentVal?: T) => boolean;
    /**
     * Generates a function which maps an input number to its negation.
     * @returns A function which maps an input number to its negation.
     */
    static negate<T extends number>(): (input: T, currentVal?: T) => number;
    /**
     * Generates a function which maps an input number to its absolute value.
     * @returns A function which maps an input number to its absolute value.
     */
    static abs<T extends number>(): (input: T, currentVal?: T) => number;
    /**
     * Generates a function which maps an input number to a rounded version of itself at a certain precision.
     * @param precision The precision to which to round the input.
     * @returns A function which maps an input number to a rounded version of itself at the specified precision.
     */
    static withPrecision<T extends number>(precision: number): (input: T, currentVal?: T) => number;
    /**
     * Generates a function which maps an input number to itself if and only if it differs from the previous mapped value
     * by a certain amount, and to the previous mapped value otherwise.
     * @param threshold The minimum difference between the input and the previous mapped value required to map the input
     * to itself.
     * @returns A function which maps an input number to itself if and only if it differs from the previous mapped value
     * by the specified amount, and to the previous mapped value otherwise.
     */
    static changedBy<T extends number>(threshold: number): (input: T, currentVal?: T) => number;
    /**
     * Generates a function which maps an input number to itself up to a maximum frequency, and to the previous mapped
     * value otherwise.
     * @param freq The maximum frequency at which to map the input to itself, in Hertz.
     * @param timeFunc A function which gets the current time in milliseconds. Defaults to `Date.now()`.
     * @returns A function which maps an input number to itself up to the specified maximum frequency, and to the
     * previous mapped value otherwise.
     */
    atFrequency<T>(freq: number, timeFunc?: () => number): (input: T, currentVal?: T) => T;
}

/**
 * An abstract implementation of a subscribable which allows adding, removing, and notifying subscribers.
 */
declare abstract class AbstractSubscribable<T> implements Subscribable<T> {
    readonly isSubscribable = true;
    /**
     * Checks if two values are equal using the strict equality operator.
     * @param a The first value.
     * @param b The second value.
     * @returns whether a and b are equal.
     */
    static readonly DEFAULT_EQUALITY_FUNC: (a: any, b: any) => boolean;
    protected subs: HandlerSubscription<(v: T) => void>[];
    protected notifyDepth: number;
    /** A function which sends initial notifications to subscriptions. */
    protected readonly initialNotifyFunc: (sub: HandlerSubscription<(v: T) => void>) => void;
    /** A function which responds to when a subscription to this subscribable is destroyed. */
    protected readonly onSubDestroyedFunc: (sub: HandlerSubscription<(v: T) => void>) => void;
    /** @inheritdoc */
    abstract get(): T;
    /** @inheritdoc */
    sub(handler: (v: T) => void, initialNotify?: boolean, paused?: boolean): Subscription;
    /** @inheritdoc */
    unsub(handler: (v: T) => void): void;
    /**
     * Notifies subscriptions that this subscribable's value has changed.
     */
    protected notify(): void;
    /**
     * Notifies a subscription of this subscribable's current state.
     * @param sub The subscription to notify.
     */
    protected notifySubscription(sub: HandlerSubscription<(v: T) => void>): void;
    /**
     * Responds to when a subscription to this subscribable is destroyed.
     * @param sub The destroyed subscription.
     */
    protected onSubDestroyed(sub: HandlerSubscription<(v: T) => void>): void;
    /**
     * Maps this subscribable to a new subscribable.
     * @param fn The function to use to map to the new subscribable.
     * @param equalityFunc The function to use to check for equality between mapped values. Defaults to the strict
     * equality comparison (`===`).
     * @returns The mapped subscribable.
     */
    map<M>(fn: (input: T, previousVal?: M) => M, equalityFunc?: ((a: M, b: M) => boolean)): MappedSubscribable<M>;
    /**
     * Maps this subscribable to a new subscribable with a persistent, cached value which is mutated when it changes.
     * @param fn The function to use to map to the new subscribable.
     * @param equalityFunc The function to use to check for equality between mapped values.
     * @param mutateFunc The function to use to change the value of the mapped subscribable.
     * @param initialVal The initial value of the mapped subscribable.
     * @returns The mapped subscribable.
     */
    map<M>(fn: (input: T, previousVal?: M) => M, equalityFunc: ((a: M, b: M) => boolean), mutateFunc: ((oldVal: M, newVal: M) => void), initialVal: M): MappedSubscribable<M>;
    /**
     * Subscribes to and pipes this subscribable's state to a mutable subscribable. Whenever an update of this
     * subscribable's state is received through the subscription, it will be used as an input to change the other
     * subscribable's state.
     * @param to The mutable subscribable to which to pipe this subscribable's state.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    pipe(to: MutableSubscribable<any, T>, paused?: boolean): Subscription;
    /**
     * Subscribes to this subscribable's state and pipes a mapped version to a mutable subscribable. Whenever an update
     * of this subscribable's state is received through the subscription, it will be transformed by the specified mapping
     * function, and the transformed state will be used as an input to change the other subscribable's state.
     * @param to The mutable subscribable to which to pipe this subscribable's mapped state.
     * @param map The function to use to transform inputs.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    pipe<M>(to: MutableSubscribable<any, M>, map: (input: T) => M, paused?: boolean): Subscription;
}

/**
 * Types of subscribable array change event.
 */
declare enum SubscribableArrayEventType {
    /** An element was added. */
    Added = "Added",
    /** An element was removed. */
    Removed = "Removed",
    /** The array was cleared. */
    Cleared = "Cleared"
}
/**
 * A function which handles changes in a {@link SubscribableArray}'s state.
 */
declare type SubscribableArrayHandler<T> = (index: number, type: SubscribableArrayEventType, item: T | readonly T[] | undefined, array: readonly T[]) => void;
/**
 * An array which allows others to subscribe to be notified of changes in its state.
 */
interface SubscribableArray<T> {
    /** The length of this array. */
    readonly length: number;
    /**
     * Retrieves an element from this array.
     * @param index The index of the element.
     * @returns the element at the specified index.
     * @throws Error if index is out of bounds.
     */
    get(index: number): T;
    /**
     * Attempts to retrieve an element from this array.
     * @param index The index of the element.
     * @returns the element at the specified index, or undefined if index is out of bounds.
     */
    tryGet(index: number): T | undefined;
    /**
     * Gets a read-only version of this array.
     * @returns a read-only version of this array.
     */
    getArray(): readonly T[];
    /**
     * Subscribes to changes in this array's state.
     * @param handler A function which is called when this array's state changes.
     * @param initialNotify Whether to immediately invoke the callback function with this array's current state.
     * Defaults to `false`. This argument is ignored if the subscription is initialized as paused.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    sub(handler: SubscribableArrayHandler<T>, initialNotify?: boolean, paused?: boolean): Subscription;
    /**
     * Unsubscribes a callback function from this array.
     * @param handler The function to unsubscribe.
     * @deprecated This method has been deprecated in favor of using the {@link Subscription} object returned by `.sub()`
     * to manage subscriptions.
     */
    unsub(handler: SubscribableArrayHandler<T>): void;
}

/**
 * An array-like class to observe changes in a list of objects.
 * @class ArraySubject
 * @template T
 */
declare abstract class AbstractSubscribableArray<T> implements SubscribableArray<T> {
    /** @inheritdoc */
    abstract readonly length: number;
    protected subs: HandlerSubscription<SubscribableArrayHandler<T>>[];
    protected notifyDepth: number;
    /** A function which sends initial notifications to subscriptions. */
    protected readonly initialNotifyFunc: (sub: HandlerSubscription<SubscribableArrayHandler<T>>) => void;
    /** A function which responds to when a subscription to this subscribable is destroyed. */
    protected readonly onSubDestroyedFunc: (sub: HandlerSubscription<SubscribableArrayHandler<T>>) => void;
    /** @inheritdoc */
    sub(handler: SubscribableArrayHandler<T>, initialNotify?: boolean, paused?: boolean): Subscription;
    /** @inheritdoc */
    unsub(handler: SubscribableArrayHandler<T>): void;
    /** @inheritdoc */
    abstract getArray(): readonly T[];
    /**
     * Gets an item from the array.
     * @param index Thex index of the item to get.
     * @returns An item.
     * @throws
     */
    get(index: number): T;
    /**
     * Tries to get the value from the array.
     * @param index The index of the item to get.
     * @returns The value or undefined if not found.
     */
    tryGet(index: number): T | undefined;
    /**
     * Notifies subscriptions of a change in the array.
     * @param index The index that was changed.
     * @param type The type of subject event.
     * @param modifiedItem The item modified by the operation.
     */
    protected notify(index: number, type: SubscribableArrayEventType, modifiedItem?: T | readonly T[]): void;
    /**
     * Notifies a subscription of this array's current state.
     * @param sub The subscription to notify.
     */
    protected initialNotify(sub: HandlerSubscription<SubscribableArrayHandler<T>>): void;
    /**
     * Responds to when a subscription to this array is destroyed.
     * @param sub The destroyed subscription.
     */
    protected onSubDestroyed(sub: HandlerSubscription<SubscribableArrayHandler<T>>): void;
}

/**
 * A type which contains the `length` property of a tuple.
 */
declare type TupleLength<T extends readonly any[]> = {
    length: T['length'];
};
/**
 * A type which maps a tuple of input types to a tuple of subscribables that provide the input types.
 */
declare type CombinedSubscribableInputs<Types extends readonly any[]> = {
    [Index in keyof Types]: Subscribable<Types[Index]>;
} & TupleLength<Types>;
/**
 * A subscribable subject whose state is a combined tuple of an arbitrary number of values.
 */
declare class CombinedSubject<I extends any[]> extends AbstractSubscribable<Readonly<I>> implements MappedSubscribable<Readonly<I>> {
    private readonly inputs;
    private readonly inputValues;
    private readonly inputSubs;
    private _isAlive;
    /** @inheritdoc */
    get isAlive(): boolean;
    private _isPaused;
    /** @inheritdoc */
    get isPaused(): boolean;
    /**
     * Constructor.
     * @param inputs The subscribables which provide the inputs to this subject.
     */
    private constructor();
    /**
     * Creates a new subject whose state is a combined tuple of an arbitrary number of input values.
     * @param inputs The subscribables which provide the inputs to the new subject.
     * @returns A new subject whose state is a combined tuple of the specified input values.
     */
    static create<I extends any[]>(...inputs: CombinedSubscribableInputs<I>): CombinedSubject<I>;
    /** @inheritdoc */
    get(): Readonly<I>;
    /** @inheritdoc */
    pause(): void;
    /** @inheritdoc */
    resume(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * A subscribable subject that is a mapped stream from one or more input subscribables.
 */
declare class MappedSubject<I extends any[], T> implements MappedSubscribable<T> {
    readonly isSubscribable = true;
    private readonly input;
    private readonly mapped;
    /** @inheritdoc */
    get isAlive(): boolean;
    /** @inheritdoc */
    get isPaused(): boolean;
    /**
     * Creates a new MappedSubject.
     * @param mapFunc The function which maps this subject's inputs to a value.
     * @param equalityFunc The function which this subject uses to check for equality between values.
     * @param mutateFunc The function which this subject uses to change its value.
     * @param initialVal The initial value of this subject.
     * @param inputs The subscribables which provide the inputs to this subject.
     */
    private constructor();
    /**
     * Creates a new mapped subject. Values are compared for equality using the strict equality comparison (`===`).
     * @param mapFunc The function to use to map inputs to the new subject value.
     * @param inputs The subscribables which provide the inputs to the new subject.
     */
    static create<I extends any[], T>(mapFunc: (inputs: Readonly<I>, previousVal?: T) => T, ...inputs: CombinedSubscribableInputs<I>): MappedSubject<I, T>;
    /**
     * Creates a new mapped subject. Values are compared for equality using a custom function.
     * @param mapFunc The function to use to map inputs to the new subject value.
     * @param equalityFunc The function which the new subject uses to check for equality between values.
     * @param inputs The subscribables which provide the inputs to the new subject.
     */
    static create<I extends any[], T>(mapFunc: (inputs: Readonly<I>, previousVal?: T) => T, equalityFunc: (a: T, b: T) => boolean, ...inputs: CombinedSubscribableInputs<I>): MappedSubject<I, T>;
    /**
     * Creates a new mapped subject with a persistent, cached value which is mutated when it changes. Values are
     * compared for equality using a custom function.
     * @param mapFunc The function to use to map inputs to the new subject value.
     * @param equalityFunc The function which the new subject uses to check for equality between values.
     * @param mutateFunc The function to use to change the value of the new subject.
     * @param initialVal The initial value of the new subject.
     * @param inputs The subscribables which provide the inputs to the new subject.
     */
    static create<I extends any[], T>(mapFunc: (inputs: Readonly<I>, previousVal?: T) => T, equalityFunc: (a: T, b: T) => boolean, mutateFunc: (oldVal: T, newVal: T) => void, initialVal: T, ...inputs: CombinedSubscribableInputs<I>): MappedSubject<I, T>;
    /** @inheritdoc */
    get(): T;
    /** @inheritdoc */
    sub(handler: (v: T) => void, initialNotify?: boolean, paused?: boolean): Subscription;
    /** @inheritdoc */
    unsub(handler: (v: T) => void): void;
    /**
     * Maps this subscribable to a new subscribable.
     * @param fn The function to use to map to the new subscribable.
     * @param equalityFunc The function to use to check for equality between mapped values. Defaults to the strict
     * equality comparison (`===`).
     * @returns The mapped subscribable.
     */
    map<M>(fn: (input: T, previousVal?: M) => M, equalityFunc?: ((a: M, b: M) => boolean)): MappedSubscribable<M>;
    /**
     * Maps this subscribable to a new subscribable with a persistent, cached value which is mutated when it changes.
     * @param fn The function to use to map to the new subscribable.
     * @param equalityFunc The function to use to check for equality between mapped values.
     * @param mutateFunc The function to use to change the value of the mapped subscribable.
     * @param initialVal The initial value of the mapped subscribable.
     * @returns The mapped subscribable.
     */
    map<M>(fn: (input: T, previousVal?: M) => M, equalityFunc: ((a: M, b: M) => boolean), mutateFunc: ((oldVal: M, newVal: M) => void), initialVal: M): MappedSubscribable<M>;
    /**
     * Subscribes to and pipes this subscribable's state to a mutable subscribable. Whenever an update of this
     * subscribable's state is received through the subscription, it will be used as an input to change the other
     * subscribable's state.
     * @param to The mutable subscribable to which to pipe this subscribable's state.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    pipe(to: MutableSubscribable<any, T>, paused?: boolean): Subscription;
    /**
     * Subscribes to this subscribable's state and pipes a mapped version to a mutable subscribable. Whenever an update
     * of this subscribable's state is received through the subscription, it will be transformed by the specified mapping
     * function, and the transformed state will be used as an input to change the other subscribable's state.
     * @param to The mutable subscribable to which to pipe this subscribable's mapped state.
     * @param map The function to use to transform inputs.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    pipe<M>(to: MutableSubscribable<any, M>, map: (input: T) => M, paused?: boolean): Subscription;
    /** @inheritdoc */
    pause(): void;
    /** @inheritdoc */
    resume(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Types of changes made to {@link SubscribableSet}.
 */
declare enum SubscribableSetEventType {
    /** A key was added. */
    Added = "Added",
    /** A key was deleted. */
    Deleted = "Deleted"
}
/**
 * A function which handles changes in a {@link SubscribableSet}'s state.
 */
declare type SubscribableSetHandler<T> = (set: ReadonlySet<T>, type: SubscribableSetEventType, key: T) => void;
/**
 * A set which allows others to subscribe to be notified of changes in its state.
 */
interface SubscribableSet<T> {
    /** Flags this object as a SubscribableSet. */
    readonly isSubscribableSet: true;
    /** The number of elements contained in this set. */
    readonly size: number;
    /**
     * Gets a read-only version of this set.
     * @returns A read-only version of this set.
     */
    get(): ReadonlySet<T>;
    /**
     * Checks whether this set contains a key.
     * @param key The key to check.
     * @returns Whether this set contains the specified key.
     */
    has(key: T): boolean;
    /**
     * Subscribes to changes in this set's state.
     * @param handler A function which is called when this set's state changes.
     * @param initialNotify Whether to immediately invoke the callback function with this set's current state.
     * Defaults to `false`. This argument is ignored if the subscription is initialized as paused.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    sub(handler: SubscribableSetHandler<T>, initialNotify?: boolean, paused?: boolean): Subscription;
    /**
     * Subscribes to and pipes this set's state to a mutable subscribable set. Whenever a key added or removed event is
     * received through the subscription, the same key will be added to or removed from the other set.
     * @param to The mutable subscribable set to which to pipe this set's state.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    pipe(to: MutableSubscribableSet<T>, paused?: boolean): Subscription;
    /**
     * Subscribes to this set's state and pipes a mapped version to a mutable subscribable set. Whenever a key added
     * event is received through the subscription, the key will be transformed by the specified mapping
     * function, and the transformed key will be added to the other set. Whenever a key removed event is received, the
     * transformed key is removed from the other set if and only if no remaining key in this set maps to the same
     * transformed key.
     * @param to The mutable subscribable to which to pipe this set's mapped state.
     * @param map The function to use to transform keys.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    pipe<M>(to: MutableSubscribableSet<M>, map: (input: T) => M, paused?: boolean): Subscription;
}
/**
 * A subscribable set which can accept inputs to add or remove keys.
 */
interface MutableSubscribableSet<T> extends SubscribableSet<T> {
    /** Flags this object as a MutableSubscribableSet. */
    readonly isMutableSubscribableSet: true;
    /**
     * Adds a key to this set.
     * @param key The key to add.
     * @returns This set, after the key has been added.
     */
    add(key: T): this;
    /**
     * Removes a key from this set.
     * @param key The key to remove.
     * @returns Whether the key was removed.
     */
    delete(key: T): boolean;
    /**
     * Removes all keys from this set.
     */
    clear(): void;
}

/**
 * An abstract implementation of a subscribable set which allows adding, removing, and notifying subscribers.
 */
declare abstract class AbstractSubscribableSet<T> implements SubscribableSet<T>, Subscribable<ReadonlySet<T>> {
    readonly isSubscribable = true;
    readonly isSubscribableSet = true;
    /** @inheritdoc */
    get size(): number;
    protected subs: HandlerSubscription<SubscribableSetHandler<T>>[];
    protected notifyDepth: number;
    /** A function which sends initial notifications to subscriptions. */
    protected readonly initialNotifyFunc: (sub: HandlerSubscription<SubscribableSetHandler<T>>) => void;
    /** A function which responds to when a subscription to this subscribable is destroyed. */
    protected readonly onSubDestroyedFunc: (sub: HandlerSubscription<SubscribableSetHandler<T>>) => void;
    /** @inheritdoc */
    abstract get(): ReadonlySet<T>;
    /** @inheritdoc */
    has(key: T): boolean;
    /** @inheritdoc */
    sub(handler: SubscribableSetHandler<T>, initialNotify?: boolean, paused?: boolean): Subscription;
    /** @inheritdoc */
    unsub(handler: SubscribableSetHandler<T>): void;
    /**
     * Notifies subscriptions of a change in this set.
     * @param type The type of change.
     * @param key The key related to the change.
     */
    protected notify(type: SubscribableSetEventType, key: T): void;
    /**
     * Notifies a subscription of this set's current state.
     * @param sub The subscription to notify.
     */
    protected initialNotify(sub: HandlerSubscription<SubscribableSetHandler<T>>): void;
    /**
     * Responds to when a subscription to this set is destroyed.
     * @param sub The destroyed subscription.
     */
    protected onSubDestroyed(sub: HandlerSubscription<SubscribableSetHandler<T>>): void;
    /**
     * Maps this subscribable to a new subscribable.
     * @param fn The function to use to map to the new subscribable.
     * @param equalityFunc The function to use to check for equality between mapped values. Defaults to the strict
     * equality comparison (`===`).
     * @returns The mapped subscribable.
     */
    map<M>(fn: (input: ReadonlySet<T>, previousVal?: M) => M, equalityFunc?: ((a: M, b: M) => boolean)): MappedSubject<[ReadonlySet<T>], M>;
    /**
     * Maps this subscribable to a new subscribable with a persistent, cached value which is mutated when it changes.
     * @param fn The function to use to map to the new subscribable.
     * @param equalityFunc The function to use to check for equality between mapped values.
     * @param mutateFunc The function to use to change the value of the mapped subscribable.
     * @param initialVal The initial value of the mapped subscribable.
     * @returns The mapped subscribable.
     */
    map<M>(fn: (input: ReadonlySet<T>, previousVal?: M) => M, equalityFunc: ((a: M, b: M) => boolean), mutateFunc: ((oldVal: M, newVal: M) => void), initialVal: M): MappedSubject<[ReadonlySet<T>], M>;
    /**
     * Subscribes to and pipes this subscribable's state to a mutable subscribable. Whenever an update of this
     * subscribable's state is received through the subscription, it will be used as an input to change the other
     * subscribable's state.
     * @param to The mutable subscribable to which to pipe this subscribable's state.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    pipe(to: MutableSubscribable<any, ReadonlySet<T>>, paused?: boolean): Subscription;
    /**
     * Subscribes to and pipes mapped inputs from another subscribable. Whenever an update of the other subscribable's
     * state is received through the subscription, it will be transformed by the specified mapping function, and the
     * transformed state will be used as an input to change this subscribable's state.
     * @param to The mutable subscribable to which to pipe this subscribable's mapped state.
     * @param map The function to use to transform inputs.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    pipe<M>(to: MutableSubscribable<any, M>, map: (input: ReadonlySet<T>) => M, paused?: boolean): Subscription;
    /**
     * Subscribes to and pipes this set's state to a mutable subscribable set. Whenever a key added or removed event is
     * received through the subscription, the same key will be added to or removed from the other set.
     * @param to The mutable subscribable set to which to pipe this set's state.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    pipe(to: MutableSubscribableSet<T>, paused?: boolean): Subscription;
    /**
     * Subscribes to this set's state and pipes a mapped version to a mutable subscribable set. Whenever a key added
     * event is received through the subscription, the key will be transformed by the specified mapping
     * function, and the transformed key will be added to the other set. Whenever a key removed event is received, the
     * transformed key is removed from the other set if and only if no remaining key in this set maps to the same
     * transformed key.
     * @param to The mutable subscribable to which to pipe this set's mapped state.
     * @param map The function to use to transform keys.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    pipe<M>(to: MutableSubscribableSet<M>, map: (input: T) => M, paused?: boolean): Subscription;
}

/**
 * An array-like class to observe changes in a list of objects.
 * @class ArraySubject
 * @template T
 */
declare class ArraySubject<T> extends AbstractSubscribableArray<T> {
    private array;
    /** The length of this array. */
    get length(): number;
    /**
     * Constructs an observable array.
     * @param arr The initial array elements.
     */
    private constructor();
    /**
     * Creates and returns a new observable array.
     * @static
     * @template AT The type of the array items.
     * @param arr The initial array elements.
     * @returns A new instance of SubjectArray.
     */
    static create<AT>(arr?: AT[]): ArraySubject<AT>;
    /**
     * Inserts a new item at the end or the specified index.
     * @param item The item to insert.
     * @param index The optional index to insert the item to. Will add the item at then end if index not given.
     */
    insert(item: T, index?: number): void;
    /**
     * Inserts items of an array beginning at the specified index.
     * @param [index] The index to begin inserting the array items.
     * @param arr The array to insert.
     */
    insertRange(index: number | undefined, arr: readonly T[]): void;
    /**
     * Removes the item at the specified index.
     * @param index The index of the item to remove.
     */
    removeAt(index: number): void;
    /**
     * Removes the given item from the array.
     * @param item The item to remove.
     * @returns Returns a boolean indicating if the item was found and removed.
     */
    removeItem(item: T): boolean;
    /**
     * Replaces all items in the array with the new array.
     * @param arr The array.
     */
    set(arr: readonly T[]): void;
    /**
     * Clears all data in the array.
     */
    clear(): void;
    /**
     * Gets the array.
     * @returns The array.
     */
    getArray(): readonly T[];
}

/**
 * A class for subjects that return a computed value.
 * @class ComputedSubject
 * @template I The type of the input value.
 * @template T The type of the computed output value.
 */
declare class ComputedSubject<I, T> implements MutableSubscribable<T, I> {
    private readonly computeFn;
    readonly isSubscribable = true;
    readonly isMutableSubscribable = true;
    private value;
    private rawValue;
    private subs;
    private notifyDepth;
    private readonly initialNotifyFunc;
    private readonly onSubDestroyedFunc;
    /**
     * Creates an instance of ComputedSubject.
     * @param value The initial value.
     * @param computeFn The computation function.
     */
    private constructor();
    /**
     * Creates and returns a new ComputedSubject.
     * @param v The initial value of the Subject.
     * @param fn A function which transforms raw values to computed values.
     * @returns A ComputedSubject instance.
     */
    static create<IT, CT>(v: IT, fn: (v: IT) => CT): ComputedSubject<IT, CT>;
    /**
     * Sets the new value and notifies the subscribers when value changed.
     * @param value The new value.
     */
    set(value: I): void;
    /**
     * Gets the computed value of the Subject.
     * @returns The computed value.
     */
    get(): T;
    /**
     * Gets the raw value of the Subject.
     * @returns The raw value.
     */
    getRaw(): I;
    /** @inheritdoc */
    sub(handler: (v: T, rv: I) => void, initialNotify?: boolean, paused?: boolean): Subscription;
    /** @inheritdoc */
    unsub(handler: (v: T, rv: I) => void): void;
    /**
     * Notifies subscriptions that this subject's value has changed.
     */
    private notify;
    /**
     * Notifies a subscription of this subject's current state.
     * @param sub The subscription to notify.
     */
    private notifySubscription;
    /**
     * Responds to when a subscription to this subject is destroyed.
     * @param sub The destroyed subscription.
     */
    private onSubDestroyed;
    /**
     * Maps this subject to a new subscribable.
     * @param fn The function to use to map to the new subscribable.
     * @param equalityFunc The function to use to check for equality between mapped values. Defaults to the strict
     * equality comparison (`===`).
     * @returns The mapped subscribable.
     */
    map<M>(fn: (input: T, previousVal?: M) => M, equalityFunc?: ((a: M, b: M) => boolean)): MappedSubject<[T], M>;
    /**
     * Maps this subject to a new subscribable with a persistent, cached value which is mutated when it changes.
     * @param fn The function to use to map to the new subscribable.
     * @param equalityFunc The function to use to check for equality between mapped values.
     * @param mutateFunc The function to use to change the value of the mapped subscribable.
     * @param initialVal The initial value of the mapped subscribable.
     * @returns The mapped subscribable.
     */
    map<M>(fn: (input: T, previousVal?: M) => M, equalityFunc: ((a: M, b: M) => boolean), mutateFunc: ((oldVal: M, newVal: M) => void), initialVal: M): MappedSubject<[T], M>;
    /**
     * Subscribes to and pipes this subscribable's state to a mutable subscribable. Whenever an update of this
     * subscribable's state is received through the subscription, it will be used as an input to change the other
     * subscribable's state.
     * @param to The mutable subscribable to which to pipe this subscribable's state.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    pipe(to: MutableSubscribable<any, T>, paused?: boolean): Subscription;
    /**
     * Subscribes to this subscribable's state and pipes a mapped version to a mutable subscribable. Whenever an update
     * of this subscribable's state is received through the subscription, it will be transformed by the specified mapping
     * function, and the transformed state will be used as an input to change the other subscribable's state.
     * @param to The mutable subscribable to which to pipe this subscribable's mapped state.
     * @param map The function to use to transform inputs.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    pipe<M>(to: MutableSubscribable<any, M>, map: (input: T) => M, paused?: boolean): Subscription;
}

/**
 * A function which handles changes in an {@link ObjectSubject}'s state.
 */
declare type ObjectSubjectHandler<T extends Record<string, any>> = (v: Readonly<T>, key: keyof T, newValue: T[keyof T], oldValue: T[keyof T]) => void;
/**
 * A object-valued subscribable subject which supports setting individual properties on the object and notifying
 * subscribers of any changes to those properties.
 */
declare class ObjectSubject<T extends Record<string, any>> implements MutableSubscribable<Readonly<T>, Partial<Readonly<T>>> {
    private readonly obj;
    readonly isSubscribable = true;
    readonly isMutableSubscribable = true;
    private subs;
    private notifyDepth;
    private readonly initialNotifyFunc;
    private readonly onSubDestroyedFunc;
    /**
     * Constructs an observable object Subject.
     * @param obj The initial object.
     */
    private constructor();
    /**
     * Creates and returns a new ObjectSubject.
     * @param v The initial value of the subject.
     * @returns An ObjectSubject instance.
     */
    static create<IT>(v: IT): ObjectSubject<IT>;
    /**
     * Gets this subject's object.
     * @returns This subject's object.
     */
    get(): Readonly<T>;
    /** @inheritdoc */
    sub(handler: ObjectSubjectHandler<T>, initialNotify?: boolean, paused?: boolean): Subscription;
    /** @inheritdoc */
    unsub(handler: ObjectSubjectHandler<T>): void;
    /**
     * Sets the values of a subset of the properties of this subject's object and notifies subscribers if any of the
     * values changed.
     * @param value An object defining the values of the properties to set.
     */
    set(value: Partial<Readonly<T>>): void;
    /**
     * Sets the value of one of the properties of this subject's object and notifies subscribers if the value changed.
     * @param key The property to set.
     * @param value The new value.
     */
    set<K extends keyof T>(key: K, value: T[K]): void;
    /**
     * Notifies subscriptions that one of the properties of this subject's object has changed.
     * @param key The property of the object that changed.
     * @param oldValue The old value of the property that changed.
     */
    private notify;
    /**
     * Notifies a subscription of this subject's current state.
     * @param sub The subscription to notify.
     */
    private initialNotify;
    /**
     * Responds to when a subscription to this subscribable is destroyed.
     * @param sub The destroyed subscription.
     */
    private onSubDestroyed;
    /**
     * Maps this subject to a new subscribable.
     * @param fn The function to use to map to the new subscribable.
     * @param equalityFunc The function to use to check for equality between mapped values. Defaults to the strict
     * equality comparison (`===`).
     * @returns The mapped subscribable.
     */
    map<M>(fn: (input: T, previousVal?: M) => M, equalityFunc?: ((a: M, b: M) => boolean)): MappedSubject<[T], M>;
    /**
     * Maps this subject to a new subscribable with a persistent, cached value which is mutated when it changes.
     * @param fn The function to use to map to the new subscribable.
     * @param equalityFunc The function to use to check for equality between mapped values.
     * @param mutateFunc The function to use to change the value of the mapped subscribable.
     * @param initialVal The initial value of the mapped subscribable.
     * @returns The mapped subscribable.
     */
    map<M>(fn: (input: Readonly<T>, previousVal?: M) => M, equalityFunc: ((a: M, b: M) => boolean), mutateFunc: ((oldVal: M, newVal: M) => void), initialVal: M): MappedSubject<[Readonly<T>], M>;
    /**
     * Subscribes to and pipes this subscribable's state to a mutable subscribable. Whenever an update of this
     * subscribable's state is received through the subscription, it will be used as an input to change the other
     * subscribable's state.
     * @param to The mutable subscribable to which to pipe this subscribable's state.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    pipe(to: MutableSubscribable<any, T>, paused?: boolean): Subscription;
    /**
     * Subscribes to this subscribable's state and pipes a mapped version to a mutable subscribable. Whenever an update
     * of this subscribable's state is received through the subscription, it will be transformed by the specified mapping
     * function, and the transformed state will be used as an input to change the other subscribable's state.
     * @param to The mutable subscribable to which to pipe this subscribable's mapped state.
     * @param map The function to use to transform inputs.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    pipe<M>(to: MutableSubscribable<any, M>, map: (input: T) => M, paused?: boolean): Subscription;
}

/**
 * A subscribable set whose keys can be freely added and removed.
 */
declare class SetSubject<T> extends AbstractSubscribableSet<T> implements MutableSubscribable<ReadonlySet<T>>, MutableSubscribableSet<T> {
    readonly isMutableSubscribable = true;
    readonly isMutableSubscribableSet = true;
    private readonly backingSet;
    /**
     * Constructor.
     * @param initialKeys The keys with which to initialize this set. If not defined, this set will be initialized to the
     * empty set.
     */
    private constructor();
    /**
     * Creates and returns a new SetSubject.
     * @param initialKeys The keys initially contained in the new set. If not undefined, the new set will be initialized
     * to the empty set.
     * @returns A new SetSubject instance.
     */
    static create<T>(initialKeys?: Iterable<T>): SetSubject<T>;
    /** @inheritdoc */
    get(): ReadonlySet<T>;
    /**
     * Sets the keys contained in this set.
     * @param keys The keys to set.
     */
    set(keys: Iterable<T>): void;
    /** @inheritdoc */
    add(key: T): this;
    /** @inheritdoc */
    delete(key: T): boolean;
    /**
     * Removes all keys from this set.
     */
    clear(): void;
}

/**
 * An event to which handlers can be subscribed to be notified whenever the event is emitted.
 */
declare type ReadonlySubEvent<SenderType, DataType> = Omit<SubEvent<SenderType, DataType>, 'notify' | 'clear'>;
/**
 * An event which can be emitted with optional data to subscribers.
 */
declare class SubEvent<SenderType, DataType> {
    private subs;
    private notifyDepth;
    private readonly onSubDestroyedFunc;
    /**
     * Subscribes to this event.
     * @param handler A function to be called when an event is emitted.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    on(handler: (sender: SenderType, data: DataType) => void, paused?: boolean): Subscription;
    /**
     * Unsubscribes a callback function from this event.
     * @param handler The function to unsubscribe.
     * @deprecated This method has been deprecated in favor of using the {@link Subscription} object returned by `.on()`
     * to manage subscriptions.
     */
    off(handler: (sender: SenderType, data: DataType) => void): void;
    /**
     * Clears all subscriptions to this event.
     */
    clear(): void;
    /**
     * Emits an event to subscribers.
     * @param sender The source of the event.
     * @param data Data associated with the event.
     */
    notify(sender: SenderType, data: DataType): void;
    /**
     * Responds to when a subscription to this event is destroyed.
     * @param sub The destroyed subscription.
     */
    private onSubDestroyed;
}

/** Extracts the type argument from a Subject. */
declare type ExtractSubjectType<P> = P extends Subject<infer T> ? T : never;
/** Generates an indexed type with all the Subjects extracted. */
declare type ExtractSubjectTypes<P extends {
    [key: string]: Subject<any>;
}> = {
    [Key in keyof P]: ExtractSubjectType<P[Key]>;
};
/**
 * A subscribable subject whose value can be freely manipulated.
 */
declare class Subject<T> extends AbstractSubscribable<T> implements MutableSubscribable<T> {
    protected value: T;
    protected readonly equalityFunc: (a: T, b: T) => boolean;
    protected readonly mutateFunc?: ((oldVal: T, newVal: T) => void) | undefined;
    readonly isMutableSubscribable = true;
    /**
     * Constructs an observable Subject.
     * @param value The initial value.
     * @param equalityFunc The function to use to check for equality.
     * @param mutateFunc The function to use to mutate the subject's value.
     */
    protected constructor(value: T, equalityFunc: (a: T, b: T) => boolean, mutateFunc?: ((oldVal: T, newVal: T) => void) | undefined);
    /**
     * Creates and returns a new Subject.
     * @param v The initial value of the subject.
     * @param equalityFunc The function to use to check for equality between subject values. Defaults to the strict
     * equality comparison (`===`).
     * @param mutateFunc The function to use to change the subject's value. If not defined, new values will replace
     * old values by variable assignment.
     * @returns A Subject instance.
     */
    static create<IT>(v: IT, equalityFunc?: (a: IT, b: IT) => boolean, mutateFunc?: (oldVal: IT, newVal: IT) => void): Subject<IT>;
    /** @inheritdoc */
    protected notifySub(sub: (v: T) => void): void;
    /**
     * Sets the value of this subject and notifies subscribers if the value changed.
     * @param value The new value.
     */
    set(value: T): void;
    /**
     * Applies a partial set of properties to this subject's value and notifies subscribers if the value changed as a
     * result.
     * @param value The properties to apply.
     */
    apply(value: Partial<T>): void;
    /** @inheritdoc */
    notify(): void;
    /**
     * Gets the value of this subject.
     * @returns The value of this subject.
     */
    get(): T;
}

/**
 * Utility methods for working with Subscribables.
 */
declare class SubscribableUtils {
    /**
     * A numeric equality function which returns `true` if and only if two numbers are strictly equal or if they are both
     * `NaN`.
     * @param a The first number to compare.
     * @param b The second number to compare.
     * @returns Whether the two numbers are strictly equal or both `NaN`.
     */
    static readonly NUMERIC_NAN_EQUALITY: (a: number, b: number) => boolean;
    /**
     * Checks if a query is a subscribable.
     * @param query A query.
     * @returns Whether the query is a subscribable.
     */
    static isSubscribable<T = any>(query: unknown): query is Subscribable<T>;
    /**
     * Checks if a query is a mutable subscribable.
     * @param query A query.
     * @returns Whether the query is a mutable subscribable.
     */
    static isMutableSubscribable<T = any, I = any>(query: unknown): query is MutableSubscribable<T, I>;
    /**
     * Converts a value to a subscribable.
     *
     * If the `excludeSubscribables` argument is `true` and the value is already a subscribable, then the value is
     * returned unchanged. Otherwise, a new subscribable whose state is always equal to the value will be created and
     * returned.
     * @param value The value to convert to a subscribable.
     * @param excludeSubscribables Whether to return subscribable values as-is instead of wrapping them in another
     * subscribable.
     * @returns A subscribable.
     */
    static toSubscribable<V, Exclude extends boolean>(value: V, excludeSubscribables: Exclude): Exclude extends true ? (V extends Subscribable<any> ? V : Subscribable<V>) : Subscribable<V>;
}

/**
 * A consumer of events which optionally filters event data before passing the consumed events to handlers.
 */
interface Consumer<T> {
    /** Flags this object as a Consumer. */
    readonly isConsumer: true;
    /**
     * Handles an event using the provided event handler.
     * @param handler The event handler for the event.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns A new subscription for the provided handler.
     */
    handle(handler: Handler<T>, paused?: boolean): Subscription;
    /**
     * Disables handling of the event.
     * @param handler The handler to disable.
     * @deprecated This method has been deprecated in favor of using the {@link Subscription} object returned by
     * `.handle()` to manage subscriptions.
     */
    off(handler: Handler<T>): void;
    /**
     * Caps the event subscription to a specified frequency, in Hz.
     * @param frequency The frequency, in Hz, to cap to.
     * @param immediateFirstPublish Whether to fire once immediately before throttling.
     * @returns A new consumer with the applied frequency filter.
     */
    atFrequency(frequency: number, immediateFirstPublish?: boolean): Consumer<T>;
    /**
     * Quantizes the numerical event data to consume only at the specified decimal precision.
     * @param precision The decimal precision to snap to.
     * @returns A new consumer with the applied precision filter.
     */
    withPrecision(precision: number): Consumer<T>;
    /**
     * Filter the subscription to consume only when the value has changed by a minimum amount.
     * @param amount The minimum amount threshold below which the consumer will not consume.
     * @returns A new consumer with the applied change threshold filter.
     */
    whenChangedBy(amount: number): Consumer<T>;
    /**
     * Filter the subscription to consume only if the value has changed. At all.  Really only
     * useful for strings or other events that don't change much.
     * @returns A new consumer with the applied change threshold filter.
     */
    whenChanged(): Consumer<T>;
    /**
     * Filters events by time such that events will not be consumed until a minimum duration
     * has passed since the previous event.
     * @param deltaTime The minimum delta time between events.
     * @returns A new consumer with the applied change threshold filter.
     */
    onlyAfter(deltaTime: number): Consumer<T>;
}

/**
 * A typed container for subscribers interacting with the Event Bus.
 */
declare class EventSubscriber<E> {
    private bus;
    /**
     * Creates an instance of an EventSubscriber.
     * @param bus The EventBus that is the parent of this instance.
     */
    constructor(bus: EventBus);
    /**
     * Subscribes to a topic on the bus.
     * @param topic The topic to subscribe to.
     * @returns A consumer to bind the event handler to.
     */
    on<K extends keyof E & string>(topic: K): Consumer<E[K]>;
}

/** A handler for handling subscription data. */
declare type Handler<T> = (data: T) => void;
/** A handler for handling wildcard multiple subscription data. */
declare type WildcardHandler = (topic: string, data: any) => void;
/**
 * Meta-events published for event bus happenings.
 */
interface EventBusMetaEvents {
    /** General event bus topic, currently only used for resync requests. */
    event_bus: string;
    /** Notification that a topic has had a subscripiton.  */
    event_bus_topic_first_sub: string;
}
/**
 * An indexed event type. Indexed events have keys of the form `event_[index]`.
 */
declare type IndexedEventType<T extends string> = `${T}_${number}`;
/**
 * Mock event types.
 */
interface MockEventTypes {
    /** A random number event. */
    randomNumber: number;
}
/**
 * An interface that describes an event publisher.
 */
interface Publisher<E> {
    /**
     * Publishes an event with data to a topic.
     * @param topic The topic to publish to.
     * @param data The data to publish.
     * @param sync Whether or not to sync the data on the bus.
     * @param isCached Whether or not this event should be cached for retrieval.
     */
    pub<K extends keyof E>(topic: K, data: E[K], sync?: boolean, isCached?: boolean): void;
}
/**
 * An event bus that can be used to publish data from backend
 * components and devices to consumers.
 */
declare class EventBus {
    private _topicSubsMap;
    private _wildcardSubs;
    private _notifyDepthMap;
    private _wildcardNotifyDepth;
    private _eventCache;
    private _busSync;
    private _busId;
    protected readonly onWildcardSubDestroyedFunc: (sub: HandlerSubscription<WildcardHandler>) => void;
    /**
     * Creates an instance of an EventBus.
     * @param useAlternativeEventSync Whether or not to use coherent event sync (optional, default false).
     * If true, FlowEventSync will only work for gauges.
     */
    constructor(useAlternativeEventSync?: boolean);
    /**
     * Subscribes to a topic on the bus.
     * @param topic The topic to subscribe to.
     * @param handler The handler to be called when an event happens.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    on(topic: string, handler: Handler<any>, paused?: boolean): Subscription;
    /**
     * Unsubscribes a handler from the topic's events.
     * @param topic The topic to unsubscribe from.
     * @param handler The handler to unsubscribe from topic.
     * @deprecated This method has been deprecated in favor of using the {@link Subscription} object returned by `.on()`
     * to manage subscriptions.
     */
    off(topic: string, handler: Handler<any>): void;
    /**
     * Subscribes to all topics.
     * @param handler The handler to subscribe to all events.
     * @returns The new subscription.
     */
    onAll(handler: WildcardHandler): Subscription;
    /**
     * Unsubscribe the handler from all topics.
     * @param handler The handler to unsubscribe from all events.
     * @deprecated This method has been deprecated in favor of using the {@link Subscription} object returned by
     * `.onAll()` to manage subscriptions.
     */
    offAll(handler: WildcardHandler): void;
    /**
     * Publishes an event to the topic on the bus.
     * @param topic The topic to publish to.
     * @param data The data portion of the event.
     * @param sync Whether or not this message needs to be synced on local stoage.
     * @param isCached Whether or not this message will be resync'd across the bus on load.
     */
    pub(topic: string, data: any, sync?: boolean, isCached?: boolean): void;
    /**
     * Responds to when a wildcard subscription is destroyed.
     * @param sub The destroyed subscription.
     */
    private onWildcardSubDestroyed;
    /**
     * Re-sync all synced events
     */
    private resyncEvents;
    /**
     * Publish an event to the sync bus.
     * @param topic The topic to publish to.
     * @param data The data to publish.
     * @param isCached Whether or not this message will be resync'd across the bus on load.
     */
    private syncEvent;
    /**
     * Gets a typed publisher from the event bus..
     * @returns The typed publisher.
     */
    getPublisher<E>(): Publisher<E>;
    /**
     * Gets a typed subscriber from the event bus.
     * @returns The typed subscriber.
     */
    getSubscriber<E>(): EventSubscriber<E>;
    /**
     * Get the number of subscribes for a given topic.
     * @param topic The name of the topic.
     * @returns The number of subscribers.
     **/
    getTopicSubscriberCount(topic: string): number;
}

/**
 * The available facility frequency types.
 */
declare enum FacilityFrequencyType {
    None = 0,
    ATIS = 1,
    Multicom = 2,
    Unicom = 3,
    CTAF = 4,
    Ground = 5,
    Tower = 6,
    Clearance = 7,
    Approach = 8,
    Departure = 9,
    Center = 10,
    FSS = 11,
    AWOS = 12,
    ASOS = 13,
    /** Clearance Pre-Taxi*/
    CPT = 14,
    /** Remote Clearance Delivery */
    GCO = 15
}
/**
 * A radio frequency on facility data.
 */
interface FacilityFrequency {
    /** The name of the frequency. */
    readonly name: string;
    /** The frequency, in MHz. */
    readonly freqMHz: number;
    /** The frequency, in BCD16. */
    readonly freqBCD16: number;
    /** The type of the frequency. */
    readonly type: FacilityFrequencyType;
}
/**
 * An ILS frequency on airport runway data.
 */
interface FacilityILSFrequency {
    /** The ICAO of the ILS frequency. */
    readonly icao: string;
    /** The name of the frequency. */
    readonly name: string;
    /** The frequency, in MHz. */
    readonly freqMHz: number;
    /** The frequency, in BCD16. */
    readonly freqBCD16: number;
    /** The type of the frequency. */
    readonly type: FacilityFrequencyType;
    /** Whether or not this ILS has a glideslope. */
    readonly hasGlideslope: boolean;
    /** The glideslope angle for this localizer. */
    readonly glideslopeAngle: number;
    /** The course, in degrees true, for this localizer. */
    readonly localizerCourse: number;
    /** The magvar at this localizer's position. */
    readonly magvar: number;
}
/**
 * A runway on airport facility data.
 */
interface AirportRunway {
    /** The latitude of the runway center. */
    readonly latitude: number;
    /** The longitude of the runway center. */
    readonly longitude: number;
    /** The runway elevation in meters. */
    readonly elevation: number;
    /** The heading of the runway. */
    readonly direction: number;
    /** The runway designation. */
    readonly designation: string;
    /** The length of the runway in meters. */
    readonly length: number;
    /** The width of the runway in meters. */
    readonly width: number;
    /** The runway surface type. */
    readonly surface: RunwaySurfaceType;
    /** The runway lighting type. */
    readonly lighting: RunwayLightingType;
    /** The primary runway designator character. */
    readonly designatorCharPrimary: RunwayDesignator;
    /** The secondary runway designator character. */
    readonly designatorCharSecondary: RunwayDesignator;
    /** The primary ILS frequency for the runway. */
    readonly primaryILSFrequency: FacilityILSFrequency;
    /** The secondary ILS frequency for the runway. */
    readonly secondaryILSFrequency: FacilityILSFrequency;
    /** The primary elevation for the runway in meters. */
    readonly primaryElevation: number;
    /** The primary displaced threshold distance from the start of the runway in meters. */
    readonly primaryThresholdLength: number;
    /** The primary elevation for the runway in meters. */
    readonly secondaryElevation: number;
    /** The primary displaced threshold distance from the start of the runway in meters. */
    readonly secondaryThresholdLength: number;
}
/**
 * A segment of an airway.
 */
interface AirwaySegment {
    /** The name of the airway */
    readonly name: string;
    /** The type of the airway. */
    readonly type: number;
    /** The previous FS ICAO on the airway. */
    readonly prevIcao: string;
    /** The next FS ICAO on the airway. */
    readonly nextIcao: string;
}
/**
 * A navdata airway.
 */
interface Airway {
    /** The name of the airway.*/
    readonly name: string;
    /** The type of the airway. */
    readonly type: number;
    /** The FS ICAOs that make up the airway. */
    readonly icaos: readonly string[];
}
/**
 * A leg in a flight plan or procedure.
 */
interface FlightPlanLeg {
    /** The ARINC-424 leg type. */
    type: LegType;
    /** The ICAO of the fix, if specified. */
    fixIcao: string;
    /** Whether or not the fix is a flyover fix. */
    flyOver: boolean;
    /** Whether or not the distance is minutes of time. */
    distanceMinutes: boolean;
    /** Whether or not the course is true or magnetic. */
    trueDegrees: boolean;
    /** The direction of the turn for the leg, if any. */
    turnDirection: LegTurnDirection;
    /** A reference ICAO for legs that have relative information. */
    originIcao: string;
    /** A center fix ICAO for legs that require it. */
    arcCenterFixIcao: string;
    /** The theta of the leg. */
    theta: number;
    /** The rho of the leg. */
    rho: number;
    /** The course of the leg. */
    course: number;
    /** The distance for the leg, in meters. */
    distance: number;
    /** Any speed restriction for the leg, in knots IAS. */
    speedRestriction: number;
    /** The type of altitude restriction for the leg. */
    altDesc: AltitudeRestrictionType;
    /** The first altitude field for restrictions. */
    altitude1: number;
    /** The second altitude field for restrictions. */
    altitude2: number;
    /** An exact latitude for this leg termination. */
    lat?: number;
    /** An exact longitude for this leg termination. */
    lon?: number;
    /** Flags indicating the approach fix type. */
    fixTypeFlags: number;
}
/** Additional Approach Types (additive to those defined in simplane). */
declare enum AdditionalApproachType {
    APPROACH_TYPE_VISUAL = 99
}
/** Approach Types inclusive of default ApproachType and AdditionalApproachType. */
declare type ExtendedApproachType = ApproachType | AdditionalApproachType;
/**
 * Flags indicating the approach fix type.
 */
declare enum FixTypeFlags {
    None = 0,
    IAF = 1,
    IF = 2,
    MAP = 4,
    FAF = 8,
    MAHP = 16
}
/**
 * Flags indicating the rnav approach type.
 */
declare enum RnavTypeFlags {
    None = 0,
    LNAV = 1,
    LNAVVNAV = 2,
    LP = 4,
    LPV = 8
}
/**
 * An arrival transition for a particular selected runway.
 */
interface RunwayTransition {
    /** The number of the runway. */
    readonly runwayNumber: number;
    /** The letter designation for the runway, if any (L, C, R) */
    readonly runwayDesignation: number;
    /** The legs that make up this procedure. */
    readonly legs: readonly Readonly<FlightPlanLeg>[];
}
/**
 * An enroute transition for an arrival.
 */
interface EnrouteTransition {
    /** The name for this transition. */
    readonly name: string;
    /** The legs that make up this procedure. */
    readonly legs: readonly Readonly<FlightPlanLeg>[];
}
/**
 * An arrival-to-approach transition.
 */
interface ApproachTransition {
    /** The name for this transition. */
    readonly name: string;
    /** The legs that make up this procedure. */
    readonly legs: readonly Readonly<FlightPlanLeg>[];
}
/**
 * An approach procedure.
 */
interface ApproachProcedure {
    /** The name of the approach procedure. */
    readonly name: string;
    /** The approach runway designation. */
    readonly runway: string;
    /** The ICAOs associated with this procedure. */
    readonly icaos: readonly string[];
    /** Transitions from the arrival that are available on this procedure. */
    readonly transitions: readonly ApproachTransition[];
    /** The common legs of the procedure for all transitions. */
    readonly finalLegs: readonly Readonly<FlightPlanLeg>[];
    /** The legs of the procedure for the missed approach segment. */
    readonly missedLegs: readonly Readonly<FlightPlanLeg>[];
    /** The approach type. */
    readonly approachType: ExtendedApproachType;
    /** The approach name suffix. */
    readonly approachSuffix: string;
    /** The approach runway designator. */
    readonly runwayDesignator: RunwayDesignator;
    /** The approach runway number. */
    readonly runwayNumber: number;
    /** The approach RNAV Type Flag. */
    readonly rnavTypeFlags: RnavTypeFlags;
}
/** Common interface for procedures. */
interface Procedure {
    /** The name of the departure. */
    readonly name: string;
    /** The legs of the procedure that are common to all selected transitions and runways. */
    readonly commonLegs: readonly Readonly<FlightPlanLeg>[];
    /** The transition from the departure to the enroute segment. */
    readonly enRouteTransitions: readonly EnrouteTransition[];
    /** The transition from the selected runway to the common procedure legs. */
    readonly runwayTransitions: readonly RunwayTransition[];
}
/**
 * A departure procedure (SID).
 */
declare type DepartureProcedure = Procedure;
/**
 * An arrival procedure (STAR).
 */
declare type ArrivalProcedure = Procedure;
/**
 * A navdata facility from the simulator.
 */
interface Facility {
    /** The FS ICAO for this facility. */
    readonly icao: string;
    /** The name of the facility. */
    readonly name: string;
    /** The latitude of the facility. */
    readonly lat: number;
    /** The longitude of the facility. */
    readonly lon: number;
    /** The region code in which this facility appears. */
    readonly region: string;
    /** The city region boundary within which this facility appears.*/
    readonly city: string;
    /** The magnetic variation at a given facilty location. */
    readonly magvar: number;
}
/**
 * An airport facility from the simulator.
 */
interface AirportFacility extends Facility {
    /** The privacy type of this airport. */
    readonly airportPrivateType: AirportPrivateType;
    /** The primary fuel available at this airport. */
    readonly fuel1: string;
    /** The secondary fuel available at this airport. */
    readonly fuel2: string;
    /** The name of the preferred airport approach. */
    readonly bestApproach: string;
    /** Whether or not the airport has radar coverage. */
    readonly radarCoverage: GpsBoolean;
    /** The type of airspace for the airport. */
    readonly airspaceType: number;
    /** The class of the airport. */
    readonly airportClass: number;
    /** Whether or not the airport is towered. */
    readonly towered: boolean;
    /** The frequencies available on the airport. */
    readonly frequencies: readonly FacilityFrequency[];
    /** The runways available on the airport. */
    readonly runways: AirportRunway[];
    /** The departure procedures on the airport. */
    readonly departures: readonly DepartureProcedure[];
    /** The approach procedures on the airport. */
    readonly approaches: readonly ApproachProcedure[];
    /** The arrival procedures on the airport. */
    readonly arrivals: readonly ArrivalProcedure[];
}
/**
 * The class of airport facility.
 */
declare enum AirportClass {
    /** No other airport class could be identified. */
    None = 0,
    /** The airport has at least one hard surface runway. */
    HardSurface = 1,
    /** The airport has no hard surface runways. */
    SoftSurface = 2,
    /** The airport has only water surface runways. */
    AllWater = 3,
    /** The airport has no runways, but does contain helipads. */
    HeliportOnly = 4,
    /** The airport is a non-public use airport. */
    Private = 5
}
/**
 * The class of an airport facility, expressed as a mask for nearest airport search session filtering.
 */
declare enum AirportClassMask {
    /** No other airport class could be identified. */
    None = 0,
    /** The airport has at least one hard surface runway. */
    HardSurface = 2,
    /** The airport has no hard surface runways. */
    SoftSurface = 4,
    /** The airport has only water surface runways. */
    AllWater = 8,
    /** The airport has no runways, but does contain helipads. */
    HeliportOnly = 16,
    /** The airport is a non-public use airport. */
    Private = 32
}
/**
 * An intersection facility.
 */
interface IntersectionFacility extends Facility {
    /** The airway segments that are adjacent to this */
    readonly routes: readonly AirwaySegment[];
    /** The FS ICAO of the nearest VOR to this intersection. */
    readonly nearestVorICAO: string;
    /** The type of the nearest VOR. */
    readonly nearestVorType: VorType;
    /** The frequency of the nearest VOR, in BCD16. */
    readonly nearestVorFrequencyBCD16: number;
    /** The frequency of the nearest VOR, in MHz. */
    readonly nearestVorFrequencyMHz: number;
    /** The radial in degrees true from the nearest VOR that the intersection lies on. */
    readonly nearestVorTrueRadial: number;
    /** The radial in degrees magnetic from the nearest VOR that the intersection lies on. */
    readonly nearestVorMagneticRadial: number;
    /** This distance to the nearest VOR. */
    readonly nearestVorDistance: number;
}
/**
 * An enumeration of possible intersection types.
 */
declare enum IntersectionType {
    None = 0,
    Named = 1,
    Unnamed = 2,
    Vor = 3,
    NDB = 4,
    Offroute = 5,
    IAF = 6,
    FAF = 7,
    RNAV = 8,
    VFR = 9
}
/**
 * A VOR facility.
 */
interface VorFacility extends Facility {
    /** The frequency of the VOR, in MHz. */
    readonly freqMHz: number;
    /** The frequency of the VOR, in BCD16. */
    readonly freqBCD16: number;
    /** The magnetic variation of the specific VOR. */
    readonly magneticVariation: number;
    /** The type of the VOR. */
    readonly type: VorType;
    /** The class of the VOR. */
    readonly vorClass: VorClass;
}
/**
 * A NDB facility.
 */
interface NdbFacility extends Facility {
    /** The frequency of the facility, in MHz. */
    readonly freqMHz: number;
    /** The type of NDB. */
    readonly type: NdbType;
}
/**
 * A User Waypoint facility.
 */
interface UserFacility extends Facility {
    /** If the user waypoint is temporary. */
    isTemporary: boolean;
    /** The type of user facility this is. */
    userFacilityType: UserFacilityType;
    /** The First Reference Facility. */
    referenceFacility1?: Facility;
    /** The First Reference Facility distance. */
    facility1Distance?: number;
    /** The First Reference Facility radial. */
    facility1Radial?: number;
    /** The Second Reference Facility. */
    referenceFacility2?: Facility;
    /** The Second Reference Facility radial. */
    facility2Radial?: number;
}
declare enum UserFacilityType {
    RADIAL_RADIAL = 0,
    RADIAL_DISTANCE = 1,
    LAT_LONG = 2
}
/**
 * A runway waypoint facility.
 */
interface RunwayFacility extends Facility {
    /** The runway associated with this facility. */
    readonly runway: OneWayRunway;
}
/**
 * A visual approach waypoint facility.
 */
interface VisualFacility extends Facility {
    /** The name of the approach to which this facility belongs. */
    readonly approach: string;
}
/**
 * ARINC 424 Leg Types
 */
declare enum LegType {
    /** An unknown leg type. */
    Unknown = 0,
    /** An arc-to-fix leg. This indicates a DME arc leg to a specified fix.*/
    AF = 1,
    /** A course-to-altitude leg. */
    CA = 2,
    /**
     * A course-to-DME-distance leg. This leg is flown on a wind corrected course
     * to a specific DME distance from another fix.
     */
    CD = 3,
    /** A course-to-fix leg.*/
    CF = 4,
    /** A course-to-intercept leg. */
    CI = 5,
    /** A course-to-radial intercept leg. */
    CR = 6,
    /** A direct-to-fix leg, from an unspecified starting position. */
    DF = 7,
    /**
     * A fix-to-altitude leg. A FA leg is flown on a track from a fix to a
     * specified altitude.
     */
    FA = 8,
    /**
     * A fix-to-distance leg. This leg is flown on a track from a fix to a
     * specific distance from the fix.
     */
    FC = 9,
    /**
     * A fix to DME distance leg. This leg is flown on a track from a fix to
     * a specific DME distance from another fix.
     */
    FD = 10,
    /** A course-to-manual-termination leg. */
    FM = 11,
    /** A hold-to-altitude leg. The hold is flown until a specified altitude is reached. */
    HA = 12,
    /**
     * A hold-to-fix leg. This indicates one time around the hold circuit and
     * then an exit.
     */
    HF = 13,
    /** A hold-to-manual-termination leg. */
    HM = 14,
    /** Initial procedure fix. */
    IF = 15,
    /** A procedure turn leg. */
    PI = 16,
    /** A radius-to-fix leg, with endpoint fixes, a center fix, and a radius. */
    RF = 17,
    /** A track-to-fix leg, from the previous fix to the terminator. */
    TF = 18,
    /** A heading-to-altitude leg. */
    VA = 19,
    /** A heading-to-DME-distance leg. */
    VD = 20,
    /** A heading-to-intercept leg. */
    VI = 21,
    /** A heading-to-manual-termination leg. */
    VM = 22,
    /** A heading-to-radial intercept leg. */
    VR = 23,
    /** A leg representing a discontinuity in the flight plan. */
    Discontinuity = 99,
    /** A leg representing a discontinuity in the flight plan that does not prevent sequencing. */
    ThruDiscontinuity = 100
}
/**
 * Types of altitude restrictions on procedure legs.
 */
declare enum AltitudeRestrictionType {
    Unused = 0,
    At = 1,
    AtOrAbove = 2,
    AtOrBelow = 3,
    Between = 4
}
declare enum LegTurnDirection {
    None = 0,
    Left = 1,
    Right = 2,
    Either = 3
}
declare enum AirwayType {
    None = 0,
    Victor = 1,
    Jet = 2,
    Both = 3
}
declare enum NdbType {
    CompassPoint = 0,
    MH = 1,
    H = 2,
    HH = 3
}
declare enum VorType {
    Unknown = 0,
    VOR = 1,
    VORDME = 2,
    DME = 3,
    TACAN = 4,
    VORTAC = 5,
    ILS = 6,
    VOT = 7
}
declare enum RunwaySurfaceType {
    Concrete = 0,
    Grass = 1,
    WaterFSX = 2,
    GrassBumpy = 3,
    Asphalt = 4,
    ShortGrass = 5,
    LongGrass = 6,
    HardTurf = 7,
    Snow = 8,
    Ice = 9,
    Urban = 10,
    Forest = 11,
    Dirt = 12,
    Coral = 13,
    Gravel = 14,
    OilTreated = 15,
    SteelMats = 16,
    Bituminous = 17,
    Brick = 18,
    Macadam = 19,
    Planks = 20,
    Sand = 21,
    Shale = 22,
    Tarmac = 23,
    WrightFlyerTrack = 24,
    Ocean = 26,
    Water = 27,
    Pond = 28,
    Lake = 29,
    River = 30,
    WasteWater = 31,
    Paint = 32
}
declare enum RunwayLightingType {
    Unknown = 0,
    None = 1,
    PartTime = 2,
    FullTime = 3,
    Frequency = 4
}
/**
 * Describes a selected one way runway.
 */
interface OneWayRunway {
    /** The index of this runway's parent AirportRunway object in the airport facility. */
    readonly parentRunwayIndex: number;
    /** The runway number of this runway (as the numerical value of the one way designation). */
    readonly direction: number;
    /** The runwayDesignator of this runway. */
    readonly runwayDesignator: RunwayDesignator;
    /** The designation of this runway. */
    readonly designation: string;
    /** The latitude of the start of this runway. */
    readonly latitude: number;
    /** The longitude of the start of this runway. */
    readonly longitude: number;
    /** The elevation of this runway, at the displaced threshold, in meters. */
    readonly elevation: number;
    /** The true course of this runway in degrees. */
    readonly course: number;
    /** The ILS frequency for this runway. */
    readonly ilsFrequency?: FacilityILSFrequency;
    /** The total length of this runway, including displaced thresholds, in meters. */
    readonly length: number;
    /** The distance, in meters, between the start of this runway and the displaced threshold on that end. */
    readonly startThresholdLength: number;
    /** The distance, in meters, between the end of this runway and the displaced threshold on that end. */
    readonly endThresholdLength: number;
}
declare enum AirportPrivateType {
    Uknown = 0,
    Public = 1,
    Military = 2,
    Private = 3
}
declare enum GpsBoolean {
    Unknown = 0,
    No = 1,
    Yes = 2
}
declare enum VorClass {
    Unknown = 0,
    Terminal = 1,
    LowAlt = 2,
    HighAlt = 3,
    ILS = 4,
    VOT = 5
}
declare enum FacilityType {
    Airport = "LOAD_AIRPORT",
    Intersection = "LOAD_INTERSECTION",
    VOR = "LOAD_VOR",
    NDB = "LOAD_NDB",
    USR = "USR",
    RWY = "RWY",
    VIS = "VIS"
}
/**
 * A type map of FacilityType enum to facility type.
 */
declare type FacilityTypeMap = {
    /** Airport facility. */
    [FacilityType.Airport]: AirportFacility;
    /** VOR facility. */
    [FacilityType.VOR]: VorFacility;
    /** NDB facility. */
    [FacilityType.NDB]: NdbFacility;
    /** Intersection facility. */
    [FacilityType.Intersection]: IntersectionFacility;
    /** User waypoint facility. */
    [FacilityType.USR]: UserFacility;
    /** Runway waypoint facility. */
    [FacilityType.RWY]: RunwayFacility;
    /** Visual approach waypoint facility. */
    [FacilityType.VIS]: VisualFacility;
};
declare enum FacilitySearchType {
    All = 0,
    Airport = 1,
    Intersection = 2,
    Vor = 3,
    Ndb = 4,
    Boundary = 5,
    User = 6
}
/**
 * All of the FacilitySearchTypes except for Boundary, because it does not have a lat lon
 */
declare type FacilitySearchTypeLatLon = FacilitySearchType.All | FacilitySearchType.Airport | FacilitySearchType.Intersection | FacilitySearchType.Vor | FacilitySearchType.Ndb | FacilitySearchType.User;
/**
 * Results from the completion of a nearest facilities search.
 */
interface NearestSearchResults<TAdded, TRemoved> {
    /** The ID of the search session these results belong to. */
    readonly sessionId: number;
    /** The ID of the search that was performed. */
    readonly searchId: number;
    /** The list of items added since the previous search. */
    readonly added: readonly TAdded[];
    /** The list of items removed since the previous search. */
    readonly removed: readonly TRemoved[];
}
/**
 * A facility that describes an airspace boundary.
 */
interface BoundaryFacility {
    /** The unique ID of the boundary. */
    readonly id: number;
    /** The name of the boundary. */
    readonly name: string;
    /** The airspace type of the boundary. */
    readonly type: BoundaryType;
    /** The minimum altitude for the boundary. */
    readonly minAlt: number;
    /** The maximum altitude for the boundary. */
    readonly maxAlt: number;
    /** The minimum altitude type. */
    readonly minAltType: BoundaryAltitudeType;
    /** The maximum altitude type. */
    readonly maxAltType: BoundaryAltitudeType;
    /** The top left corner of the bounding box for the boundary. */
    readonly topLeft: LatLong;
    /** The bottom right corner of the bounding box for the boundary. */
    readonly bottomRight: LatLong;
    /** The vectors that describe the boundary borders. */
    readonly vectors: BoundaryVector[];
    /** LODs of the vectors that describe the boundary borders. */
    readonly lods?: BoundaryVector[][];
}
/**
 * A type of airspace boundary.
 */
declare enum BoundaryType {
    None = 0,
    Center = 1,
    ClassA = 2,
    ClassB = 3,
    ClassC = 4,
    ClassD = 5,
    ClassE = 6,
    ClassF = 7,
    ClassG = 8,
    Tower = 9,
    Clearance = 10,
    Ground = 11,
    Departure = 12,
    Approach = 13,
    MOA = 14,
    Restricted = 15,
    Prohibited = 16,
    Warning = 17,
    Alert = 18,
    Danger = 19,
    NationalPark = 20,
    ModeC = 21,
    Radar = 22,
    Training = 23
}
/**
 * A type of airspace boundary altitude maxima.
 */
declare enum BoundaryAltitudeType {
    Unknown = 0,
    MSL = 1,
    AGL = 2,
    Unlimited = 3
}
/**
 * A vector in a boundary border geometry.
 */
interface BoundaryVector {
    /** The type of the vector. */
    readonly type: BoundaryVectorType;
    /**
     * The origin ID of the vector. If the type is Origin, then this is the ID of the
     * vector. If the type is not Origin, then this is the ID of the origin vector
     * that relates to the current vector.
     */
    readonly originId: number;
    /** The latitude of the vector. */
    readonly lat: number;
    /** The longitude of the vector. */
    readonly lon: number;
    /** The radius of the vector, if any. */
    readonly radius: number;
}
/**
 * A type of boundary geometry vector.
 */
declare enum BoundaryVectorType {
    None = 0,
    Start = 1,
    Line = 2,
    Origin = 3,
    ArcCW = 4,
    ArcCCW = 5,
    Circle = 6
}
/**
 * A METAR.
 */
interface Metar {
    /** The ident of this METAR's airport. */
    readonly icao: string;
    /** The day of observation, in UTC time. */
    readonly day: number;
    /** The hour of observation, in UTC time. */
    readonly hour: number;
    /** The minute of observation, in UTC time. */
    readonly min: number;
    /** The wind direction, in degrees relative to true north. */
    readonly windDir: number;
    /** The wind speed, expressed in units defined by `windSpeedUnits`. */
    readonly windSpeed: number;
    /** The wind gust, expressed in units defined by `windSpeedUnits`. */
    readonly gust?: number;
    /** The units in which this METAR's wind speeds are reported. */
    readonly windSpeedUnits: MetarWindSpeedUnits;
    /** Whether winds are variable. */
    readonly vrb: boolean;
    /** Whether ceiling and visibility are OK. */
    readonly cavok: boolean;
    /** The visibility, expressed in units defined by `visUnits`. */
    readonly vis: number;
    /** The units in which this METAR's visibility is reported. */
    readonly visUnits: MetarVisibilityUnits;
    /** Whether the observed visibility is less than the reported visibility. */
    readonly visLt: boolean;
    /** Cloud layers. */
    readonly layers: readonly MetarCloudLayer[];
    /** The vertical visibility, in hundreds of feet. */
    readonly vertVis?: number;
    /** The temperature, in degrees Celsius. */
    readonly temp: number;
    /** The dew point, in degrees Celsius. */
    readonly dew: number;
    /** The altimeter setting, in inHg. */
    readonly altimeterA?: number;
    /** The altimeter setting, in hPa. */
    readonly altimeterQ?: number;
    /** The estimated sea-level pressure, in hPa. */
    readonly slp?: number;
    /** Significant weather phenomena. */
    readonly phenomena: readonly MetarPhenomenon[];
    /** Whether this METAR contains remarks. */
    readonly rmk: boolean;
    /** A formatted string representation of this METAR. */
    readonly metarString: string;
}
/**
 * Wind speed units used by METAR.
 */
declare enum MetarWindSpeedUnits {
    Knot = 0,
    MeterPerSecond = 1,
    KilometerPerHour = 2
}
/** Visibility distance units used by METAR. */
declare enum MetarVisibilityUnits {
    Meter = 0,
    StatuteMile = 1
}
/**
 * A METAR cloud layer description.
 */
interface MetarCloudLayer {
    /** The altitude of this layer, in hundreds of feet. */
    readonly alt: number;
    /** The coverage of this layer. */
    readonly cover: MetarCloudLayerCoverage;
    /** The significant cloud type found in this layer. */
    readonly type: MetarCloudLayerType;
}
/**
 * METAR cloud layer coverage/sky condition.
 */
declare enum MetarCloudLayerCoverage {
    SkyClear = 0,
    Clear = 1,
    NoSignificant = 2,
    Few = 3,
    Scattered = 4,
    Broken = 5,
    Overcast = 6
}
/**
 * METAR significant cloud types.
 */
declare enum MetarCloudLayerType {
    Unspecified = -1,
    ToweringCumulus = 0,
    Cumulonimbus = 1,
    AltocumulusCastellanus = 2
}
/**
 * A METAR weather phenomenon.
 */
interface MetarPhenomenon {
    /** The type of this phenomenon. */
    readonly phenom: MetarPhenomenonType;
    /**
     * The intensity of this phenomenon.
     */
    readonly intensity: MetarPhenomenonIntensity;
    /** Whether this phenomenon has the blowing modifier. */
    readonly blowing: boolean;
    /** Whether this phenomenon has the freezing modifier. */
    readonly freezing: boolean;
    /** Whether this phenomenon has the drifting modifier. */
    readonly drifting: boolean;
    /** Whether this phenomenon has the vicinity modifier. */
    readonly vicinity: boolean;
    /** Whether this phenomenon has the partial modifier. */
    readonly partial: boolean;
    /** Whether this phenomenon has the shallow modifier. */
    readonly shallow: boolean;
    /** Whether this phenomenon has the patches modifier. */
    readonly patches: boolean;
    /** Whether this phenomenon has the temporary modifier. */
    readonly tempo: boolean;
}
/** METAR phenomenon types. */
declare enum MetarPhenomenonType {
    None = 0,
    Mist = 1,
    Duststorm = 2,
    Dust = 3,
    Drizzle = 4,
    FunnelCloud = 5,
    Fog = 6,
    Smoke = 7,
    Hail = 8,
    SmallHail = 9,
    Haze = 10,
    IceCrystals = 11,
    IcePellets = 12,
    DustSandWhorls = 13,
    Spray = 14,
    Rain = 15,
    Sand = 16,
    SnowGrains = 17,
    Shower = 18,
    Snow = 19,
    Squalls = 20,
    Sandstorm = 21,
    UnknownPrecip = 22,
    VolcanicAsh = 23
}
/** METAR phenomenon intensities. */
declare enum MetarPhenomenonIntensity {
    Light = -1,
    Normal = 0,
    Heavy = 1
}
/**
 * Methods for working with FS ICAO strings.
 */
declare class ICAO {
    /**
     * An empty ICAO.
     */
    static readonly emptyIcao = "            ";
    /**
     * Gets the facility type from an ICAO.
     * @param icao The icao to get the facility type for.
     * @returns The ICAO facility type.
     * @throws An error if the facility type cannot be determined.
     */
    static getFacilityType(icao: string): FacilityType;
    /**
     * Returns the ident of the icao's associated airport. (ex. for terminal waypoints)
     * @param icao The icao to get the airport ident for.
     * @returns The airport ident.
     */
    static getAssociatedAirportIdent(icao: string): string;
    /**
     * Gets whether an icao is a facility type.
     * @param icao The icao to get the facility type for.
     * @returns a bool whether or not this icao is a facility type.
     */
    static isFacility(icao: string): boolean;
    /**
     * Gets the ident for a given ICAO string.
     * @param icao The FS ICAO to get the ident for.
     * @returns The ICAO ident.
     */
    static getIdent(icao: string): string;
    /**
     * Gets the region code for a given ICAO string.
     * @param icao The FS ICAO to get the ident for.
     * @returns The two letter region code.
     */
    static getRegionCode(icao: string): string;
}
/**
 * Utility functions for working with user facilities.
 */
declare class UserFacilityUtils {
    /**
     * Creates a user facility from latitude/longitude coordinates.
     * @param icao The ICAO string of the new facility.
     * @param lat The latitude of the new facility.
     * @param lon The longitude of the new facility.
     * @param isTemporary Whether the new facility is temporary.
     * @param name The name of the new facility.
     * @returns A new user facility.
     */
    static createFromLatLon(icao: string, lat: number, lon: number, isTemporary?: boolean, name?: string): UserFacility;
}
/**
 * Utilities to deal with TACAN facilities.
 */
declare class TacanUtils {
    /**
     * Converts a VOR frequency to a TACAN channel.
     * @param frequency The frequency of the VOR.
     * @returns The TACAN channel.
     */
    static frequencyToChannel(frequency: number): string;
}

/**
 * Itl functions for array operations.
 */
declare class ArrayUtils {
    /**
     * Gets the length of the longest string in the array.
     * @param array The array to search in.
     * @returns length of the longest string
     */
    static getMaxStringLength(array: string[]): number;
}

/**
 * A binary min-heap. Each element added to the heap is ordered according to the value of an assigned key relative
 * to the keys of the other elements in the heap. The relative values of element keys are defined by a supplied
 * comparator function. Retrieval of the element with the smallest key (minimum element) is performed in constant time.
 * Removal of the minimum element and insertions are performed in logarithmic time. Additionally, this type of heap
 * supports combined insertion and removal operations (in either order) which are slightly more efficient than chaining
 * the two operations separately.
 */
declare class BinaryHeap<T> {
    private readonly comparator;
    private readonly tree;
    /** The number of elements contained in this heap. */
    get size(): number;
    /**
     * Constructor.
     * @param comparator The function that this heap uses to compare the keys of its elements. The function returns 0 if
     * `a` and `b` share the same key, a negative number if `a` has a lower key than `b`, and a positive number if `a`
     * has a greater key than `b`.
     */
    constructor(comparator: (a: T, b: T) => number);
    /**
     * Finds the element in this heap with the smallest key.
     * @returns The element in this heap with the smallest key, or undefined if this heap is empty.
     */
    findMin(): T | undefined;
    /**
     * Removes and returns the element in this heap with the smallest key.
     * @returns The removed element, or undefined if this heap is empty.
     */
    removeMin(): T | undefined;
    /**
     * Inserts an element into this heap.
     * @param element The element to insert.
     * @returns This heap, after the element has been inserted.
     */
    insert(element: T): this;
    /**
     * Inserts an element into this heap, then removes the element with the smallest key.
     * @param element The element to insert.
     * @returns The removed element.
     */
    insertAndRemoveMin(element: T): T;
    /**
     * Removes the element in this heap with the smallest key, then inserts a new element.
     * @param element The element to insert.
     * @returns The removed element, or undefined if this heap was empty before the new element was inserted.
     */
    removeMinAndInsert(element: T): T | undefined;
    /**
     * Removes all elements from this heap.
     * @returns This heap, after it has been cleared.
     */
    clear(): this;
    /**
     * Restores the heap property for this heap upwards from a node which potentially violates the property.
     * @param index The index of the node at which to begin the operation.
     */
    private heapifyUp;
    /**
     * Restores the heap property for this heap downwards from a node which potentially violates the property.
     * @param index The index of the node at which to begin the operation.
     */
    private heapifyDown;
    /**
     * Swaps two nodes in this heap.
     * @param index1 The index of the first node.
     * @param index2 The index of the second node.
     */
    private swap;
    /**
     * Finds the index of a node's parent.
     * @param index the index of the node for which to find the parent.
     * @returns The index of the query node's parent.
     */
    private static parent;
    /**
     * Finds the index of a node's left child.
     * @param index The index of the node for which to find the child.
     * @returns The index of the query node's left child.
     */
    private static left;
    /**
     * Finds the index of a node's right child.
     * @param index The index of the node for which to find the child.
     * @returns The idnex of the query node's right child.
     */
    private static right;
}

/**
 * A binominal min-heap. Each element added to the heap is ordered according to the value of an assigned key relative
 * to the keys of the other elements in the heap. The relative values of element keys are defined by a supplied
 * comparator function. Retrieval of the element with the smallest key (minimum element) is performed in constant time.
 * Removal of the minimum element and insertions are performed in logarithmic time (amortized to constant time in the
 * case of insertions). Merges are also supported, with destructive merges performed in logarithmic time.
 */
declare class BinomialHeap<T> {
    private readonly comparator;
    /**
     * The root of the lowest-ordered tree in this heap. For each root, the `rightSibling` property points to the root
     * of the next-lowest-ordered tree in the heap, forming a singly-linked list of roots in ascending tree order.
     */
    private rootsHead?;
    private minimum?;
    private _size;
    /** The number of elements contained in this heap. */
    get size(): number;
    /**
     * Constructor.
     * @param comparator The function that this heap uses to compare the keys of its elements. The function returns 0 if
     * `a` and `b` share the same key, a negative number if `a` has a lower key than `b`, and a positive number if `a`
     * has a greater key than `b`.
     */
    constructor(comparator: (a: T, b: T) => number);
    /**
     * Finds the element in this heap with the smallest key.
     * @returns The element in this heap with the smallest key, or undefined if this heap is empty.
     */
    findMin(): T | undefined;
    /**
     * Removes and returns the element in this heap with the smallest key.
     * @returns The removed element, or undefined if this heap is empty.
     */
    removeMin(): T | undefined;
    /**
     * Inserts an element into this heap.
     * @param element The element to insert.
     * @returns This heap, after the element has been inserted.
     */
    insert(element: T): this;
    /**
     * Merges this heap with another one. The merge can either be non-destructive or destructive. A non-destructive merge
     * preserves the other heap. A destructive merge clears the other heap. A destructive merge takes O(log N) time
     * while a non-destructive merge takes O(M + log N) time, where N is either the size of this heap or the size of the
     * other heap, whichever is larger, and M is the size of the other heap. The difference stems from the need to copy
     * the other heap in a non-destructive merge. Note that the result of this operation is only valid if the two heaps
     * have equivalent comparator functions.
     * @param other The heap to merge into this one.
     * @param destructive Whether to perform a destructive merge. False by default.
     * @returns This heap, after the merge has been completed.
     */
    merge<U extends T>(other: BinomialHeap<U>, destructive?: boolean): this;
    /**
     * Removes all elements from this heap.
     * @returns This heap, after it has been cleared.
     */
    clear(): this;
    /**
     * Updates the pointer to this heap's minimum element.
     */
    private updateMin;
    /**
     * Merges two heaps.
     * @param a The lowest-ordered root of the first heap to merge, or undefined for an empty heap.
     * @param b The lowest-ordered root of the second heap to merge, or undefined for an empty heap.
     * @returns The lowest-ordered root of the union of the two input heaps, or undefined if the merged heap is empty.
     */
    private mergeHeaps;
    /**
     * Merges two binomial trees of equal order.
     * @param a The root of the first tree to merge.
     * @param b The root of the second tree to merge.
     * @returns The root of the merged tree.
     * @throws Error if the two input trees have different orders.
     */
    private mergeTrees;
    /**
     * Reverses the order of sibling nodes.
     * @param leftMostSibling The left-most sibling in a set of sibling nodes to reverse.
     * @returns The left-most sibling of the reversed set of siblings (originally the right-most sibling before the
     * reversal).
     */
    private static reverseSiblings;
    /**
     * Copies a binomial tree.
     * @param root The root of the tree to copy.
     * @returns The root of the copy.
     */
    private static copyTree;
}

/**
 * A sorted array.
 */
declare class SortedArray<T> {
    private readonly comparatorFunc;
    private readonly equalityFunc;
    private static readonly DEFAULT_EQUALITY_FUNC;
    private readonly _array;
    /** A read-only version of the array object backing this sorted array. */
    get array(): readonly T[];
    /**
     * The number of elements in this array.
     * @returns The number of elements in the array.
     */
    get length(): number;
    /**
     * Constructor.
     * @param comparatorFunc A function which defines the relative sorting priority of two elements. The function should
     * return 0 if its arguments are to be sorted identically, a negative number if the first argument is to be sorted
     * before the second argument, and a positive number if the first argument is to be sorted after the second argument.
     * @param equalityFunc A function which checks if two elements are equal. Defaults to the strict equality comparison
     * (`===`) if not defined.
     */
    constructor(comparatorFunc: (a: T, b: T) => number, equalityFunc?: (a: T, b: T) => boolean);
    /**
     * Finds the index of the first or last element in this array whose sorting priority is equal to a query element. If
     * no such element in this array exists, `-(index + 1)` is returned, where `index` is the index at which the query
     * element would be found if it were contained in the array.
     * @param element The query element.
     * @param first Whether to find the first index.
     * @returns The index of the first or last element in this array with the same sorting priority as the query, or
     * `-(index + 1)` if no such element exists, where `index` is the index at which the query element would be found if
     * it were contained in the array.
     */
    private findIndex;
    /**
     * Finds the index of the first element in this array which equals a query element, starting at a specified index.
     * The search proceeds toward the end of the array, ending at the first index containing an element whose sorting
     * priority does not equal the query, or the end of the array, whichever comes first. If no such element in this
     * array exists, -1 is returned instead.
     * @param element The query element.
     * @param startIndex The index at which to start the search.
     * @returns The index of the first element in this array which equals the query element, or -1 if no such element
     * exists.
     */
    private searchEquals;
    /**
     * Gets the element at a specified index, if it exists.
     * @param index An index.
     * @returns The element at the specified index, or undefined if the index is out of bounds.
     */
    get(index: number): T | undefined;
    /**
     * Gets the first element in this array, if it exists.
     * @returns The first element in this array, or undefined if this array is empty.
     */
    first(): T | undefined;
    /**
     * Gets the last element in this array, if it exists.
     * @returns The last element in this array, or undefined if this array is empty.
     */
    last(): T | undefined;
    /**
     * Checks whether this array contains an element. Returns true if and only if there is at least one element in this
     * array which is equal to the specified element according to this array's equality function.
     * @param element The element to check.
     * @returns Whether this array contains the element.
     */
    has(element: T): boolean;
    /**
     * Inserts an element into this array. The element will be inserted at the greatest index such that it is located
     * before all the existing elements in the array sorted after it according to this array's sorting function. All
     * existing elements located at indexes greater than or equal to the index at which the element was inserted are
     * shifted to the right.
     * @param element The element to insert.
     * @returns The index at which the element was placed.
     */
    insert(element: T): number;
    /**
     * Inserts all elements in an Iterable into this array. Each element is inserted according to the same behavior used
     * by the `insert()` method. If an element appears more than once in the iterable, one instance of that element will
     * be inserted into this array for each time the element appears in the iterable.
     * @param elements An iterable of elements to insert.
     * @returns The number of elements inserted.
     */
    insertAll(elements: Iterable<T>): number;
    /**
     * Removes the first occurrence of an element from this array. This array is searched for the first element which
     * is equal to the specified element according to this array's equality function, the matching element is removed,
     * and all elements after it are shifted to the left.
     * @param element The element to remove.
     * @returns The (former) index of the removed element, or -1 if no element was removed.
     */
    remove(element: T): number;
    /**
     * Removes all elements in an Iterable from this array. Each element is removed according to the behavior used by the
     * `remove()` method. If an element appears more than once in the iterable, one instance of that element will be
     * removed from this array for each time the element appears in the iterable.
     * @param elements An iterable of elements to remove.
     * @returns The number of elements removed.
     */
    removeAll(elements: Iterable<T>): number;
    /**
     * Removes the last element from this array and returns it.
     * @returns The removed element, or `undefined` if the array was empty.
     */
    pop(): T | undefined;
    /**
     * Removes the first element from this array and returns it.
     * @returns The removed element, or `undefined` if the array was empty.
     */
    shift(): T | undefined;
    /**
     * Finds the index of the first occurrence of an element in this array. This array is searched for the first element
     * which is equal to the specified element according to this array's equality function, and its index is returned.
     * @param element The element for which to search.
     * @returns The index of the first occurrence of the specified element, or -1 if no such element was found.
     */
    indexOf(element: T): number;
    /**
     * Searches this array for the first element whose sorting priority is equal to a query element. If no such element
     * is found, then undefined is returned instead.
     * @param query The query element.
     * @returns The first element in the array with the same sorting priority as the query, or undefined if no such
     * element exists.
     */
    match(query: T): T | undefined;
    /**
     * Searches this array for the index of the first element whose sorting priority is equal to a query element. If no
     * such element is found, then `-(index + 1)` is returned instead, where `index` is the index at which the query
     * element would be found if it were contained in the array.
     * @param query The query element.
     * @returns The index of the first element in this array with the same sorting priority as the query, or
     * `-(index + 1)` if no such element exists, where `index` is the index at which the query element would be found if
     * it were contained in the array.
     */
    matchIndex(query: T): number;
    /**
     * Removes all elements from this array.
     */
    clear(): void;
    /**
     * Gets an IterableIterator over all elements in this array.
     * @returns An IterableIterator over all elements in this array.
     */
    values(): IterableIterator<T>;
    /** @inheritdoc */
    [Symbol.iterator](): IterableIterator<T>;
}

/**
 * A linearly interpolated N-dimensional lookup table.
 */
declare class LerpLookupTable {
    private static readonly BREAKPOINT_COMPARATOR;
    private static readonly tempBreakpoint;
    private readonly _dimensionCount;
    /** The number of dimensions in this table. */
    get dimensionCount(): number;
    private readonly table;
    /**
     * Creates a lookup table of a specified dimension.
     * @param dimensionCount The number of dimensions in the new table. Values less than 0 will be clamped to 0.
     */
    constructor(dimensionCount: number);
    /**
     * Creates a lookup table initialized with an array of breakpoints.
     * @param breakpoints An array of breakpoints with which to initialize the new table. Each breakpoint should be
     * expressed as a number array, where the first element represents the breakpoint value, and the next N elements
     * represent the breakpoint key in each dimension. If not all breakpoint arrays have the same length, the dimension
     * of the table will be set equal to `N - 1`, where `N` is the length of the shortest array. For arrays with length
     * greater than `N`, all keys after index `N - 1` will be ignored. If the table ends up with zero dimensions, it will
     * be initialized to an empty table.
     */
    constructor(breakpoints: readonly (readonly number[])[]);
    /**
     * Inserts a breakpoint into this table. If the breakpoint has more dimensions than this table, only the first `N`
     * keys of the breakpoint will be used, where `N` is the dimension count of this table.
     * @param breakpoint A breakpoint, as a number array with the value at index 0 followed by the keys for each
     * dimension.
     * @returns This table, after the breakpoint has been inserted.
     * @throws Error if this table has zero dimensions, or the breakpoint has fewer dimensions than this table.
     */
    insertBreakpoint(breakpoint: readonly number[]): this;
    /**
     * Helper method for inserting a breakpoint into this table.
     * @param breakpoint The breakpoint to insert.
     * @param dimension The current dimension being evaluated.
     * @param array The array of dimensional breakpoints into which the breakpoint should be inserted.
     */
    private insertBreakpointHelper;
    /**
     * Looks up a value in this table using a specified key. The returned value will be linearly interpolated from
     * surrounding breakpoints if the key is not an exact match for any of the table's breakpoints.
     * @param key The lookup key, as an ordered N-tuple of numbers.
     * @returns The value corresponding to the specified key, or undefined if a value could not be retrieved.
     * @throws Error if this table has zero dimensions, the key has fewer dimensions than this table, or a value could
     * not be retrieved.
     */
    get(...key: number[]): number;
    /**
     * Helper method for looking up a key in this table.
     * @param key The key to look up.
     * @param dimension The current dimension being evaluated.
     * @param lookupArray The array containing breakpoints in the next lower dimension in which to search for the key.
     * @returns The interpolated value of the key at the specified dimension.
     */
    private lookupHelper;
}

/**
 * A 3D table for intepolating across multiple dimensions.
 */
declare class Table3D {
    private readonly data;
    /**
     * Adds a range of values to the table.
     * @param x The x value for this range of values.
     * @param values The range of values in [y, z]
     */
    addRange(x: number, values: Float64Array[]): void;
    /**
     * Gets the interpolated value from the table given an x and y position.
     * @param x The x position to interpolate for.
     * @param y The y position to interpolate for.
     * @returns The interpolated number.
     */
    getValue(x: number, y: number): number;
    /**
     * Interpolates a range of values given a starting y value.
     * @param y The y value to use.
     * @param range The range of values to interpolate over.
     * @returns A resultant interpolated z value.
     */
    private interpRange;
    /**
     * Interpolates in two dimensions.
     * @param y The input y value.
     * @param y0 The bottom y value for interpolation.
     * @param y1 The top y value for interpolation.
     * @param z0 The bottom z number for interpolation
     * @param z1 The top z number for interpolation.
     * @returns An interpolated z result given the input y.
     */
    private interp2d;
}

/**
 * Utility class for manipulating bit flags.
 */
declare class BitFlags {
    /**
     * Generates a bit flag with a boolean value of true at a specified index.
     * @param index The index of the flag. Must be between 0 and 32, inclusive.
     * @returns a bit flag.
     * @throws Error if index is out of bounds.
     */
    static createFlag(index: number): number;
    /**
     * Gets the inverse of some bit flags.
     * @param flags The bit flag group containing the flags to invert.
     * @param mask An optional bit mask to use when applying the inverse operation. The operation will only be performed
     * at the indexes where the mask has a value of 1 (true). If a mask is not specified, the operation will be performed
     * at all indexes.
     * @returns the inverse
     */
    static not(flags: number, mask?: number): number;
    /**
     * Gets the union of zero or more bit flags.
     * @param flags A list of bit flags.
     * @returns the union of the bit flags.
     */
    static union(...flags: number[]): number;
    /**
     * Gets the intersection of zero or more bit flags.
     * @param flags A list of bit flags.
     * @returns the intersection of the bit flags.
     */
    static intersection(...flags: number[]): number;
    /**
     * Changes a bit flag group by setting values at specific indexes.
     * @param flags The bit flag group to change.
     * @param valuesToSet A bit flag group containing the values to set.
     * @param mask A mask defining the indexes to set. Only indexes at which the mask has a value of `1` (`true`) will
     * be set.
     * @returns The result of changing `flags` using the specified values and indexes.
     */
    static set(flags: number, valuesToSet: number, mask: number): number;
    /**
     * Checks if a bit flag group meets at least one condition from a list of conditions.
     * @param flags A bit flag group.
     * @param conditions The conditions to meet, as a bit flag group.
     * @returns whether the bit flag group meets at least one condition.
     */
    static isAny(flags: number, conditions: number): boolean;
    /**
     * Checks if a bit flag group meets all the conditions from a list of conditions.
     * @param flags A bit flag group.
     * @param conditions The conditions to meet, as a bit flag group.
     * @returns whether the bit flag group meets all the conditions.
     */
    static isAll(flags: number, conditions: number): boolean;
    /**
     * Iterates through a bit flag group and executes a callback function once for each flag.
     * @param flags A bit flag group.
     * @param callback A function which will be called once for each flag.
     * @param valueFilter The value on which to filter. If defined, only flags with values equal to the filter will be
     * iterated, otherwise all flags will be iterated regardless of their values.
     * @param startIndex The index of the flag at which to start (inclusive). Defaults to 0.
     * @param endIndex The index of the flag at which to end (exclusive). Defaults to 32.
     */
    static forEach(flags: number, callback: (value: boolean, index: number, flags: number) => void, valueFilter?: boolean, startIndex?: number, endIndex?: number): void;
}

/**
 * Utility type to get the family of a unit type.
 */
declare type FamilyOfUnit<U extends Unit<string>> = U extends Unit<infer T> ? T : never;
/**
 * Utility type to get the Unit type from a NumberUnit type.
 */
declare type UnitOfNumber<N extends NumberUnitInterface<string>> = N extends NumberUnitInterface<string, infer U> ? U : never;
/**
 * A numeric value with unit type.
 */
interface NumberUnitInterface<F extends string, U extends Unit<F> = Unit<F>> {
    /** This NumberUnit's numeric value. */
    number: number;
    /** This NumberUnit's unit type. */
    unit: U;
    /**
     * Adds a value to this NumberUnit and returns the result.
     * @param value The other value.
     * @param out The NumberUnit to which to write the result.
     * @returns The sum.
     * @throws Error if the supplied value cannot be converted to this NumberUnit's unit type.
     */
    add<OU extends Unit<F>>(value: NumberUnitInterface<F>, out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Adds a value to this NumberUnit and returns the result.
     * @param value The other value.
     * @param unit The unit type of the other value.
     * @param out The NumberUnit to which to write the result.
     * @returns The sum.
     * @throws Error if the supplied value cannot be converted to this NumberUnit's unit type.
     */
    add<OU extends Unit<F>>(value: number, unit: Unit<F>, out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Subtracts a value from this NumberUnit and returns the result.
     * @param value The other value.
     * @param out The NumberUnit to which to write the result.
     * @returns The difference.
     * @throws Error if the supplied value cannot be converted to this NumberUnit's unit type.
     */
    subtract<OU extends Unit<F>>(value: NumberUnitInterface<F>, out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Subtracts a value from this NumberUnit and returns the result.
     * @param value The other value.
     * @param unit The unit type of the other value.
     * @param out The NumberUnit to which to write the result.
     * @returns The difference.
     * @throws Error if the supplied value cannot be converted to this NumberUnit's unit type.
     */
    subtract<OU extends Unit<F>>(value: number, unit: Unit<F>, out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Scales this NumberUnit by a unit-less factor and returns the result.
     * @param factor The factor by which to scale.
     * @param out The NumberUnit to which to write the result.
     * @returns The scaled value.
     */
    scale<OU extends Unit<F>>(factor: number, out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Finds the ratio of this NumberUnit to another value.
     * @param value The other value.
     * @returns The ratio.
     * @throws Error if the other value cannot be converted to this NumberUnit's unit type.
     */
    ratio(value: NumberUnitInterface<F>): number;
    /**
     * Finds the ratio of this NumberUnit to another value.
     * @param value The other value.
     * @param unit The unit type of the other value.
     * @returns the ratio.
     * @throws Error if the other value cannot be converted to this NumberUnit's unit type.
     */
    ratio(value: number, unit: Unit<F>): number;
    /**
     * Calculates the absolute value of this NumberUnit and returns the result.
     * @param out The NumberUnit to which to write the result.
     * @returns The absolute value.
     */
    abs<OU extends Unit<F>>(out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Returns the numeric value of this NumberUnit after conversion to a specified unit.
     * @param unit The unit to which to convert.
     * @returns The converted numeric value.
     * @throws Error if this NumberUnit's unit type cannot be converted to the specified unit.
     */
    asUnit(unit: Unit<F>): number;
    /**
     * Checks whether this NumberUnit is greater than, equal to, or less than another value.
     * @param value The other value.
     * @returns 0 if this NumberUnit is equal to the other value, -1 if this number is less, 1 if this number is greater.
     * @throws Error if this NumberUnit cannot be compared to the other value.
     */
    compare(value: NumberUnitInterface<F>): number;
    /**
     * Checks whether this NumberUnit is greater than, equal to, or less than another value.
     * @param value The other value.
     * @param unit The unit type of the other value. Defaults to this NumberUnit's unit type.
     * @returns 0 if this NumberUnit is equal to the other value, -1 if this number is less, 1 if this number is greater.
     * @throws Error if this NumberUnit cannot be compared to the other value.
     */
    compare(value: number, unit?: Unit<F>): number;
    /**
     * Checks whether this NumberUnit is equal to another value.
     * @param value The other value.
     * @returns Whether this NumberUnit is equal to the other value.
     */
    equals(value: NumberUnitInterface<string>): boolean;
    /**
     * Checks whether this NumberUnit is equal to another value.
     * @param value The other value.
     * @param unit The unit type of the other value. Defaults to this NumberUnit's unit type.
     * @returns Whether this NumberUnit is equal to the other value.
     */
    equals(value: number, unit?: Unit<string>): boolean;
    /**
     * Checks whether this NumberUnit has a numeric value of NaN.
     * @returns Whether this NumberUnit has a numeric value of NaN.
     */
    isNaN(): boolean;
    /**
     * Copies this NumberUnit.
     * @returns A copy of this NumberUnit.
     */
    copy(): NumberUnit<F, U>;
}
/**
 * A number with an associated unit. Each NumberUnit is created with a reference unit type,
 * which cannot be changed after instantiation. The reference unit type determines how the
 * value of the NumberUnit is internally represented. Each NumberUnit also maintains an
 * active unit type, which can be dynamically changed at any time.
 */
declare class NumberUnit<F extends string, U extends Unit<F> = Unit<F>> implements NumberUnitInterface<F, U> {
    private _number;
    private _unit;
    readonly readonly: NumberUnitReadOnly<F, U>;
    /**
     * Constructor.
     * @param number - the initial numeric value of the new NumberUnit.
     * @param unit - the unit type of the new NumberUnit.
     */
    constructor(number: number, unit: U);
    /**
     * Gets this NumberUnit's numeric value.
     * @returns This NumberUnit's numeric value.
     */
    get number(): number;
    /**
     * Gets this NumberUnit's unit type.
     * @returns This NumberUnit's unit type.
     */
    get unit(): U;
    /**
     * Converts a value to a numeric value with this NumberUnit's unit type.
     * @param value - the value.
     * @param unit - the unit type of the new value. Defaults to this NumberUnit's unit type. This argument is ignored if
     * value is a NumberUnit.
     * @returns the numeric of the value with this NumberUnit's unit type.
     */
    private toNumberOfThisUnit;
    /**
     * Sets this NumberUnit's numeric value. This method will not change this NumberUnit's unit type. If the supplied
     * value cannot be converted to this NumberUnit's unit type, this NumberUnit will not be changed and this method will
     * return undefined.
     * @param value - the new value.
     * @returns this NumberUnit, after it has been changed, or undefined if the operation could not be carried out.
     */
    set(value: NumberUnitInterface<F>): this;
    /**
     * Sets this NumberUnit's numeric value. This method will not change this NumberUnit's unit type.
     * @param value - the new value.
     * @param unit - the unit type of the new value. Defaults to this NumberUnit's unit type.
     * @returns this NumberUnit, after it has been changed.
     * @throws Error if the supplied value cannot be converted to this NumberUnit's unit type.
     */
    set(value: number, unit?: Unit<F>): this;
    /**
     * Adds a value to this NumberUnit and returns the result.
     * @param value The other value.
     * @param out The NumberUnit to which to write the result.
     * @returns The sum.
     * @throws Error if the supplied value cannot be converted to this NumberUnit's unit type.
     */
    add<OU extends Unit<F>>(value: NumberUnitInterface<F>, out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Adds a value to this NumberUnit in place and returns the result.
     * @param value The other value.
     * @returns The sum.
     * @throws Error if the supplied value cannot be converted to this NumberUnit's unit type.
     */
    add(value: NumberUnitInterface<F>): this;
    /**
     * Adds a value to this NumberUnit and returns the result.
     * @param value The other value.
     * @param unit The unit type of the other value.
     * @param out The NumberUnit to which to write the result.
     * @returns The sum.
     * @throws Error if the supplied value cannot be converted to this NumberUnit's unit type.
     */
    add<OU extends Unit<F>>(value: number, unit: Unit<F>, out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Adds a value to this NumberUnit in place and returns the result.
     * @param value The other value.
     * @param unit The unit type of the other value.
     * @returns The sum.
     * @throws Error if the supplied value cannot be converted to this NumberUnit's unit type.
     */
    add(value: number, unit: Unit<F>): this;
    /**
     * Subtracts a value from this NumberUnit and returns the result.
     * @param value The other value.
     * @param out The NumberUnit to which to write the result.
     * @returns The difference.
     * @throws Error if the supplied value cannot be converted to this NumberUnit's unit type.
     */
    subtract<OU extends Unit<F>>(value: NumberUnitInterface<F>, out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Subtracts a value from this NumberUnit in place and returns the result.
     * @param value The other value.
     * @param out The NumberUnit to which to write the result. Defaults to this NumberUnit.
     * @returns The difference.
     * @throws Error if the supplied value cannot be converted to this NumberUnit's unit type.
     */
    subtract(value: NumberUnitInterface<F>): this;
    /**
     * Subtracts a value from this NumberUnit and returns the result.
     * @param value The other value.
     * @param unit The unit type of the other value.
     * @param out The NumberUnit to which to write the result.
     * @returns The difference.
     * @throws Error if the supplied value cannot be converted to this NumberUnit's unit type.
     */
    subtract<OU extends Unit<F>>(value: number, unit: Unit<F>, out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Subtracts a value from this NumberUnit in place and returns the result.
     * @param value The other value.
     * @param unit The unit type of the other value.
     * @returns The difference.
     * @throws Error if the supplied value cannot be converted to this NumberUnit's unit type.
     */
    subtract(value: number, unit: Unit<F>): this;
    /**
     * Scales this NumberUnit by a unit-less factor and returns the result.
     * @param factor The factor by which to scale.
     * @param out The NumberUnit to which to write the result.
     * @returns The scaled value.
     */
    scale<OU extends Unit<F>>(factor: number, out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Scales this NumberUnit by a unit-less factor in place and returns the result.
     * @param factor The factor by which to scale.
     * @param out The NumberUnit to which to write the result.
     * @returns The scaled value.
     */
    scale(factor: number): this;
    /**
     * Finds the ratio of this NumberUnit to another value.
     * @param value The other value.
     * @returns The ratio.
     * @throws Error if the other value cannot be converted to this NumberUnit's unit type.
     */
    ratio(value: NumberUnitInterface<F>): number;
    /**
     * Finds the ratio of this NumberUnit to another value.
     * @param value The other value.
     * @param unit The unit type of the other value.
     * @returns the ratio.
     * @throws Error if the other value cannot be converted to this NumberUnit's unit type.
     */
    ratio(value: number, unit: Unit<F>): number;
    /**
     * Calculates the absolute value of this NumberUnit and returns the result.
     * @param out The NumberUnit to which to write the result.
     * @returns The absolute value.
     */
    abs<OU extends Unit<F>>(out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Calculates the absolute value of this NumberUnit in place and returns the result.
     * @returns The absolute value.
     */
    abs(): this;
    /**
     * Returns the numeric value of this NumberUnit after conversion to a specified unit.
     * @param unit The unit to which to convert.
     * @returns The converted numeric value.
     * @throws Error if this NumberUnit's unit type cannot be converted to the specified unit.
     */
    asUnit(unit: Unit<F>): number;
    /**
     * Checks whether this NumberUnit is greater than, equal to, or less than another value.
     * @param value The other value.
     * @returns 0 if this NumberUnit is equal to the other value, -1 if this number is less, 1 if this number is greater.
     * @throws Error if this NumberUnit cannot be compared to the other value.
     */
    compare(value: NumberUnitInterface<F>): number;
    /**
     * Checks whether this NumberUnit is greater than, equal to, or less than another value.
     * @param value The other value.
     * @param unit The unit type of the other value. Defaults to this NumberUnit's unit type.
     * @returns 0 if this NumberUnit is equal to the other value, -1 if this number is less, 1 if this number is greater.
     * @throws Error if this NumberUnit cannot be compared to the other value.
     */
    compare(value: number, unit?: Unit<F>): number;
    /**
     * Checks whether this NumberUnit is equal to another value.
     * @param value The other value.
     * @returns Whether this NumberUnit is equal to the other value.
     */
    equals(value: NumberUnitInterface<string>): boolean;
    /**
     * Checks whether this NumberUnit is equal to another value.
     * @param value The other value.
     * @param unit The unit type of the other value. Defaults to this NumberUnit's unit type.
     * @returns Whether this NumberUnit is equal to the other value.
     */
    equals(value: number, unit?: Unit<string>): boolean;
    /**
     * Checks whether this NumberUnit has a numeric value of NaN.
     * @returns Whether this NumberUnit has a numeric value of NaN.
     */
    isNaN(): boolean;
    /**
     * Copies this NumberUnit.
     * @returns A copy of this NumberUnit.
     */
    copy(): NumberUnit<F, U>;
}
/**
 * A read-only interface for a WT_NumberUnit.
 */
declare class NumberUnitReadOnly<F extends string, U extends Unit<F> = Unit<F>> implements NumberUnitInterface<F, U> {
    private readonly source;
    /**
     * Constructor.
     * @param source - the source of the new read-only NumberUnit.
     */
    constructor(source: NumberUnit<F, U>);
    /**
     * Gets this NumberUnit's numeric value.
     * @returns This NumberUnit's numeric value.
     */
    get number(): number;
    /**
     * Gets this NumberUnit's unit type.
     * @returns This NumberUnit's unit type.
     */
    get unit(): U;
    /**
     * Adds a value to this NumberUnit and returns the result.
     * @param value The other value.
     * @param out The NumberUnit to which to write the result.
     * @returns The sum.
     * @throws Error if the supplied value cannot be converted to this NumberUnit's unit type.
     */
    add<OU extends Unit<F>>(value: NumberUnitInterface<F>, out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Adds a value to this NumberUnit and returns the result.
     * @param value The other value.
     * @param unit The unit type of the other value.
     * @param out The NumberUnit to which to write the result.
     * @returns The sum.
     * @throws Error if the supplied value cannot be converted to this NumberUnit's unit type.
     */
    add<OU extends Unit<F>>(value: number, unit: Unit<F>, out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Subtracts a value from this NumberUnit and returns the result.
     * @param value The other value.
     * @param out The NumberUnit to which to write the result.
     * @returns The difference.
     * @throws Error if the supplied value cannot be converted to this NumberUnit's unit type.
     */
    subtract<OU extends Unit<F>>(value: NumberUnitInterface<F>, out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Subtracts a value from this NumberUnit and returns the result.
     * @param value The other value.
     * @param unit The unit type of the other value.
     * @param out The NumberUnit to which to write the result.
     * @returns The difference.
     * @throws Error if the supplied value cannot be converted to this NumberUnit's unit type.
     */
    subtract<OU extends Unit<F>>(value: number, unit: Unit<F>, out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Scales this NumberUnit by a unit-less factor and returns the result.
     * @param factor The factor by which to scale.
     * @param out The NumberUnit to which to write the result.
     * @returns The scaled value.
     */
    scale<OU extends Unit<F>>(factor: number, out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Finds the ratio of this NumberUnit to another value.
     * @param value The other value.
     * @returns The ratio.
     * @throws Error if the other value cannot be converted to this NumberUnit's unit type.
     */
    ratio(value: NumberUnitInterface<F>): number;
    /**
     * Finds the ratio of this NumberUnit to another value.
     * @param value The other value.
     * @param unit The unit type of the other value.
     * @returns the ratio.
     * @throws Error if the other value cannot be converted to this NumberUnit's unit type.
     */
    ratio(value: number, unit: Unit<F>): number;
    /**
     * Calculates the absolute value of this NumberUnit and returns the result.
     * @param out The NumberUnit to which to write the result.
     * @returns The absolute value.
     */
    abs<OU extends Unit<F>>(out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Returns the numeric value of this NumberUnit after conversion to a specified unit.
     * @param unit The unit to which to convert.
     * @returns The converted numeric value.
     * @throws Error if this NumberUnit's unit type cannot be converted to the specified unit.
     */
    asUnit(unit: Unit<F>): number;
    /**
     * Checks whether this NumberUnit is greater than, equal to, or less than another value.
     * @param value The other value.
     * @returns 0 if this NumberUnit is equal to the other value, -1 if this number is less, 1 if this number is greater.
     * @throws Error if this NumberUnit cannot be compared to the other value.
     */
    compare(value: NumberUnitInterface<F>): number;
    /**
     * Checks whether this NumberUnit is greater than, equal to, or less than another value.
     * @param value The other value.
     * @param unit The unit type of the other value. Defaults to this NumberUnit's unit type.
     * @returns 0 if this NumberUnit is equal to the other value, -1 if this number is less, 1 if this number is greater.
     * @throws Error if this NumberUnit cannot be compared to the other value.
     */
    compare(value: number, unit?: Unit<F>): number;
    /**
     * Checks whether this NumberUnit is equal to another value.
     * @param value The other value.
     * @returns Whether this NumberUnit is equal to the other value.
     */
    equals(value: NumberUnitInterface<string>): boolean;
    /**
     * Checks whether this NumberUnit is equal to another value.
     * @param value The other value.
     * @param unit The unit type of the other value. Defaults to this NumberUnit's unit type.
     * @returns Whether this NumberUnit is equal to the other value.
     */
    equals(value: number, unit?: Unit<string>): boolean;
    /**
     * Checks whether this NumberUnit has a numeric value of NaN.
     * @returns Whether this NumberUnit has a numeric value of NaN.
     */
    isNaN(): boolean;
    /**
     * Copies this NumberUnit.
     * @returns A copy of this NumberUnit.
     */
    copy(): NumberUnit<F, U>;
}
/**
 * A unit of measurement.
 */
interface Unit<F extends string> {
    /** This unit's family. */
    readonly family: F;
    /** This unit's name. */
    readonly name: string;
    /**
     * Checks whether conversions between this unit and another unit are possible.
     * @param otherUnit The other unit.
     * @returns Whether conversions between this unit and another unit are possible.
     */
    canConvert(otherUnit: Unit<string>): boolean;
    /**
     * Converts a value of this unit to another unit.
     * @param value The value to convert.
     * @param toUnit The unit to which to convert.
     * @returns The converted value.
     * @throws Error if attempting an invalid conversion.
     */
    convertTo(value: number, toUnit: Unit<F>): number;
    /**
     * Converts a value of another unit to this unit.
     * @param value The value to convert.
     * @param fromUnit The unit from which to convert.
     * @returns The converted value.
     * @throws Error if attempting an invalid conversion.
     */
    convertFrom(value: number, fromUnit: Unit<F>): number;
    /**
     * Creates a NumberUnit with a specified initial value of this unit type.
     * @param value The numeric value of the new NumberUnit.
     * @returns A NumberUnit of this unit type.
     */
    createNumber(value: number): NumberUnit<F, this>;
    /**
     * Checks whether this unit is equal to another unit. Returns true if and only if the other unit belongs to the same
     * family and has the same name as this unit.
     * @param other The other unit to which to compare.
     * @returns Whether this unit is equal to the comparison.
     */
    equals(other: Unit<string>): boolean;
}
/**
 * A unit type that can be compounded.
 */
interface CompoundableUnit<F extends string> extends Unit<F> {
    /** The relative linear scale of this unit compared to the standard unit of the same family. */
    readonly scaleFactor: number;
}
/**
 * A unit of measurement.
 */
declare abstract class AbstractUnit<F extends string> implements Unit<F> {
    readonly name: string;
    abstract readonly family: F;
    /**
     * Constructor.
     * @param name The name of this unit.
     */
    constructor(name: string);
    /** @inheritdoc */
    canConvert(otherUnit: Unit<string>): boolean;
    /** @inheritdoc */
    abstract convertTo(value: number, toUnit: Unit<F>): number;
    /** @inheritdoc */
    abstract convertFrom(value: number, fromUnit: Unit<F>): number;
    /** @inheritdoc */
    createNumber(value: number): NumberUnit<F, this>;
    /** @inheritdoc */
    equals(other: Unit<string>): boolean;
}
/**
 * A unit that can be converted to another unit of the same type via a fixed linear transformation.
 */
declare class SimpleUnit<F extends string> extends AbstractUnit<F> implements CompoundableUnit<F> {
    readonly family: F;
    readonly scaleFactor: number;
    readonly zeroOffset: number;
    /**
     * Constructor.
     * @param family The family to which this unit belongs.
     * @param name The name of this unit.
     * @param scaleFactor The relative linear scale of the new unit compared to the standard unit of the same family.
     * @param zeroOffset The zero offset of the new unit compared to the standard unit of the same family.
     */
    constructor(family: F, name: string, scaleFactor: number, zeroOffset?: number);
    /** @inheritdoc */
    canConvert(otherUnit: Unit<string>): boolean;
    /** @inheritdoc */
    convertTo(value: number, toUnit: Unit<F>): number;
    /** @inheritdoc */
    convertFrom(value: number, fromUnit: Unit<F>): number;
}
/**
 * A unit of measure composed of the multiplicative combination of multiple elementary units.
 */
declare class CompoundUnit<F extends string> extends AbstractUnit<F> {
    readonly family: F;
    private readonly numerator;
    private readonly denominator;
    protected readonly scaleFactor: number;
    /**
     * Constructor.
     * @param family The family to which this unit belongs.
     * @param numerator An array of CompoundableUnits containing all the units in the numerator of the compound unit.
     * @param denominator An array of CompoundableUnits containing all the units in the denominator of the compound unit.
     * @param name The name of this unit. If not defined, one will be automatically generated.
     */
    constructor(family: F, numerator: CompoundableUnit<string>[], denominator: CompoundableUnit<string>[], name?: string);
    /**
     * Gets the scale factor for this unit.
     * @returns the scale factor for this unit.
     */
    private getScaleFactor;
    /** @inheritdoc */
    canConvert(otherUnit: Unit<string>): boolean;
    /** @inheritdoc */
    convertTo(value: number, toUnit: Unit<F>): number;
    /** @inheritdoc */
    convertFrom(value: number, fromUnit: Unit<F>): number;
}
/**
 * Predefined unit families.
 */
declare enum UnitFamily {
    Distance = "distance",
    Angle = "angle",
    Duration = "duration",
    Weight = "weight",
    Volume = "volume",
    Pressure = "pressure",
    Temperature = "temperature",
    Speed = "speed",
    Acceleration = "acceleration",
    WeightFlux = "weight_flux",
    VolumeFlux = "volume_flux"
}
/**
 * Predefined unit types.
 */
declare class UnitType {
    static readonly METER: SimpleUnit<UnitFamily.Distance>;
    static readonly FOOT: SimpleUnit<UnitFamily.Distance>;
    static readonly KILOMETER: SimpleUnit<UnitFamily.Distance>;
    /** Statute mile. */
    static readonly MILE: SimpleUnit<UnitFamily.Distance>;
    /** Nautical mile. */
    static readonly NMILE: SimpleUnit<UnitFamily.Distance>;
    /** Great-arc radian. The average radius of Earth. */
    static readonly GA_RADIAN: SimpleUnit<UnitFamily.Distance>;
    static readonly RADIAN: SimpleUnit<UnitFamily.Angle>;
    static readonly DEGREE: SimpleUnit<UnitFamily.Angle>;
    static readonly ARC_MIN: SimpleUnit<UnitFamily.Angle>;
    static readonly ARC_SEC: SimpleUnit<UnitFamily.Angle>;
    static readonly MILLISECOND: SimpleUnit<UnitFamily.Duration>;
    static readonly SECOND: SimpleUnit<UnitFamily.Duration>;
    static readonly MINUTE: SimpleUnit<UnitFamily.Duration>;
    static readonly HOUR: SimpleUnit<UnitFamily.Duration>;
    static readonly KILOGRAM: SimpleUnit<UnitFamily.Weight>;
    static readonly POUND: SimpleUnit<UnitFamily.Weight>;
    static readonly TON: SimpleUnit<UnitFamily.Weight>;
    static readonly TONNE: SimpleUnit<UnitFamily.Weight>;
    /** Weight equivalent of one liter of fuel, using the generic conversion 1 gallon = 6.7 pounds. */
    static readonly LITER_FUEL: SimpleUnit<UnitFamily.Weight>;
    /** Weight equivalent of one pound of fuel, using the generic conversion 1 gallon = 6.7 pounds. */
    static readonly GALLON_FUEL: SimpleUnit<UnitFamily.Weight>;
    static readonly LITER: SimpleUnit<UnitFamily.Volume>;
    static readonly GALLON: SimpleUnit<UnitFamily.Volume>;
    /** Hectopascal. */
    static readonly HPA: SimpleUnit<UnitFamily.Pressure>;
    /** Atmosphere. */
    static readonly ATM: SimpleUnit<UnitFamily.Pressure>;
    /** Inch of mercury. */
    static readonly IN_HG: SimpleUnit<UnitFamily.Pressure>;
    /** Millimeter of mercury. */
    static readonly MM_HG: SimpleUnit<UnitFamily.Pressure>;
    static readonly CELSIUS: SimpleUnit<UnitFamily.Temperature>;
    static readonly FAHRENHEIT: SimpleUnit<UnitFamily.Temperature>;
    static readonly KNOT: CompoundUnit<UnitFamily.Speed>;
    /** Kilometer per hour. */
    static readonly KPH: CompoundUnit<UnitFamily.Speed>;
    /** Miles per hour. */
    static readonly MPH: CompoundUnit<UnitFamily.Speed>;
    /** Meter per minute. */
    static readonly MPM: CompoundUnit<UnitFamily.Speed>;
    /** Meter per second. */
    static readonly MPS: CompoundUnit<UnitFamily.Speed>;
    /** Foot per minute. */
    static readonly FPM: CompoundUnit<UnitFamily.Speed>;
    /** Foot per second. */
    static readonly FPS: CompoundUnit<UnitFamily.Speed>;
    /** Meter per minute per second. */
    static readonly MPM_PER_SEC: CompoundUnit<UnitFamily.Acceleration>;
    /** Meter per second per second. */
    static readonly MPS_PER_SEC: CompoundUnit<UnitFamily.Acceleration>;
    /** Foot per minute per second. */
    static readonly FPM_PER_SEC: CompoundUnit<UnitFamily.Acceleration>;
    /** Foot per second per second. */
    static readonly FPS_PER_SEC: CompoundUnit<UnitFamily.Acceleration>;
    /** Average gravitational acceleration on Earth at sea level. */
    static readonly G_ACCEL: CompoundUnit<UnitFamily.Acceleration>;
    /** Kilogram per hour. */
    static readonly KGH: CompoundUnit<UnitFamily.WeightFlux>;
    /** Pound per hour. */
    static readonly PPH: CompoundUnit<UnitFamily.WeightFlux>;
    /** Weight equivalent of one liter of fuel per hour, using the generic conversion 1 gallon = 6.7 pounds. */
    static readonly LPH_FUEL: CompoundUnit<UnitFamily.WeightFlux>;
    /** Weight equivalent of one gallon fuel per hour, using the generic conversion 1 gallon = 6.7 pounds. */
    static readonly GPH_FUEL: CompoundUnit<UnitFamily.WeightFlux>;
}

/**
 * A Subject which provides a {@link NumberUnitInterface} value.
 */
declare class NumberUnitSubject<F extends string, U extends Unit<F> = Unit<F>> extends AbstractSubscribable<NumberUnitInterface<F, U>> implements MutableSubscribable<NumberUnitInterface<F, U>>, MutableSubscribable<NumberUnitInterface<F, U>, number> {
    private readonly value;
    /** @inheritdoc */
    readonly isMutableSubscribable = true;
    /**
     * Constructor.
     * @param value The value of this subject.
     */
    private constructor();
    /**
     * Creates a NumberUnitSubject.
     * @param initialVal The initial value.
     * @returns A NumberUnitSubject.
     */
    static create<F extends string, U extends Unit<F>>(initialVal: NumberUnit<F, U>): NumberUnitSubject<F, U>;
    /**
     * Creates a NumberUnitSubject.
     * @param initialVal The initial value.
     * @returns A NumberUnitSubject.
     * @deprecated Use `NumberUnitSubject.create()` instead.
     */
    static createFromNumberUnit<F extends string, U extends Unit<F>>(initialVal: NumberUnit<F, U>): NumberUnitSubject<F, U>;
    /** @inheritdoc */
    get(): NumberUnitInterface<F, U>;
    /**
     * Sets the new value and notifies the subscribers if the value changed.
     * @param value The new value.
     */
    set(value: NumberUnitInterface<F>): void;
    /**
     * Sets the new value and notifies the subscribers if the value changed.
     * @param value The numeric part of the new value.
     * @param unit The unit type of the new value. Defaults to the unit type of the NumberUnit used to create this
     * subject.
     */
    set(value: number, unit?: Unit<F>): void;
}

/**
 * A readonly version of a {@link Float64Array}.
 */
declare type ReadonlyFloat64Array = Readonly<Omit<Float64Array, 'set' | 'copyWithin' | 'sort'>>;
/**
 * 2D vector mathematical operations.
 */
declare class Vec2Math {
    /**
     * Creates a 2D vector initialized to `[0, 0]`.
     * @returns A new 2D vector initialized to `[0, 0]`.
     */
    static create(): Float64Array;
    /**
     * Creates a 2D vector with specified x- and y- components.
     * @param x The x-component of the new vector.
     * @param y The y-component of the new vector.
     * @returns A new 2D vector with the specified components.
     */
    static create(x: number, y: number): Float64Array;
    /**
     * Gets the polar angle theta of a vector in radians.
     * @param vec - a vector.
     * @returns the polar angle theta of the vector.
     */
    static theta(vec: ReadonlyFloat64Array): number;
    /**
     * Sets the components of a vector.
     * @param x - the new x-component.
     * @param y - the new y-component.
     * @param vec - the vector to change.
     * @returns the vector after it has been changed.
     */
    static set(x: number, y: number, vec: Float64Array): Float64Array;
    /**
     * Sets the polar components of a vector.
     * @param r - the new length (magnitude).
     * @param theta - the new polar angle theta, in radians.
     * @param vec - the vector to change.
     * @returns the vector after it has been changed.
     */
    static setFromPolar(r: number, theta: number, vec: Float64Array): Float64Array;
    /**
     * Add one vector to another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector sum.
     */
    static add(v1: ReadonlyFloat64Array, v2: ReadonlyFloat64Array, out: Float64Array): Float64Array;
    /**
     * Subtracts one vector from another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector difference.
     */
    static sub(v1: ReadonlyFloat64Array, v2: ReadonlyFloat64Array, out: Float64Array): Float64Array;
    /**
     * Gets the dot product of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @returns The dot product of the vectors.
     */
    static dot(v1: ReadonlyFloat64Array, v2: ReadonlyFloat64Array): number;
    /**
     * Multiplies a vector by a scalar.
     * @param v1 The vector to multiply.
     * @param scalar The scalar to apply.
     * @param out The vector to write the results to.
     * @returns The scaled vector.
     */
    static multScalar(v1: ReadonlyFloat64Array, scalar: number, out: Float64Array): Float64Array;
    /**
     * Gets the magnitude of a vector.
     * @param v1 The vector to get the magnitude for.
     * @returns the vector's magnitude.
     */
    static abs(v1: ReadonlyFloat64Array): number;
    /**
     * Normalizes the vector to a unit vector.
     * @param v1 The vector to normalize.
     * @param out The vector to write the results to.
     * @returns the normalized vector.
     */
    static normalize(v1: ReadonlyFloat64Array, out: Float64Array): Float64Array;
    /**
     * Gets the normal of the supplied vector.
     * @param v1 The vector to get the normal for.
     * @param out The vector to write the results to.
     * @param counterClockwise Whether or not to get the counterclockwise normal.
     * @returns the normal vector.
     */
    static normal(v1: ReadonlyFloat64Array, out: Float64Array, counterClockwise?: boolean): Float64Array;
    /**
     * Gets the Euclidean distance between two vectors.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns the Euclidean distance between the two vectors.
     */
    static distance(vec1: ReadonlyFloat64Array, vec2: ReadonlyFloat64Array): number;
    /**
     * Checks if two vectors are equal.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns Whether the two vectors are equal.
     */
    static equals(vec1: ReadonlyFloat64Array, vec2: ReadonlyFloat64Array): boolean;
    /**
     * Copies one vector to another.
     * @param from The vector from which to copy.
     * @param to The vector to which to copy.
     * @returns The changed vector.
     */
    static copy(from: ReadonlyFloat64Array, to: Float64Array): Float64Array;
}
/**
 * 3D vector mathematical operations.
 */
declare class Vec3Math {
    /**
     * Creates a 3D vector initialized to `[0, 0, 0]`.
     * @returns A new 3D vector initialized to `[0, 0, 0]`.
     */
    static create(): Float64Array;
    /**
     * Creates a 3D vector with specified x-, y-, and z- components.
     * @param x The x-component of the new vector.
     * @param y The y-component of the new vector.
     * @param z The z-component of the new vector.
     * @returns A new 3D vector with the specified components.
     */
    static create(x: number, y: number, z: number): Float64Array;
    /**
     * Gets the spherical angle theta of a vector in radians.
     * @param vec - a vector.
     * @returns the spherical angle theta of the vector.
     */
    static theta(vec: ReadonlyFloat64Array): number;
    /**
     * Gets the spherical angle phi of a vector in radians.
     * @param vec - a vector.
     * @returns the spherical angle phi of the vector.
     */
    static phi(vec: ReadonlyFloat64Array): number;
    /**
     * Sets the components of a vector.
     * @param x - the new x-component.
     * @param y - the new y-component.
     * @param z - the new z-component.
     * @param vec - the vector to change.
     * @returns the vector after it has been changed.
     */
    static set(x: number, y: number, z: number, vec: Float64Array): Float64Array;
    /**
     * Sets the spherical components of a vector.
     * @param r - the new length (magnitude).
     * @param theta - the new spherical angle theta, in radians.
     * @param phi - the new spherical angle phi, in radians.
     * @param vec - the vector to change.
     * @returns the vector after it has been changed.
     */
    static setFromSpherical(r: number, theta: number, phi: number, vec: Float64Array): Float64Array;
    /**
     * Add one vector to another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector sum.
     */
    static add(v1: ReadonlyFloat64Array, v2: ReadonlyFloat64Array, out: Float64Array): Float64Array;
    /**
     * Subtracts one vector from another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector difference.
     */
    static sub(v1: ReadonlyFloat64Array, v2: ReadonlyFloat64Array, out: Float64Array): Float64Array;
    /**
     * Gets the dot product of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @returns The dot product of the vectors.
     */
    static dot(v1: ReadonlyFloat64Array, v2: ReadonlyFloat64Array): number;
    /**
     * Gets the cross product of two vectors.
     * @param v1 - the first vector.
     * @param v2 - the second vector.
     * @param out - the vector to which to write the result.
     * @returns the cross product.
     */
    static cross(v1: ReadonlyFloat64Array, v2: ReadonlyFloat64Array, out: Float64Array): Float64Array;
    /**
     * Multiplies a vector by a scalar.
     * @param v1 The vector to multiply.
     * @param scalar The scalar to apply.
     * @param out The vector to write the results to.
     * @returns The scaled vector.
     */
    static multScalar(v1: ReadonlyFloat64Array, scalar: number, out: Float64Array): Float64Array;
    /**
     * Gets the magnitude of a vector.
     * @param v1 The vector to get the magnitude for.
     * @returns the vector's magnitude.
     */
    static abs(v1: ReadonlyFloat64Array): number;
    /**
     * Normalizes the vector to a unit vector.
     * @param v1 The vector to normalize.
     * @param out The vector to write the results to.
     * @returns the normalized vector.
     */
    static normalize(v1: ReadonlyFloat64Array, out: Float64Array): Float64Array;
    /**
     * Gets the Euclidean distance between two vectors.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns the Euclidean distance between the two vectors.
     */
    static distance(vec1: ReadonlyFloat64Array, vec2: ReadonlyFloat64Array): number;
    /**
     * Checks if two vectors are equal.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns Whether the two vectors are equal.
     */
    static equals(vec1: ReadonlyFloat64Array, vec2: ReadonlyFloat64Array): boolean;
    /**
     * Copies one vector to another.
     * @param from The vector from which to copy.
     * @param to The vector to which to copy.
     * @returns the changed vector.
     */
    static copy(from: ReadonlyFloat64Array, to: Float64Array): Float64Array;
}
/**
 * N-dimensional vector mathematical operations.
 */
declare class VecNMath {
    /**
     * Creates an N-dimensional vector with all components initialized to `0`.
     * @param length The length of the new vector.
     * @returns A new N-dimensional vector with the specified length and all components initialized to `0`.
     */
    static create(length: number): Float64Array;
    /**
     * Creates an N-dimensional vector with specified components.
     * @param length The length of the new vector.
     * @param components The components of the new vector.
     * @returns A new N-dimensional vector with the specified length and components.
     */
    static create(length: number, ...components: number[]): Float64Array;
    /**
     * Sets the components of a vector.
     * @param vec The vector to change.
     * @param components The new components.
     * @returns The vector after it has been changed.
     */
    static set(vec: Float64Array, ...components: number[]): Float64Array;
    /**
     * Gets the magnitude of a vector.
     * @param vec The vector to get the magnitude for.
     * @returns The vector's magnitude.
     */
    static abs(vec: ReadonlyFloat64Array): number;
    /**
     * Gets the dot product of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @returns The dot product of the vectors.
     * @throws Error if the two vectors are of unequal lengths.
     */
    static dot(v1: ReadonlyFloat64Array, v2: ReadonlyFloat64Array): number;
    /**
     * Normalizes a vector to a unit vector.
     * @param v1 The vector to normalize.
     * @param out The vector to write the results to.
     * @returns The normalized vector.
     */
    static normalize(v1: ReadonlyFloat64Array, out: Float64Array): Float64Array;
    /**
     * Checks if two vectors are equal.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns Whether the two vectors are equal.
     */
    static equals(vec1: ReadonlyFloat64Array, vec2: ReadonlyFloat64Array): boolean;
    /**
     * Copies one vector to another.
     * @param from The vector from which to copy.
     * @param to The vector to which to copy.
     * @returns The changed vector.
     * @throws Error if the vectors are of unequal lengths.
     */
    static copy(from: ReadonlyFloat64Array, to: Float64Array): Float64Array;
}

/**
 * A Subject which allows a 2D vector to be observed.
 */
declare class Vec2Subject extends AbstractSubscribable<ReadonlyFloat64Array> implements MutableSubscribable<ReadonlyFloat64Array, Readonly<ArrayLike<number>>> {
    private readonly value;
    /** @inheritdoc */
    readonly isMutableSubscribable = true;
    /**
     * Constructor.
     * @param value The value of this subject.
     */
    private constructor();
    /**
     * Creates a Vec2Subject.
     * @param initialVal The initial value.
     * @returns A Vec2Subject.
     */
    static create(initialVal: Float64Array): Vec2Subject;
    /**
     * Creates a Vec2Subject.
     * @param initialVal The initial value.
     * @returns A Vec2Subject.
     * @deprecated Use `Vec2Subject.create()` instead.
     */
    static createFromVector(initialVal: Float64Array): Vec2Subject;
    /** @inheritdoc */
    get(): ReadonlyFloat64Array;
    /**
     * Sets the new value and notifies the subscribers if the value changed.
     * @param value The new value.
     */
    set(value: Readonly<ArrayLike<number>>): void;
    /**
     * Sets the new value and notifies the subscribers if the value changed.
     * @param x The x component of the new value.
     * @param y The y component of the new value.
     */
    set(x: number, y: number): void;
}
/**
 * A Subject which allows a 3D vector to be observed.
 */
declare class Vec3Subject extends AbstractSubscribable<ReadonlyFloat64Array> implements MutableSubscribable<ReadonlyFloat64Array, Readonly<ArrayLike<number>>> {
    private readonly value;
    /** @inheritdoc */
    readonly isMutableSubscribable = true;
    /**
     * Constructor.
     * @param value The value of this subject.
     */
    private constructor();
    /**
     * Creates a Vec3Subject.
     * @param initialVal The initial value.
     * @returns A Vec3Subject.
     */
    static create(initialVal: Float64Array): Vec3Subject;
    /**
     * Creates a Vec3Subject.
     * @param initialVal The initial value.
     * @returns A Vec3Subject.
     * @deprecated Use `Vec3Subject.create()` instead.
     */
    static createFromVector(initialVal: Float64Array): Vec3Subject;
    /** @inheritdoc */
    get(): ReadonlyFloat64Array;
    /**
     * Sets the new value and notifies the subscribers if the value changed.
     * @param value The new value.
     */
    set(value: Readonly<ArrayLike<number>>): void;
    /**
     * Sets the new value and notifies the subscribers if the value changed.
     * @param x The x component of the new value.
     * @param y The y component of the new value.
     */
    set(x: number, y: number, z: number): void;
}
/**
 * A Subject which allows a N-D vector to be observed.
 */
declare class VecNSubject extends AbstractSubscribable<ReadonlyFloat64Array> implements MutableSubscribable<ReadonlyFloat64Array, Readonly<ArrayLike<number>>> {
    private readonly value;
    /** @inheritdoc */
    readonly isMutableSubscribable = true;
    /**
     * Constructor.
     * @param value The value of this subject.
     */
    private constructor();
    /**
     * Creates a VecNSubject.
     * @param initialVal The initial value.
     * @returns A VecNSubject.
     */
    static create(initialVal: Float64Array): VecNSubject;
    /**
     * Creates a VecNSubject.
     * @param initialVal The initial value.
     * @returns A VecNSubject.
     * @deprecated Use `VecNSubject.create()` instead.
     */
    static createFromVector(initialVal: Float64Array): VecNSubject;
    /** @inheritdoc */
    get(): ReadonlyFloat64Array;
    /**
     * Sets the new value and notifies the subscribers if the value changed.
     * @param value The new value.
     * @throws Error if the length of `value` is greater than the length of this subject's value.
     */
    set(value: Readonly<ArrayLike<number>>): void;
    /**
     * Sets the new value and notifies the subscribers if the value changed.
     * @param args The individual components of the new value.
     * @throws Error if the number of components of the new value is greater than the length of this subject's value.
     */
    set(...args: number[]): void;
}

/** A readonly 2D affine transformation. */
declare type ReadonlyTransform2D = Pick<Transform2D, 'getParameters' | 'apply' | 'copy'>;
/**
 * A 2D affine transformation. By default, Transform2D objects are initially created as identity transformations.
 */
declare class Transform2D {
    private readonly array;
    /**
     * Gets the parameters of this transformation as a 6-tuple: `[scaleX, skewX, translateX, skewY, scaleY, translateY]`.
     * @returns The parameters of this transformation.
     */
    getParameters(): ReadonlyFloat64Array;
    /**
     * Sets the parameters of this transformation.
     * @param scaleX The x scaling factor.
     * @param skewX The x skew factor.
     * @param translateX The x translation.
     * @param skewY The y skew factor.
     * @param scaleY The y scaling factor.
     * @param translateY The y translation.
     * @returns This transformation, after it has been changed.
     */
    set(scaleX: number, skewX: number, translateX: number, skewY: number, scaleY: number, translateY: number): this;
    /**
     * Sets the parameters of this transformation from another transformation.
     * @param transform The transformation from which to take parameters.
     */
    set(transform: ReadonlyTransform2D): this;
    /**
     * Sets the x scaling factor of this transformation.
     * @param value The new x scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScaleX(value: number): this;
    /**
     * Sets the y scaling factor of this transformation.
     * @param value The new y scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScaleY(value: number): this;
    /**
     * Sets the x and y scaling factors of this transformation.
     * @param x The new x scaling factor.
     * @param y The new y scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScale(x: number, y: number): this;
    /**
     * Sets the x skew factor of this transformation.
     * @param value The new x skew factor.
     * @returns This transformation, after it has been changed.
     */
    setSkewX(value: number): this;
    /**
     * Sets the y skew factor of this transformation.
     * @param value The new y skew factor.
     * @returns This transformation, after it has been changed.
     */
    setSkewY(value: number): this;
    /**
     * Sets the x translation of this transformation.
     * @param value The new x translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslateX(value: number): this;
    /**
     * Sets the y translation of this transformation.
     * @param value The new y translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslateY(value: number): this;
    /**
     * Sets the x and y translations of this transformation.
     * @param x The new x translation.
     * @param y The new y translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslate(x: number, y: number): this;
    /**
     * Inverts this transformation.
     * @returns This transformation, after it has been inverted.
     */
    invert(): this;
    /**
     * Copies this transformation.
     * @returns A copy of this transformation.
     */
    copy(): Transform2D;
    /**
     * Applies this transformation to a 2D vector.
     * @param vec A 2D vector.
     * @param out The vector to which to write the result.
     * @returns The result of applying this transformation to `vec`.
     */
    apply(vec: ReadonlyFloat64Array, out: Float64Array): Float64Array;
    private static readonly offsetOriginCache;
    /**
     * Changes this transformation to the one that is the result of offsetting this transformation's origin.
     * @param x The x-coordinate of the offset origin.
     * @param y The y-coordinate of the offset origin.
     * @returns This transformation, after it has been changed.
     */
    offsetOrigin(x: number, y: number): this;
    /**
     * Sets this transformation to the identity transformation.
     * @returns This transformation, after it has been changed.
     */
    toIdentity(): this;
    /**
     * Sets this transformation to a translation.
     * @param x The x translation.
     * @param y The y translation.
     * @returns This transformation, after it has been changed.
     */
    toTranslation(x: number, y: number): this;
    /**
     * Sets this transformation to a scaling about the origin (0, 0).
     * @param x The x scaling factor.
     * @param y The y scaling factor.
     * @returns This transformation, after it has been changed.
     */
    toScale(x: number, y: number): this;
    /**
     * Sets this transformation to a scaling about an arbitrary origin.
     * @param x The x scaling factor.
     * @param y The y scaling factor.
     * @param originX The x-coordinate of the scaling origin.
     * @param originY The y-coordinate of the scaling origin.
     * @returns This transformation, after it has been changed.
     */
    toScale(x: number, y: number, originX: number, originY: number): this;
    /**
     * Sets this transformation to a rotation about the origin (0, 0).
     * @param theta The rotation angle, in radians.
     * @returns This transformation, after it has been changed.
     */
    toRotation(theta: number): this;
    /**
     * Sets this transformation to a rotation about an arbitrary origin.
     * @param theta The rotation angle, in radians.
     * @param originX The x-coordinate of the rotation origin.
     * @param originY The y-coordinate of the rotation origin.
     * @returns This transformation, after it has been changed.
     */
    toRotation(theta: number, originX: number, originY: number): this;
    /**
     * Sets this transformation to a reflection across a line passing through the origin (0, 0).
     * @param theta The angle of the reflection line, in radians, with respect to the positive x axis.
     * @returns This transformation, after it has been changed.
     */
    toReflection(theta: number): this;
    /**
     * Sets this transformation to a reflection across a line passing through an arbitrary origin.
     * @param theta The angle of the reflection line, in radians, with respect to the positive x axis.
     * @param originX The x-coordinate of the reflection origin.
     * @param originY The y-coordinate of the reflection origin.
     * @returns This transformation, after it has been changed.
     */
    toReflection(theta: number, originX: number, originY: number): this;
    private static readonly concatCache;
    /**
     * Concatenates one or more transformations and returns the result. Concatenating transformations `[A, B, ...]`
     * results in a transformation that is equivalent to first applying `A`, then applying `B`, etc. Note that this order
     * is the _opposite_ of the one resulting from multiplying the individual transformation _matrices_
     * `M_A * M_B * ...`.
     *
     * If the number of transformations to concatenate equals zero, the identity matrix is returned.
     * @param out The transformation to which to write the result.
     * @param transforms The transformations to concatenate, in order.
     * @returns The result of concatenating all transformations in `transforms`.
     */
    static concat<T extends Transform2D>(out: T, transforms: readonly ReadonlyTransform2D[]): T;
}

/** A readonly 3D affine transformation. */
declare type ReadonlyTransform3D = Pick<Transform3D, 'getParameters' | 'apply' | 'copy'>;
/**
 * A 3D affine transformation. By default, Transform3D objects are initially created as identity transformations.
 */
declare class Transform3D {
    private readonly array;
    /**
     * Gets the parameters of this transformation as a 12-tuple:
     * `[scaleX, skewX(Y), skewX(Z), translateX, skewY(X), scaleY, skewY(Z), translateY, skewZ(X), skewZ(Y), scaleZ, translateZ]`.
     * @returns The parameters of this transformation.
     */
    getParameters(): Readonly<Float64Array>;
    /**
     * Sets the parameters of this transformation.
     * @param scaleX The x scaling factor.
     * @param skewXY The x skew factor along the y axis.
     * @param skewXZ The x skew factor along the z axis.
     * @param translateX The x translation.
     * @param skewYX The y skew factor along the x axis.
     * @param scaleY The y scaling factor.
     * @param skewYZ The y skew factor along the z axis.
     * @param translateY The y translation.
     * @param skewZX The z skew factor along the x axis.
     * @param skewZY The z skew factor along the y axis.
     * @param scaleZ The z scaling factor.
     * @param translateZ The z translation.
     * @returns This transformation, after it has been changed.
     */
    set(scaleX: number, skewXY: number, skewXZ: number, translateX: number, skewYX: number, scaleY: number, skewYZ: number, translateY: number, skewZX: number, skewZY: number, scaleZ: number, translateZ: number): this;
    /**
     * Sets the parameters of this transformation from another transformation.
     * @param transform The transformation from which to take parameters.
     */
    set(transform: ReadonlyTransform3D): this;
    /**
     * Sets the x scaling factor of this transformation.
     * @param value The new x scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScaleX(value: number): this;
    /**
     * Sets the y scaling factor of this transformation.
     * @param value The new y scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScaleY(value: number): this;
    /**
     * Sets the z scaling factor of this transformation.
     * @param value The new z scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScaleZ(value: number): this;
    /**
     * Sets the x and y scaling factors of this transformation.
     * @param x The new x scaling factor.
     * @param y The new y scaling factor.
     * @param z The new z scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScale(x: number, y: number, z: number): this;
    /**
     * Sets the x skew factor of this transformation.
     * @param y The new x skew factor along the y axis.
     * @param z The new x skew factor along the z axis.
     * @returns This transformation, after it has been changed.
     */
    setSkewX(y: number, z: number): this;
    /**
     * Sets the y skew factor of this transformation.
     * @param x The new y skew factor along the x axis.
     * @param z The new y skew factor along the z axis.
     * @returns This transformation, after it has been changed.
     */
    setSkewY(x: number, z: number): this;
    /**
     * Sets the z skew factor of this transformation.
     * @param x The new z skew factor along the x axis.
     * @param y The new z skew factor along the y axis.
     * @returns This transformation, after it has been changed.
     */
    setSkewZ(x: number, y: number): this;
    /**
     * Sets the x translation of this transformation.
     * @param value The new x translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslateX(value: number): this;
    /**
     * Sets the y translation of this transformation.
     * @param value The new y translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslateY(value: number): this;
    /**
     * Sets the z translation of this transformation.
     * @param value The new z translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslateZ(value: number): this;
    /**
     * Sets the x and y translations of this transformation.
     * @param x The new x translation.
     * @param y The new y translation.
     * @param z The new z translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslate(x: number, y: number, z: number): this;
    /**
     * Inverts this transformation.
     * @returns This transformation, after it has been inverted.
     * @throws Error if this transformation cannot be inverted.
     */
    invert(): this;
    /**
     * Copies this transformation.
     * @returns A copy of this transformation.
     */
    copy(): Transform3D;
    /**
     * Applies this transformation to a 3D vector.
     * @param vec A 3D vector.
     * @param out The vector to which to write the result.
     * @returns The result of applying this transformation to `vec`.
     */
    apply(vec: ReadonlyFloat64Array, out: Float64Array): Float64Array;
    private static readonly offsetOriginCache;
    /**
     * Changes this transformation to the one that is the result of offsetting this transformation's origin.
     * @param x The x-coordinate of the offset origin.
     * @param y The y-coordinate of the offset origin.
     * @param z The z-coordinate of the offset origin.
     * @returns This transformation, after it has been changed.
     */
    offsetOrigin(x: number, y: number, z: number): this;
    /**
     * Sets this transformation to the identity transformation.
     * @returns This transformation, after it has been changed.
     */
    toIdentity(): this;
    /**
     * Sets this transformation to a translation.
     * @param x The x translation.
     * @param y The y translation.
     * @param z The z translation.
     * @returns This transformation, after it has been changed.
     */
    toTranslation(x: number, y: number, z: number): this;
    /**
     * Sets this transformation to a scaling about the origin (0, 0, 0).
     * @param x The x scaling factor.
     * @param y The y scaling factor.
     * @param z The z scaling factor.
     * @returns This transformation, after it has been changed.
     */
    toScale(x: number, y: number, z: number): this;
    /**
     * Sets this transformation to a scaling about an arbitrary origin.
     * @param x The x scaling factor.
     * @param y The y scaling factor.
     * @param z The z scaling factor.
     * @param originX The x-coordinate of the scaling origin.
     * @param originY The y-coordinate of the scaling origin.
     * @param originZ The z-coordinate of the scaling origin.
     * @returns This transformation, after it has been changed.
     */
    toScale(x: number, y: number, z: number, originX: number, originY: number, originZ: number): this;
    /**
     * Sets this transformation to a rotation about an axis parallel to the x axis passing through the origin (0, 0, 0).
     * @param theta The rotation angle, in radians.
     * @returns This transformation, after it has been changed.
     */
    toRotationX(theta: number): this;
    /**
     * Sets this transformation to a rotation about an axis parallel to the x axis passing through an arbitrary point.
     * @param theta The rotation angle, in radians.
     * @param originX The x-coordinate of the rotation origin.
     * @param originY The y-coordinate of the rotation origin.
     * @param originZ The z-coordinate of the rotation origin.
     * @returns This transformation, after it has been changed.
     */
    toRotationX(theta: number, originX: number, originY: number, originZ: number): this;
    /**
     * Sets this transformation to a rotation about an axis parallel to the y axis passing through the origin (0, 0, 0).
     * @param theta The rotation angle, in radians.
     * @returns This transformation, after it has been changed.
     */
    toRotationY(theta: number): this;
    /**
     * Sets this transformation to a rotation about an axis parallel to the y axis passing through an arbitrary point.
     * @param theta The rotation angle, in radians.
     * @param originX The x-coordinate of the rotation origin.
     * @param originY The y-coordinate of the rotation origin.
     * @param originZ The z-coordinate of the rotation origin.
     * @returns This transformation, after it has been changed.
     */
    toRotationY(theta: number, originX: number, originY: number, originZ: number): this;
    /**
     * Sets this transformation to a rotation about an axis parallel to the z axis passing through the origin (0, 0, 0).
     * @param theta The rotation angle, in radians.
     * @returns This transformation, after it has been changed.
     */
    toRotationZ(theta: number): this;
    /**
     * Sets this transformation to a rotation about an axis parallel to the z axis passing through an arbitrary point.
     * @param theta The rotation angle, in radians.
     * @param originX The x-coordinate of the rotation origin.
     * @param originY The y-coordinate of the rotation origin.
     * @param originZ The z-coordinate of the rotation origin.
     * @returns This transformation, after it has been changed.
     */
    toRotationZ(theta: number, originX: number, originY: number, originZ: number): this;
    /**
     * Sets this transformation to a rotation about an arbitrary axis passing through the origin (0, 0, 0).
     * @param theta The rotation angle, in radians.
     * @param axisX The x component of the vector defining the direction of the rotation axis.
     * @param axisY The y component of the vector defining the direction of the rotation axis.
     * @param axisZ The z component of the vector defining the direction of the rotation axis.
     * @returns This transformation, after it has been changed.
     */
    toRotation(theta: number, axisX: number, axisY: number, axisZ: number): this;
    /**
     * Sets this transformation to a rotation about an arbitrary axis passing through an arbitrary point.
     * @param theta The rotation angle, in radians.
     * @param axisX The x component of the vector defining the direction of the rotation axis.
     * @param axisY The y component of the vector defining the direction of the rotation axis.
     * @param axisZ The z component of the vector defining the direction of the rotation axis.
     * @param originX The x-coordinate of the rotation origin.
     * @param originY The y-coordinate of the rotation origin.
     * @param originZ The z-coordinate of the rotation origin.
     * @returns This transformation, after it has been changed.
     */
    toRotation(theta: number, axisX: number, axisY: number, axisZ: number, originX: number, originY: number, originZ: number): this;
    private static readonly concatCache;
    /**
     * Concatenates one or more transformations and returns the result. Concatenating transformations `[A, B, ...]`
     * results in a transformation that is equivalent to first applying `A`, then applying `B`, etc. Note that this order
     * is the _opposite_ of the one resulting from multiplying the individual transformation _matrices_
     * `M_A * M_B * ...`.
     *
     * If the number of transformations to concatenate equals zero, the identity matrix is returned.
     * @param out The transformation to which to write the result.
     * @param transforms The transformations to concatenate, in order.
     * @returns The result of concatenating all transformations in `transforms`.
     */
    static concat<T extends Transform3D>(out: T, transforms: readonly ReadonlyTransform3D[]): T;
}

/**
 * A readonly perspective transformation.
 */
declare type ReadonlyTransformPerspective = Pick<TransformPerspective, 'getCameraPosition' | 'getCameraRotation' | 'getSurfacePosition' | 'apply' | 'copy'>;
/**
 * A perspective transformation.
 */
declare class TransformPerspective {
    private static readonly vec3Cache;
    private readonly cameraPos;
    private readonly surfacePos;
    private readonly cameraPosTransform;
    private readonly cameraRotationTransform;
    private readonly cameraRotationInverseTransform;
    private readonly allCameraTransforms;
    private readonly fullTransform;
    /**
     * Gets the position of this transformation's camera, as `[x, y, z]` in world coordinates.
     * @returns The position of this transformation's camera, as `[x, y, z]` in world coordinates.
     */
    getCameraPosition(): ReadonlyFloat64Array;
    /**
     * Gets the transformation representing the rotation of this transformation's camera.
     * @returns The transformation representing the rotation of this transformation's camera.
     */
    getCameraRotation(): ReadonlyTransform3D;
    /**
     * Gets the position of this transformation's projection surface relative to the camera, as `[x, y, z]` in camera
     * coordinates.
     * @returns The position of this transformation's projection surface relative to the camera, as `[x, y, z]` in camera
     * coordinates.
     */
    getSurfacePosition(): ReadonlyFloat64Array;
    /**
     * Sets the parameters of this transformation.
     * @param cameraPos The position of the camera, as `[x, y, z]` in world coordinates.
     * @param cameraRotation A transformation representing the rotation of the camera.
     * @param surfacePos The position of the projection surface relative to the camera, as `[x, y, z]` in camera
     * coordinates.
     * @returns This transformation, after it has been changed.
     */
    set(cameraPos: ReadonlyFloat64Array, cameraRotation: ReadonlyTransform3D, surfacePos: ReadonlyFloat64Array): this;
    /**
     * Sets the parameters of this transformation from another transformation.
     * @param transform The transformation from which to take parameters.
     */
    set(transform: ReadonlyTransformPerspective): this;
    /**
     * Sets the position of this projection's camera. Does not update the full camera transformation.
     * @param cameraPos The position of the camera, as `[x, y, z]` in world coordinates.
     */
    private _setCameraPosition;
    /**
     * Sets the rotation of this projection's camera. Does not update the full camera transformation.
     * @param cameraRotation A transformation representing the rotation of the camera.
     */
    _setCameraRotation(cameraRotation: ReadonlyTransform3D): void;
    /**
     * Sets the position of this projection's camera.
     * @param cameraPos The position of the camera, as `[x, y, z]` in world coordinates.
     * @returns This transformation, after it has been changed.
     */
    setCameraPosition(cameraPos: ReadonlyFloat64Array): this;
    /**
     * Sets the rotation of this projection's camera.
     * @param cameraRotation A transformation representing the rotation of the camera.
     * @returns This transformation, after it has been changed.
     */
    setCameraRotation(cameraRotation: ReadonlyTransform3D): this;
    /**
     * Sets the position of this transformation's projection surface relative to the camera.
     * @param surfacePos The position of the projection surface relative to the camera, as `[x, y, z]` in camera
     * coordinates.
     * @returns This transformation, after it has been changed.
     */
    setSurfacePosition(surfacePos: ReadonlyFloat64Array): this;
    /**
     * Copies this transformation.
     * @returns A copy of this transformation.
     */
    copy(): TransformPerspective;
    /**
     * Applies this transformation to a 3D vector.
     * @param vec A 3D vector, in world coordinates.
     * @param out The 2D vector to which to write the result.
     * @returns The result of applying this transformation to `vec`.
     */
    apply(vec: ReadonlyFloat64Array, out: Float64Array): Float64Array;
}

/**
 * A utitlity class for calculating a numerical average of a selected number of samples.
 */
declare class SimpleMovingAverage {
    private samples;
    private _values;
    /**
     * Class to return a numerical average from a specified number of inputs.
     * @param samples is the number of samples.
     */
    constructor(samples: number);
    /**
     * Returns a numerical average of the inputs.
     * @param input is the input number.
     * @returns The numerical average.
     */
    getAverage(input: number): number;
    /**
     * Resets the average.
     */
    reset(): void;
}

/**
 * A utitlity class for basic math.
 */
declare class MathUtils {
    /** Twice the value of pi. */
    static readonly TWO_PI: number;
    /** Half the value of pi. */
    static readonly HALF_PI: number;
    /**
     * Clamps a numerical value to the min/max range.
     * @param value The value to be clamped.
     * @param min The minimum.
     * @param max The maximum.
     *
     * @returns The clamped numerical value..
     */
    static clamp(value: number, min: number, max: number): number;
    /**
     * Rounds a number.
     * @param value The number to round.
     * @param precision The precision with which to round. Defaults to `1`.
     * @returns The rounded number.
     */
    static round(value: number, precision?: number): number;
    /**
     * Calculates the angular difference between two angles in the range `[0, 2 * pi)`. The calculation supports both
     * directional and non-directional differences. The directional difference is the angle swept from the start angle
     * to the end angle proceeding in the direction of increasing angle. The non-directional difference is the smaller
     * of the two angles swept from the start angle to the end angle proceeding in either direction.
     * @param start The starting angle, in radians.
     * @param end The ending angle, in radians.
     * @param directional Whether to calculate the directional difference. Defaults to `true`.
     * @returns The angular difference between the two angles, in radians, in the range `[0, 2 * pi)`.
     */
    static diffAngle(start: number, end: number, directional?: boolean): number;
    /**
     * Linearly interpolates a keyed value along one dimension.
     * @param x The key of the value to interpolate.
     * @param x0 The key of the first known value.
     * @param x1 The key of the second known value.
     * @param y0 The first known value.
     * @param y1 The second known value.
     * @param clampStart Whether to clamp the interpolated value to the first known value. Defaults to false.
     * @param clampEnd Whether to clamp the interpolated value to the second known value. Defaults to false.
     * @returns The interpolated value corresponding to the specified key.
     */
    static lerp(x: number, x0: number, x1: number, y0: number, y1: number, clampStart?: boolean, clampEnd?: boolean): number;
}

/**
 * Applies time-weighted exponential smoothing (i.e. an exponential moving average) to a sequence of raw values. When
 * a new raw value is added to the sequence, it and the last smoothed value are weighted according to the time elapsed
 * since the last smoothed value was calculated (i.e. since the last raw value was added) and averaged. The calculation
 * of the weighting is such that the weight of each raw value in the sequence decays exponentially with the "age"
 * (i.e. time elapsed between when that value was added to the sequence and when the latest value was added to the
 * sequence) of the value.
 */
declare class ExpSmoother {
    readonly tau: number;
    readonly dtThreshold: number;
    private lastValue;
    /**
     * Constructor.
     * @param tau This smoother's time constant. The larger the constant, the greater the smoothing effect.
     * @param initial The initial smoothed value of this smoother. Defaults to null.
     * @param dtThreshold The elapsed time threshold, in seconds, above which this smoother will not smooth a new raw
     * value. Defaults to infinity.
     */
    constructor(tau: number, initial?: number | null, dtThreshold?: number);
    /**
     * Gets the last smoothed value.
     * @returns the last smoothed value, or null if none exists.
     */
    last(): number | null;
    /**
     * Adds a new raw value and gets the next smoothed value. If the new raw value is the first to be added since this
     * smoother was created or reset with no initial smoothed value, the returned smoothed value will be equal to the
     * raw value.
     * @param raw The new raw value.
     * @param dt The elapsed time, in seconds, since the last raw value was added.
     * @returns The next smoothed value.
     */
    next(raw: number, dt: number): number;
    /**
     * Calculates the smoothing factor for a given time interval.
     * @param dt A time interval, in seconds.
     * @returns the smoothing factor for the given time interval.
     */
    private calculateFactor;
    /**
     * Resets the "history" of this smoother and optionally sets the initial smoothed value.
     * @param value The new initial smoothed value. Defaults to null.
     * @returns The reset smoothed value.
     */
    reset<T extends number | null>(value?: T): T;
    /**
     * Applies exponential smoothing.
     * @param value The value to smooth.
     * @param last The last smoothed value.
     * @param factor The smoothing factor.
     * @returns A smoothed value.
     */
    private static smooth;
}

/**
 * A visitor function for k-d tree searches.
 * @param element A search result.
 * @param key The key of the search result.
 * @param distance The distance from the search result's key to the query key.
 * @param queryKey The query key.
 * @param queryElement The query element, or undefined if the search was initiated directly from a key.
 * @returns Whether to continue the search.
 */
declare type KdTreeSearchVisitor<T> = (element: T, key: ReadonlyFloat64Array, distance: number, queryKey: ReadonlyFloat64Array, queryElement: T | undefined) => boolean;
/**
 * A filtering function for k-d tree searches.
 * @param element A candidate search result.
 * @param key The key of the candidate search result.
 * @param distance The distance from the candidate search result's key to the query key.
 * @param queryKey The query key.
 * @param queryElement The query element, or undefined if the search was initiated directly from a key.
 * @returns Whether to include the candidate in the final search results.
 */
declare type KdTreeSearchFilter<T> = (element: T, key: ReadonlyFloat64Array, distance: number, queryKey: ReadonlyFloat64Array, queryElement: T | undefined) => boolean;
/**
 * A k-dimensional search tree.
 */
declare class KdTree<T> {
    private readonly keyFunc;
    readonly dimensionCount: number;
    private readonly elements;
    private readonly keys;
    private readonly nodes;
    private minDepth;
    private maxDepth;
    private readonly indexArrays;
    private readonly indexSortFuncs;
    private readonly keyCache;
    /** The number of elements in this tree. */
    get size(): number;
    /**
     * Constructor.
     * @param dimensionCount The number of dimensions supported by this tree. If this argument is not an integer, it will
     * be truncated to one.
     * @param keyFunc A function which generates keys from elements. Keys are an N-tuple of numbers, where N is equal to
     * the dimension count of this tree.
     * @throws Error if the dimension count is less than 2.
     */
    constructor(dimensionCount: number, keyFunc: (element: T, out: Float64Array) => Float64Array);
    /**
     * Searches this tree for elements whose keys are located near a query key and visits each of them with a function.
     * @param key The query key.
     * @param radius The radius around the query key to search.
     * @param visitor A visitor function. This function will be called once per element found within the search radius.
     * If the visitor returns `true`, then the search will continue; if the visitor returns `false`, the search will
     * immediately halt.
     */
    searchKey(key: ReadonlyFloat64Array, radius: number, visitor: KdTreeSearchVisitor<T>): void;
    /**
     * Searches this tree for elements whose keys are located near a query key and returns them in order of increasing
     * distance from the query key.
     * @param key The query key.
     * @param radius The radius around the query key to search.
     * @param maxResultCount The maximum number of search results to return.
     * @param out An array in which to store the search results.
     * @param filter A function to filter the search results.
     * @returns An array containing the search results, in order of increasing distance from the query key.
     */
    searchKey(key: ReadonlyFloat64Array, radius: number, maxResultCount: number, out: T[], filter?: KdTreeSearchFilter<T>): T[];
    /**
     * Searches this tree for elements whose keys are located near the key of a query element and visits each of them
     * with a function.
     * @param element The query element.
     * @param radius The radius around the query element's key to search.
     * @param visitor A visitor function. This function will be called once per element found within the search radius.
     * If the visitor returns `true`, then the search will continue; if the visitor returns `false`, the search will
     * immediately halt.
     */
    search(element: T, radius: number, visitor: KdTreeSearchVisitor<T>): void;
    /**
     * Searches this tree for elements whose keys are located near the key of a query element and returns them in order
     * of increasing distance from the query key.
     * @param element The query element.
     * @param radius The radius around the query key to search.
     * @param maxResultCount The maximum number of search results to return.
     * @param out An array in which to store the search results.
     * @param filter A function to filter the search results.
     * @returns An array containing the search results, in order of increasing distance from the query key.
     */
    search(element: T, radius: number, maxResultCount: number, out: T[], filter?: KdTreeSearchFilter<T>): T[];
    /**
     * Performs a tree search with a visitor function.
     * @param element The query element, or undefined if none exists.
     * @param key The query key.
     * @param radius The search radius.
     * @param visitor A visitor function. This function will be called once per element found within the search radius.
     * If the visitor returns `true`, then the search will continue; if the visitor returns `false`, the search will
     * immediately halt.
     */
    private doVisitorSearch;
    /**
     * Performs a tree search and returns an array of search results.
     * @param element The query element, or undefined if none exists.
     * @param key The query key.
     * @param radius The search radius.
     * @param maxResultCount The maximum number of search results to return.
     * @param out An array in which to store the search results.
     * @param filter A function to filter the search results.
     * @returns An array containing the search results, in order of increasing distance from the query key.
     */
    private doResultsSearch;
    /**
     * Searches a subtree for elements whose keys are located near a query key.
     * @param element The query element, or undefined if none exists.
     * @param key The query key.
     * @param radius The search radius.
     * @param nodeIndex The index of the root of the subtree to search.
     * @param pivotDimension The dimension in which the root of the subtree is split.
     * @param resultHandler A function which will be called once per element found within the search radius. If the
     * function returns `true`, then the search will continue; if the function returns `false`, the search will
     * immediately halt.
     * @param traversalHandler A function which determines whether the search will proceed to a child node. If the
     * function returns `true`, the search will continue; if the function returns `false`, the search will skip the
     * child.
     * @returns `false` if the search was terminated prematurely by the `resultHandler` function, and `true` otherwise.
     */
    private searchTree;
    /**
     * Inserts an element into this tree. This operation will trigger a rebalancing if, after the insertion, the length
     * of this tree's longest branch is more than twice the length of the shortest branch.
     * @param element The element to insert.
     */
    insert(element: T): void;
    /**
     * Inserts a batch of elements into this tree. This tree will be rebalanced after the elements are inserted.
     * @param elements An iterable of the elements to insert.
     */
    insertAll(elements: Iterable<T>): void;
    /**
     * Inserts an element into this tree.
     * @param element The element to insert.
     * @returns The depth at which the element was inserted, with 0 being the depth of the root.
     */
    private insertElementInTree;
    /**
     * Removes an element from this tree. This tree will be rebalanced after the element is removed.
     * @param element The element to remove.
     * @returns Whether the element was removed.
     */
    remove(element: T): boolean;
    /**
     * Removes a batch of elements from this tree. This tree will be rebalanced after the elements are removed.
     * @param elements An iterable of the elements to remove.
     * @returns Whether at least one element was removed.
     */
    removeAll(elements: Iterable<T>): boolean;
    /**
     * Removes an element and all references to it from this tree's arrays. This method does not change the structure
     * of this tree to reflect the removal of the element.
     * @param element The element to remove.
     * @returns Whether the element was removed.
     */
    private removeElementFromArrays;
    /**
     * Removes elements from this tree, then inserts elements into this tree as a single operation. The tree will be
     * rebalanced at the end of the operation.
     *
     * Using this method is more efficient than calling `removeAll()` and `insertAll()` separately.
     * @param toRemove An iterable of the elements to remove.
     * @param toInsert An iterable of the elements to insert.
     */
    removeAndInsert(toRemove: Iterable<T>, toInsert: Iterable<T>): void;
    /**
     * Rebuilds and balances this tree.
     */
    rebuild(): void;
    /**
     * Builds a portion of this tree starting from a specified node using the element indexes stored in a specified
     * section of this tree's index arrays. The built subtree is guaranteed to be balanced. Before calling this method,
     * the index array at position 0 should contain keys sorted in the specified pivot dimension, the array at position
     * 1 should contain keys sorted in the dimension after the pivot dimension, etc (with the dimension wrapping back to
     * 0 when reaching `this.dimensionCount`).
     * @param nodeIndex The index of the tree node at which to start building the tree. The element associated with the
     * pivot key will be placed at this node.
     * @param pivotDimension The dimension in which to split the first level of the tree built by this method.
     * @param start The first index, inclusive, of the section of this tree's index arrays to use to build the tree.
     * @param end The last index, exclusive, of the section of this tree's index arrays to use to build the tree.
     */
    private buildSubTree;
    /**
     * Removes all elements from this tree.
     */
    clear(): void;
    /**
     * Finds the index of a node's parent.
     * @param index the index of the node for which to find the parent.
     * @returns The index of the query node's parent.
     */
    private static parent;
    /**
     * Finds the index of a node's lesser child.
     * @param index The index of the node for which to find the child.
     * @returns The index of the query node's lesser child.
     */
    private static lesser;
    /**
     * Finds the index of a node's greater child.
     * @param index The index of the node for which to find the child.
     * @returns The idnex of the query node's greater child.
     */
    private static greater;
    /**
     * Finds the least index of any node located at a given depth.
     * @param depth The depth for which to get the least index. The root of the tree lies at depth 0.
     * @returns The least index of any node located at the specified depth.
     */
    private static leastIndexAtDepth;
    /**
     * Finds the depth at which a node lies.
     * @param index The index of the node for which to find the depth.
     * @returns The depth at which the node lies. The root of the tree lies at depth 0.
     */
    private static depth;
    /**
     * Calculates the Euclidean distance between two keys.
     * @param key1 The first key.
     * @param key2 The second key.
     * @param dimensionCount The number of dimensions in which to calculate the distance.
     * @returns The Euclidean distance between the two keys.
     */
    private static distance;
}

/**
 * A set of latitude/longitude coordinates.
 */
interface LatLonInterface {
    /** The latitude, in degrees. */
    lat: number;
    /** The longitude, in degrees. */
    lon: number;
}
/**
 * A set of latitude/longitude coordinates.
 */
interface LatLongInterface {
    /** The latitude, in degrees. */
    lat: number;
    /** The longitude, in degrees. */
    long: number;
}

/**
 * A utility class for working with magnetic variation (magnetic declination).
 */
declare class MagVar {
    /**
     * Gets the magnetic variation (magnetic declination) at a specific point on Earth. Positive values signify eastward
     * deflection, and negative values signify westward deflection.
     * @param lat The latitude of the query point.
     * @param lon The longitude of the query point.
     * @returns The magnetic variation (magnetic declination) at the point.
     */
    static get(lat: number, lon: number): number;
    /**
     * Gets the magnetic variation (magnetic declination) at a specific point on Earth. Positive values signify eastward
     * deflection, and negative values signify westward deflection.
     * @param point The query point.
     * @returns The magnetic variation (magnetic declination) at the point.
     */
    static get(point: LatLonInterface): number;
    /**
     * Converts magnetic bearing to true bearing at a specific point on Earth.
     * @param bearing A magnetic bearing.
     * @param lat The latitude of the query point.
     * @param lon The longitude of the query point.
     * @returns The true bearing equivalent of the given magnetic bearing at the specified point.
     */
    static magneticToTrue(bearing: number, lat: number, lon: number): number;
    /**
     * Converts magnetic bearing to true bearing at a specific point on Earth.
     * @param bearing A magnetic bearing.
     * @param point The query point.
     * @returns The true bearing equivalent of the given magnetic bearing at the specified point.
     */
    static magneticToTrue(bearing: number, point: LatLonInterface): number;
    /**
     * Converts magnetic bearing to true bearing given a specific magnetic variation (magnetic declination).
     * @param bearing A magnetic bearing.
     * @param magVar The magnetic variation.
     * @returns The true bearing equivalent of the given magnetic bearing.
     */
    static magneticToTrue(bearing: number, magVar: number): number;
    /**
     * Converts true bearing to magnetic bearing at a specific point on Earth.
     * @param bearing A true bearing.
     * @param lat The latitude of the query point.
     * @param lon The longitude of the query point.
     * @returns The magnetic bearing equivalent of the given true bearing at the specified point.
     */
    static trueToMagnetic(bearing: number, lat: number, lon: number): number;
    /**
     * Converts true bearing to magnetic bearing at a specific point on Earth.
     * @param bearing A true bearing.
     * @param point The query point.
     * @returns The magnetic bearing equivalent of the given true bearing at the specified point.
     */
    static trueToMagnetic(bearing: number, point: LatLonInterface): number;
    /**
     * Converts true bearing to magnetic bearing given a specific magnetic variation (magnetic declination).
     * @param bearing A true bearing.
     * @param magVar The magnetic variation.
     * @returns The magnetic bearing equivalent of the given true bearing.
     */
    static trueToMagnetic(bearing: number, magVar: number): number;
    /**
     * Gets the magnetic variation (magnetic declination) at a specific point on Earth.
     * @param arg1 The query point, or the latitude of the query point.
     * @param arg2 The longitude of the query point.
     * @returns The magnetic variation (magnetic declination) at the point.
     */
    private static getMagVar;
}

/**
 * A representation of a point on Earth's surface.
 */
interface GeoPointInterface {
    /** The latitude of the point. */
    lat: number;
    /** The longitude of the point. */
    lon: number;
    /**
     * Calculates the great-circle distance between this point and another point.
     * @param other The point to which to calculate the distance.
     * @returns The great-circle distance to the other point, in great-arc radians.
     */
    distance(other: LatLonInterface): number;
    /**
     * Calculates the great-circle distance between this point and another point.
     * @param lat The latitude of the point to which to calculate the distance.
     * @param lon The longitude of the point to which to calculate the distance.
     * @returns The great-circle distance to the other point, in great-arc radians.
     */
    distance(lat: number, lon: number): number;
    /**
     * Calculates the distance along the rhumb line connecting this point with another point.
     * @param other The other point.
     * @returns The rhumb-line distance to the other point, in great-arc radians.
     */
    distanceRhumb(other: LatLonInterface): number;
    /**
     * Calculates the distance along the rhumb line connecting this point with another point.
     * @param lat The latitude of the other point, in degrees.
     * @param lon The longitude of the other point, in degrees.
     * @returns The rhumb-line distance to the other point, in great-arc radians.
     */
    distanceRhumb(lat: number, lon: number): number;
    /**
     * Calculates the initial true bearing (forward azimuth) from this point to another point along the great circle
     * connecting the two.
     * @param other The other point.
     * @returns The initial true bearing to the other point, in degrees.
     */
    bearingTo(other: LatLonInterface): number;
    /**
     * Calculates the initial true bearing (forward azimuth) from this point to another point along the great circle
     * connecting the two.
     * @param lat The latitude of the other point, in degrees.
     * @param lon The longitude of the other point, in degrees.
     * @returns The initial true bearing to the other point, in degrees.
     */
    bearingTo(lat: number, lon: number): number;
    /**
     * Calculates the final true bearing from another point to this point (i.e. the back azimuth from this point to the
     * other point) along the great circle connecting the two.
     * @param other The other point.
     * @returns The final true bearing from the other point, in degrees.
     */
    bearingFrom(other: LatLonInterface): number;
    /**
     * Calculates the final true bearing from another point to this point (i.e. the back azimuth from this point to the
     * other point) along the great circle connecting the two.
     * @param lat The latitude of the other point, in degrees.
     * @param lon The longitude of the other point, in degrees.
     * @returns The final true bearing from the other point, in degrees.
     */
    bearingFrom(lat: number, lon: number): number;
    /**
     * Calculates the constant true bearing from this point to another point along the rhumb line connecting the two.
     * @param other The other point.
     * @returns The constant true bearing to the other point, in degrees.
     */
    bearingRhumb(other: LatLonInterface): number;
    /**
     * Calculates the constant true bearing from this point to another point along the rhumb line connecting the two.
     * @param lat The latitude of the other point, in degrees.
     * @param lon The longitude of the other point, in degrees.
     * @returns The constant true bearing to the other point, in degrees.
     */
    bearingRhumb(lat: number, lon: number): number;
    /**
     * Offsets this point by an initial bearing and distance along a great circle.
     * @param bearing The initial true bearing (forward azimuth), in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the results.
     * @returns The offset point.
     */
    offset(bearing: number, distance: number, out?: GeoPoint): GeoPoint;
    /**
     * Offsets this point by a constant bearing and distance along a rhumb line.
     * @param bearing The true bearing, in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the results.
     * @returns The offset point.
     */
    offsetRhumb(bearing: number, distance: number, out?: GeoPoint): GeoPoint;
    /**
     * Calculates the cartesian (x, y, z) representation of this point, in units of great-arc radians. By convention,
     * in the cartesian coordinate system the origin is at the center of the Earth, the positive x-axis passes through
     * 0 degrees N, 0 degrees E, and the positive z-axis passes through the north pole.
     * @param out The vector array to which to write the result.
     * @returns The cartesian representation of this point.
     */
    toCartesian(out: Float64Array): Float64Array;
    /**
     * Checks whether this point is equal to another point.
     * @param other The other point.
     * @param tolerance The tolerance of the equality check, defined as the maximum allowed distance between two equal
     * points in great-arc radians.
     * @returns Whether this point is equal to the other point.
     */
    equals(other: LatLonInterface, tolerance?: number): boolean;
    /**
     * Checks whether this point is equal to another point.
     * @param lat The latitude of the other point, in degrees.
     * @param lon The longitude of the other point, in degrees.
     * @param tolerance The tolerance of the equality check, defined as the maximum allowed distance between two equal
     * points in great-arc radians.
     * @returns Whether this point is equal to the other point.
     */
    equals(lat: number, lon: number, tolerance?: number): boolean;
    /**
     * Copies this point.
     * @param to An optional point to which to copy this point. If this argument is not supplied, a new GeoPoint object
     * will be created.
     * @returns A copy of this point.
     */
    copy(to?: GeoPoint): GeoPoint;
}
/**
 * A read-only wrapper for a GeoPoint.
 */
declare class GeoPointReadOnly implements GeoPointInterface, LatLonInterface {
    private readonly source;
    /**
     * Constructor.
     * @param source - the source of the new read-only point.
     */
    constructor(source: GeoPoint);
    /**
     * The latitude of this point, in degrees.
     * @returns the latitude of this point.
     */
    get lat(): number;
    /**
     * The longitude of this point, in degrees.
     * @returns the longitude of this point.
     */
    get lon(): number;
    /** @inheritdoc */
    distance(other: LatLonInterface): number;
    /** @inheritdoc */
    distance(lat: number, lon: number): number;
    /** @inheritdoc */
    distanceRhumb(other: LatLonInterface): number;
    /** @inheritdoc */
    distanceRhumb(lat: number, lon: number): number;
    /** @inheritdoc */
    bearingTo(other: LatLonInterface): number;
    /** @inheritdoc */
    bearingTo(lat: number, lon: number): number;
    /** @inheritdoc */
    bearingFrom(other: LatLonInterface): number;
    /** @inheritdoc */
    bearingFrom(lat: number, lon: number): number;
    /** @inheritdoc */
    bearingRhumb(other: LatLonInterface): number;
    /** @inheritdoc */
    bearingRhumb(lat: number, lon: number): number;
    /**
     * Offsets this point by an initial bearing and distance along a great circle.
     * @param bearing The initial true bearing (forward azimuth), in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the results. If not supplied, a new GeoPoint object is created.
     * @returns The offset point.
     * @throws {Error} if argument `out` is undefined.
     */
    offset(bearing: number, distance: number, out?: GeoPoint): GeoPoint;
    /**
     * Offsets this point by a constant bearing and distance along a rhumb line.
     * @param bearing The true bearing, in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the results. If not supplied, a new GeoPoint object is created.
     * @returns The offset point.
     * @throws {Error} If argument `out` is undefined.
     */
    offsetRhumb(bearing: number, distance: number, out?: GeoPoint): GeoPoint;
    /**
     * Calculates the cartesian (x, y, z) representation of this point, in units of great-arc radians. By convention,
     * in the cartesian coordinate system the origin is at the center of the Earth, the positive x-axis passes through
     * 0 degrees N, 0 degrees E, and the positive z-axis passes through the north pole.
     * @param out The vector array to which to write the result.
     * @returns The cartesian representation of this point.
     */
    toCartesian(out: Float64Array): Float64Array;
    /** @inheritdoc */
    equals(other: LatLonInterface, tolerance?: number): boolean;
    /** @inheritdoc */
    equals(lat: number, lon: number, tolerance?: number): boolean;
    /** @inheritdoc */
    copy(to?: GeoPoint): GeoPoint;
}
/**
 * A point on Earth's surface. This class uses a spherical Earth model.
 */
declare class GeoPoint implements GeoPointInterface, LatLonInterface {
    /**
     * The default equality tolerance, defined as the maximum allowed distance between two equal points in great-arc
     * radians.
     */
    static readonly EQUALITY_TOLERANCE = 1e-7;
    private static readonly tempVec3;
    private static readonly tempGeoPoint;
    private _lat;
    private _lon;
    readonly readonly: GeoPointReadOnly;
    /**
     * Constructor.
     * @param lat The latitude, in degrees.
     * @param lon The longitude, in degrees.
     */
    constructor(lat: number, lon: number);
    /**
     * The latitude of this point, in degrees.
     * @returns the latitude of this point.
     */
    get lat(): number;
    /**
     * The longitude of this point, in degrees.
     * @returns the longitude of this point.
     */
    get lon(): number;
    /**
     * Converts an argument list consisting of either a LatLonInterface or lat/lon coordinates into an equivalent
     * LatLonInterface.
     * @param arg1 Argument 1.
     * @param arg2 Argument 2.
     * @returns A LatLonInterface.
     */
    private static asLatLonInterface;
    /**
     * Converts an argument list consisting of either a 3D vector or x, y, z components into an equivalent 3D vector.
     * @param arg1 Argument 1.
     * @param arg2 Argument 2.
     * @param arg3 Argument 3.
     * @returns A 3D vector.
     */
    private static asVec3;
    /**
     * Sets this point's latitude/longitude values.
     * @param other The point from which to take the new latitude/longitude values.
     * @returns This point, after it has been changed.
     */
    set(other: LatLonInterface): this;
    /**
     * Sets this point's latitude/longitude values.
     * @param lat The new latitude, in degrees.
     * @param lon The new longitude, in degrees.
     * @returns This point, after it has been changed.
     */
    set(lat: number, lon: number): this;
    /**
     * Sets this point's coordinate values from a cartesian position vector. By convention, in the cartesian coordinate
     * system the origin is at the center of the Earth, the positive x-axis passes through 0 degrees N, 0 degrees E, and
     * the positive z-axis passes through the north pole.
     * @param vec A position vector defining the new coordinates.
     * @returns This point, after it has been changed.
     */
    setFromCartesian(vec: ReadonlyFloat64Array): this;
    /**
     * Sets this point's coordinate values from a cartesian position vector. By convention, in the cartesian coordinate
     * system the origin is at the center of the Earth, the positive x-axis passes through 0 degrees N, 0 degrees E, and
     * the positive z-axis passes through the north pole.
     * @param x The x component of a position vector defining the new coordinates.
     * @param y The y component of a position vector defining the new coordinates.
     * @param z The z component of a position vector defining the new coordinates.
     * @returns This point, after it has been changed.
     */
    setFromCartesian(x: number, y: number, z: number): this;
    /** @inheritdoc */
    distance(other: LatLonInterface): number;
    /** @inheritdoc */
    distance(lat: number, lon: number): number;
    /** @inheritdoc */
    distanceRhumb(other: LatLonInterface): number;
    /** @inheritdoc */
    distanceRhumb(lat: number, lon: number): number;
    /** @inheritdoc */
    bearingTo(other: LatLonInterface): number;
    /** @inheritdoc */
    bearingTo(lat: number, lon: number): number;
    /** @inheritdoc */
    bearingFrom(other: LatLonInterface): number;
    /** @inheritdoc */
    bearingFrom(lat: number, lon: number): number;
    /** @inheritdoc */
    bearingRhumb(other: LatLonInterface): number;
    /** @inheritdoc */
    bearingRhumb(lat: number, lon: number): number;
    /**
     * Offsets this point by an initial bearing and distance along a great circle.
     * @param bearing The initial true bearing (forward azimuth), in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the results. By default this point.
     * @returns The offset point.
     */
    offset(bearing: number, distance: number, out?: GeoPoint): GeoPoint;
    /**
     * Offsets this point by a constant bearing and distance along a rhumb line.
     * @param bearing The true bearing, in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the results. By default this point.
     * @returns The offset point.
     */
    offsetRhumb(bearing: number, distance: number, out?: GeoPoint): GeoPoint;
    /** @inheritdoc */
    toCartesian(out: Float64Array): Float64Array;
    /** @inheritdoc */
    equals(other: LatLonInterface, tolerance?: number): boolean;
    /** @inheritdoc */
    equals(lat: number, lon: number, tolerance?: number): boolean;
    /** @inheritdoc */
    copy(to?: GeoPoint): GeoPoint;
    /**
     * Calculates the cartesian (x, y, z) representation of a point, in units of great-arc radians. By convention,
     * in the cartesian coordinate system the origin is at the center of the Earth, the positive x-axis passes through
     * 0 degrees N, 0 degrees E, and the positive z-axis passes through the north pole.
     * @param point The point to convert.
     * @param out The vector array to which to write the result.
     * @returns the cartesian representation of the point.
     */
    static sphericalToCartesian(point: LatLonInterface, out: Float64Array): Float64Array;
    /**
     * Calculates the cartesian (x, y, z) representation of a point, in units of great-arc radians. By convention,
     * in the cartesian coordinate system the origin is at the center of the Earth, the positive x-axis passes through
     * 0 degrees N, 0 degrees E, and the positive z-axis passes through the north pole.
     * @param lat The latitude of the point to convert, in degrees.
     * @param lon The longitude of the point to convert, in degrees.
     * @param out The vector array to which to write the result.
     * @returns the cartesian representation of the point.
     */
    static sphericalToCartesian(lat: number, lon: number, out: Float64Array): Float64Array;
    /**
     * Checks whether two points are equal.
     * @param lat1 The latitude of the first point, in degrees.
     * @param lon1 The longitude of the first point, in degrees.
     * @param lat2 The latitude of the second point, in degrees.
     * @param lon2 The longitude of the second point, in degrees.
     * @param tolerance The tolerance of the equality check, defined as the maximum allowed distance between two equal
     * points in great-arc radians. Defaults to `GeoPoint.EQUALITY_TOLERANCE`.
     * @returns Whether the two points are equal.
     */
    static equals(lat1: number, lon1: number, lat2: number, lon2: number, tolerance?: number): boolean;
    /**
     * Checks whether two points are equal.
     * @param point1 The first point.
     * @param point2 The second point.
     * @param tolerance The tolerance of the equality check, defined as the maximum allowed distance between two equal
     * points in great-arc radians. Defaults to `GeoPoint.EQUALITY_TOLERANCE`.
     * @returns Whether the two points are equal.
     */
    static equals(point1: LatLonInterface, point2: LatLonInterface, tolerance?: number): boolean;
    /**
     * Checks whether two points are equal.
     * @param point1 The first point, in cartesian form.
     * @param point2 The second point, in cartesian form.
     * @param tolerance The tolerance of the equality check, defined as the maximum allowed distance between two equal
     * points in great-arc radians. Defaults to `GeoPoint.EQUALITY_TOLERANCE`.
     * @returns Whether the two points are equal.
     */
    static equals(point1: ReadonlyFloat64Array, point2: ReadonlyFloat64Array, tolerance?: number): boolean;
    /**
     * Calculates the great-circle distance between two points.
     * @param lat1 The latitude of the first point, in degrees.
     * @param lon1 The longitude of the first point, in degrees.
     * @param lat2 The latitude of the second point, in degrees.
     * @param lon2 The longitude of the second point, in degrees.
     * @returns The great-circle distance between the two points, in great-arc radians.
     */
    static distance(lat1: number, lon1: number, lat2: number, lon2: number): number;
    /**
     * Calculates the great-circle distance between two points.
     * @param point1 The first point.
     * @param point2 The second point.
     * @returns The great-circle distance between the two points, in great-arc radians.
     */
    static distance(point1: LatLonInterface, point2: LatLonInterface): number;
    /**
     * Calculates the great-circle distance between two points.
     * @param point1 The first point, in cartesian form.
     * @param point2 The second point, in cartesian form.
     * @returns The great-circle distance between the two points, in great-arc radians.
     */
    static distance(point1: ReadonlyFloat64Array, point2: ReadonlyFloat64Array): number;
    /**
     * Calculates the distance along the rhumb line connecting this point with another point.
     * @param lat1 The latitude of the first point, in degrees.
     * @param lon1 The longitude of the first point, in degrees.
     * @param lat2 The latitude of the second point, in degrees.
     * @param lon2 The longitude of the second point, in degrees.
     * @returns The distance along the rhumb line connecting the two points, in great-arc radians.
     */
    static distanceRhumb(lat1: number, lon1: number, lat2: number, lon2: number): number;
    /**
     * Calculates the distance along the rhumb line connecting this point with another point.
     * @param point1 The first point.
     * @param point2 The second point.
     * @returns The distance along the rhumb line connecting the two points, in great-arc radians.
     */
    static distanceRhumb(point1: LatLonInterface, point2: LatLonInterface): number;
    /**
     * Calculates the distance along the rhumb line connecting this point with another point.
     * @param point1 The first point, in cartesian form.
     * @param point2 The second point, in cartesian form.
     * @returns The distance along the rhumb line connecting the two points, in great-arc radians.
     */
    static distanceRhumb(point1: ReadonlyFloat64Array, point2: ReadonlyFloat64Array): number;
    /**
     * Calculates the initial true bearing (forward azimuth) from one point to another along the great circle connecting
     * the two.
     * @param lat1 The latitude of the initial point, in degrees.
     * @param lon1 The longitude of the initial point, in degrees.
     * @param lat2 The latitude of the final point, in degrees.
     * @param lon2 The longitude of the final point, in degrees.
     * @returns The initial true bearing, in degrees, from the initial point to the final point along the great circle
     * connecting the two.
     */
    static initialBearing(lat1: number, lon1: number, lat2: number, lon2: number): number;
    /**
     * Calculates the final true bearing from one point to another along the great circle connecting the two.
     * @param lat1 The latitude of the initial point, in degrees.
     * @param lon1 The longitude of the initial point, in degrees.
     * @param lat2 The latitude of the final point, in degrees.
     * @param lon2 The longitude of the final point, in degrees.
     * @returns The final true bearing, in degrees, from the initial point to the final point along the great circle
     * connecting the two.
     */
    static finalBearing(lat1: number, lon1: number, lat2: number, lon2: number): number;
    /**
     * Calculates the constant true bearing from one point to another along the rhumb line connecting the two.
     * @param lat1 The latitude of the initial point, in degrees.
     * @param lon1 The longitude of the initial point, in degrees.
     * @param lat2 The latitude of the final point, in degrees.
     * @param lon2 The longitude of the final point, in degrees.
     * @returns The constant true bearing, in degrees, from the initial point to the final point along the rhumb line
     * connecting the two.
     */
    static bearingRhumb(lat1: number, lon1: number, lat2: number, lon2: number): number;
    /**
     * Converts an angle, in degrees, to an equivalent value in the range [-180, 180).
     * @param angle An angle in degrees.
     * @returns The angle's equivalent in the range [-180, 180).
     */
    private static toPlusMinus180;
    /**
     * Calculates the difference in isometric latitude from a pair of geodetic (geocentric) latitudes.
     * @param latRad1 Geodetic latitude 1, in radians.
     * @param latRad2 Geodetic latitude 2, in radians.
     * @returns The difference in isometric latitude from latitude 1 to latitude 2, in radians.
     */
    private static deltaPsi;
    /**
     * Calculates the rhumb correction factor between two latitudes.
     * @param deltaPsi The difference in isometric latitude beween the two latitudes.
     * @param latRad1 Geodetic latitude 1, in radians.
     * @param latRad2 Geodetic latitude 2, in radians.
     * @returns The rhumb correction factor between the two latitudes.
     */
    private static rhumbCorrection;
}

/**
 * A circle on Earth's surface, defined as the set of points on the Earth's surface equidistant (as measured
 * geodetically) from a central point.
 */
declare class GeoCircle {
    static readonly ANGULAR_TOLERANCE = 1e-7;
    private static readonly NORTH_POLE;
    private static readonly tempGeoPoint;
    private static readonly vec3Cache;
    private static readonly intersectionCache;
    private _center;
    private _radius;
    private _sinRadius;
    /**
     * Constructor.
     * @param center The center of the new small circle, represented as a position vector in the standard geographic
     * cartesian reference system.
     * @param radius The radius of the new small circle in great-arc radians.
     */
    constructor(center: ReadonlyFloat64Array, radius: number);
    /**
     * The center of this circle.
     */
    get center(): ReadonlyFloat64Array;
    /**
     * The radius of this circle, in great-arc radians.
     */
    get radius(): number;
    /**
     * Checks whether this circle is a great circle, or equivalently, whether its radius is equal to pi / 2 great-arc
     * radians.
     * @returns Whether this circle is a great circle.
     */
    isGreatCircle(): boolean;
    /**
     * Calculates the length of an arc along this circle subtended by a central angle.
     * @param angle A central angle, in radians.
     * @returns The length of the arc subtended by the angle, in great-arc radians.
     */
    arcLength(angle: number): number;
    /**
     * Calculates the central angle which subtends an arc along this circle of given length.
     * @param length An arc length, in great-arc radians.
     * @returns The central angle which subtends an arc along this circle of the given length, in radians.
     */
    angularWidth(length: number): number;
    /**
     * Sets the center and radius of this circle.
     * @param center The new center.
     * @param radius The new radius in great-arc radians.
     * @returns this circle, after it has been changed.
     */
    set(center: ReadonlyFloat64Array | LatLonInterface, radius: number): this;
    /**
     * Sets this circle to be a great circle which contains two given points. There are two possible great circles that
     * contain any two unique points; these circles differ only by their directionality (equivalently, the sign of their
     * normal vectors). The order of points passed to this method and the right-hand rule determines which of the two is
     * returned.
     * @param point1 The first point that lies on the great circle.
     * @param point2 The second point that lies on the great circle.
     * @returns this circle, after it has been changed.
     */
    setAsGreatCircle(point1: ReadonlyFloat64Array | LatLonInterface, point2: ReadonlyFloat64Array | LatLonInterface): this;
    /**
     * Sets this circle to be a great circle defined by a point and bearing offset, equivalent to the path projected from
     * the point with the specified initial bearing (forward azimuth).
     * @param point A point that lies on the great circle.
     * @param bearing The initial bearing from the point.
     * @returns this circle, after it has been changed.
     */
    setAsGreatCircle(point: ReadonlyFloat64Array | LatLonInterface, bearing: number): this;
    /**
     * Reverses the direction of this circle. This sets the center of the circle to its antipode and the radius to its
     * complement with `Math.PI`.
     * @returns This circle, after it has been reversed.
     */
    reverse(): this;
    /**
     * Gets the distance from a point to the center of this circle, in great-arc radians.
     * @param point The point to which to measure the distance.
     * @returns the distance from the point to the center of this circle.
     */
    private distanceToCenter;
    /**
     * Finds the closest point on this circle to a specified point. In other words, projects the specified point onto
     * this circle. If the specified point is equidistant from all points on this circle (i.e. it is coincident with or
     * antipodal to this circle's center), NaN will be written to all fields of the result.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @param out A Float64Array object to which to write the result.
     * @returns The closest point on this circle to the specified point.
     */
    closest(point: ReadonlyFloat64Array | LatLonInterface, out: Float64Array): Float64Array;
    /**
     * Finds the closest point on this circle to a specified point. In other words, projects the specified point onto
     * this circle. If the specified point is equidistant from all points on this circle (i.e. it is coincident with or
     * antipodal to this circle's center), NaN will be written to all fields of the result.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @param out A GeoPoint object to which to write the result.
     * @returns The closest point on this circle to the specified point.
     */
    closest(point: ReadonlyFloat64Array | LatLonInterface, out: GeoPoint): GeoPoint;
    /**
     * Calculates and returns the great-circle distance from a specified point to the closest point that lies on this
     * circle. In other words, calculates the shortest distance from a point to this circle. The distance is signed, with
     * positive distances representing deviation away from the center of the circle, and negative distances representing
     * deviation toward the center of the circle.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @returns the great circle distance, in great-arc radians, from the point to the closest point on this circle.
     */
    distance(point: ReadonlyFloat64Array | LatLonInterface): number;
    /**
     * Checks whether a point lies on this circle.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @param tolerance The error tolerance, in great-arc radians, of this operation. Defaults to
     * `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns whether the point lies on this circle.
     */
    includes(point: ReadonlyFloat64Array | LatLonInterface, tolerance?: number): boolean;
    /**
     * Checks whether a point lies within the boundary defined by this circle. This is equivalent to checking whether
     * the distance of the point from the center of this circle is less than or equal to this circle's radius.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @param inclusive Whether points that lie on this circle should pass the check. True by default.
     * @param tolerance The error tolerance, in great-arc radians, of this operation. Defaults to
     * `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns whether the point lies within the boundary defined by this circle.
     */
    encircles(point: ReadonlyFloat64Array | LatLonInterface, inclusive?: boolean, tolerance?: number): boolean;
    /**
     * Gets the angular distance along an arc between two points that lie on this circle. The arc extends from the first
     * point to the second in a counterclockwise direction when viewed from above the center of the circle.
     * @param start A point on this circle which marks the beginning of an arc.
     * @param end A point on this circle which marks the end of an arc.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `end` lie on this circle.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @param equalityTolerance The angular tolerance for considering the start and end points to be equal, in radians.
     * If the absolute (direction-agnostic) angular distance between the start and end points is less than or equal to
     * this value, then the zero will be returned. Defaults to `0`.
     * @returns the angular width of the arc between the two points, in radians.
     * @throws Error if either point does not lie on this circle.
     */
    angleAlong(start: ReadonlyFloat64Array | LatLonInterface, end: ReadonlyFloat64Array | LatLonInterface, tolerance?: number, equalityTolerance?: number): number;
    /**
     * Gets the distance along an arc between two points that lie on this circle. The arc extends from the first point
     * to the second in a counterclockwise direction when viewed from above the center of the circle.
     * @param start A point on this circle which marks the beginning of an arc.
     * @param end A point on this circle which marks the end of an arc.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `end` lie on this circle.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @param equalityTolerance The tolerance for considering the start and end points to be equal, in great-arc radians.
     * If the absolute (direction-agnostic) along-arc distance between the start and end points is less than or equal to
     * this value, then the zero will be returned. Defaults to `0`.
     * @returns the length of the arc between the two points, in great-arc radians.
     * @throws Error if either point does not lie on this circle.
     */
    distanceAlong(start: ReadonlyFloat64Array | LatLonInterface, end: ReadonlyFloat64Array | LatLonInterface, tolerance?: number, equalityTolerance?: number): number;
    /**
     * Calculates the true bearing along this circle at a point on the circle.
     * @param point A point on this circle.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `point` lies on this circle. Defaults
     * to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns the bearing along this circle at the point.
     * @throws Error if the point does not lie on this circle.
     */
    bearingAt(point: ReadonlyFloat64Array | LatLonInterface, tolerance?: number): number;
    /**
     * Offsets a point on this circle by a specified distance. The direction of the offset for positive distances is
     * counterclockwise when viewed from above the center of this circle.
     * @param point The point to offset.
     * @param distance The distance by which to offset, in great-arc radians.
     * @param out A Float64Array object to which to write the result.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `point` lies on this circle. Defaults
     * to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns The offset point.
     * @throws Error if the point does not lie on this circle.
     */
    offsetDistanceAlong(point: ReadonlyFloat64Array | LatLonInterface, distance: number, out: Float64Array, tolerance?: number): Float64Array;
    /**
     * Offsets a point on this circle by a specified distance. The direction of the offset for positive distances is
     * counterclockwise when viewed from above the center of this circle.
     * @param point The point to offset.
     * @param distance The distance by which to offset, in great-arc radians.
     * @param out A GeoPoint object to which to write the result.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `point` lies on this circle. Defaults
     * to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns The offset point.
     * @throws Error if the point does not lie on this circle.
     */
    offsetDistanceAlong(point: ReadonlyFloat64Array | LatLonInterface, distance: number, out: GeoPoint, tolerance?: number): GeoPoint;
    /**
     * Offsets a point on this circle by a specified angular distance. The direction of the offset for positive distances
     * is counterclockwise when viewed from above the center of this circle.
     * @param point The point to offset.
     * @param angle The angular distance by which to offset, in radians.
     * @param out A Float64Array object to which to write the result.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `point` lies on this circle. Defaults
     * to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns The offset point.
     * @throws Error if the point does not lie on this circle.
     */
    offsetAngleAlong(point: ReadonlyFloat64Array | LatLonInterface, angle: number, out: Float64Array, tolerance?: number): Float64Array;
    /**
     * Offsets a point on this circle by a specified angular distance. The direction of the offset for positive distances
     * is counterclockwise when viewed from above the center of this circle.
     * @param point The point to offset.
     * @param angle The angular distance by which to offset, in radians.
     * @param out A GeoPoint object to which to write the result.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `point` lies on this circle. Defaults
     * to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns The offset point.
     * @throws Error if the point does not lie on this circle.
     */
    offsetAngleAlong(point: ReadonlyFloat64Array | LatLonInterface, angle: number, out: GeoPoint, tolerance?: number): GeoPoint;
    /**
     * Offsets a point on this circle by a specified angular distance. The direction of the offset for positive distances
     * is counterclockwise when viewed from above the center of this circle.
     * @param point The point to offset.
     * @param angle The angular distance by which to offset, in radians.
     * @param out A Float64Array or GeoPoint object to which to write the result.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `point` lies on this circle. Defaults
     * to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns The offset point.
     * @throws Error if the point does not lie on this circle.
     */
    private _offsetAngleAlong;
    /**
     * Calculates and returns the set of intersection points between this circle and another one, and writes the results
     * to an array of position vectors.
     * @param other The other circle to test for intersections.
     * @param out An array in which to store the results. The results will be stored at indexes 0 and 1. If these indexes
     * are empty, then new Float64Array objects will be created and inserted into the array.
     * @returns The number of solutions written to the out array. Either 0, 1, or 2.
     */
    intersection(other: GeoCircle, out: Float64Array[]): number;
    /**
     * Calculates and returns the set of intersection points between this circle and another one, and writes the results
     * to an array of GeoPoint objects.
     * @param other The other circle to test for intersections.
     * @param out An array in which to store the results. The results will be stored at indexes 0 and 1. If these indexes
     * are empty, then new GeoPoint objects will be created and inserted into the array.
     * @returns The number of solutions written to the out array. Either 0, 1, or 2.
     */
    intersectionGeoPoint(other: GeoCircle, out: GeoPoint[]): number;
    /**
     * Calculates and returns the number of intersection points between this circle and another one. Returns NaN if there
     * are an infinite number of intersection points.
     * @param other The other circle to test for intersections.
     * @param tolerance The error tolerance, in great-arc radians, of this operation. Defaults to
     * `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns the number of intersection points between this circle and the other one.
     */
    numIntersectionPoints(other: GeoCircle, tolerance?: number): number;
    /**
     * Creates a new small circle from a lat/long coordinate pair and radius.
     * @param point The center of the new small circle.
     * @param radius The radius of the new small circle, in great-arc radians.
     * @returns a small circle.
     */
    static createFromPoint(point: LatLonInterface, radius: number): GeoCircle;
    /**
     * Creates a new great circle that contains two points. There are two possible great circles that contain any two
     * unique points; these circles differ only by their directionality (equivalently, the sign of their normal vectors).
     * The order of points passed to this method and the right-hand rule determines which of the two is returned.
     * @param point1 The first point that lies on the new great circle.
     * @param point2 The second point that lies on the new great circle.
     * @returns a great circle.
     */
    static createGreatCircle(point1: ReadonlyFloat64Array | LatLonInterface, point2: ReadonlyFloat64Array | LatLonInterface): GeoCircle;
    static createGreatCircle(point: ReadonlyFloat64Array | LatLonInterface, bearing: number): GeoCircle;
    /**
     * Creates a new great circle defined by one point and a bearing offset. The new great circle will be equivalent to
     * the path projected from the point with the specified initial bearing (forward azimuth).
     * @param point A point that lies on the new great circle.
     * @param bearing The initial bearing from the point.
     * @returns a great circle.
     */
    static createGreatCircleFromPointBearing(point: ReadonlyFloat64Array | LatLonInterface, bearing: number): GeoCircle;
    /**
     * Calculates a normal vector for a great circle given two points which lie on the circle. The order of points passed
     * to this method and the right-hand rule determines which of the two possible normal vectors for the great circle is
     * returned.
     * @param point1 The first point that lies on the great circle.
     * @param point2 The second point that lies on the great circle.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    static getGreatCircleNormal(point1: ReadonlyFloat64Array | LatLonInterface, point2: ReadonlyFloat64Array | LatLonInterface, out: Float64Array): Float64Array;
    /**
     * Calculates a normal vector for a great circle given a point and initial bearing.
     * @param point A point that lies on the great circle.
     * @param bearing The initial bearing from the point.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    static getGreatCircleNormal(point: ReadonlyFloat64Array | LatLonInterface, bearing: number, out: Float64Array): Float64Array;
    /**
     * Calculates a normal vector for a great circle given two points which lie on the circle, or a point and initial bearing.
     * @param arg1 A point that lies on the great circle.
     * @param arg2 A second point that lies on the great circle, or an initial bearing from the first point.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    private static _getGreatCircleNormal;
    /**
     * Calculates a normal vector for a great circle given two points which lie on the cirlce.
     * @param point1 The first point that lies on the great circle.
     * @param point2 The second point that lies on the great circle.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    private static getGreatCircleNormalFromPoints;
    /**
     * Calculates a normal vector for a great circle given a point and initial bearing.
     * @param point A point that lies on the great circle.
     * @param bearing The initial bearing from the point.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    private static getGreatCircleNormalFromPointBearing;
}

/**
 * A Subject which provides a {@link GeoPointInterface} value.
 */
declare class GeoPointSubject extends AbstractSubscribable<GeoPointInterface> implements MutableSubscribable<GeoPointInterface, LatLonInterface> {
    private readonly value;
    /** @inheritdoc */
    readonly isMutableSubscribable = true;
    /**
     * Constructor.
     * @param value The value of this subject.
     */
    private constructor();
    /**
     * Creates a GeoPointSubject.
     * @param initialVal The initial value.
     * @returns A GeoPointSubject.
     */
    static create(initialVal: GeoPoint): GeoPointSubject;
    /**
     * Creates a GeoPointSubject.
     * @param initialVal The initial value.
     * @returns A GeoPointSubject.
     * @deprecated Use `GeoPointSubject.create()` instead.
     */
    static createFromGeoPoint(initialVal: GeoPoint): GeoPointSubject;
    /** @inheritdoc */
    get(): GeoPointInterface;
    /**
     * Sets the new value and notifies the subscribers if the value changed.
     * @param value The new value.
     */
    set(value: LatLonInterface): void;
    /**
     * Sets the new value and notifies the subscribers if the value changed.
     * @param lat The latitude of the new value.
     * @param lon The longitude of the new value.
     */
    set(lat: number, lon: number): void;
}

/**
 * A geographic projection.
 */
interface GeoProjection {
    /**
     * Gets the geographic center of this projection.
     * @returns The geographic center of this projection.
     */
    getCenter(): GeoPointReadOnly;
    /**
     * Gets the nominal scale factor of this projection. At a scale factor of 1, a distance of one great-arc radian will
     * be projected to a distance of one pixel.
     * @returns The nominal scale factor of this projection.
     */
    getScaleFactor(): number;
    /**
     * Gets the pre-projection (spherical) rotation of this projection as a vector `[lambda, phi, gamma]`. The rotation
     * angles are expressed in radians. The full rotation is an intrinsic rotation with angles applied in the order
     * `lambda, phi, gamma`. The rotation uses the standard geographic cartesian coordinate system, a right-handed
     * coordinate system with the origin at the center of the earth, the positive x axis passing through 0 degrees N,
     * 0 degrees E, and the positive z axis passing through the North Pole.
     * * `lambda`: Intrinsic rotation angle about the z axis. Positive rotation is in the counterclockwise direction when
     * looking down from above the axis.
     * * `phi`: Intrinsic rotation angle about the y axis. Positive rotation is in the clockwise direction when looking
     * down from above the axis.
     * * `gamma`: Intrinsic rotation angle about the x axis. Positive rotation is in the counterclockwise direction when
     * looking down from above the axis.
     * @returns The pre-projection rotation of this projection.
     */
    getPreRotation(): ReadonlyFloat64Array;
    /**
     * Gets the post-projection (planar) translation of this projection, in pixels.
     * @returns The post-projection translation of this projection.
     */
    getTranslation(): ReadonlyFloat64Array;
    /**
     * Gets the post-projection (planar) rotation angle of this projection in radians.
     * @returns The post-projection rotation angle of this projection.
     */
    getPostRotation(): number;
    /**
     * Checks whether this projection reflects the projected coordinate system across the x-axis.
     * @returns Whether this projection reflects the projected coordinate system across the x-axis.
     */
    getReflectY(): boolean;
    /**
     * Projects a set of lat/lon coordinates.
     * @param point The point to project, as either a {@link LatLonInterface} or a `[lon, lat]` array.
     * @param out The vector to which to write the result.
     * @returns The projected point, as a vector.
     */
    project(point: LatLonInterface | ReadonlyFloat64Array, out: Float64Array): Float64Array;
    /**
     * Inverts a set of projected coordinates. This method will determine the geographic point whose projected location
     * is the equal to that described by a 2D position vector.
     * @param vec The 2D position vector describing the location of the projected coordinates.
     * @param out The point to which to write the result.
     * @returns the inverted point.
     */
    invert<T extends GeoPoint | Float64Array>(vec: ReadonlyFloat64Array, out: T): T;
}
/**
 * A mutable geographic projection.
 */
interface MutableGeoProjection extends GeoProjection {
    /**
     * Sets the geographic center of this projection. The center point of the projection is projected to the origin,
     * before any post-projection transformations are applied.
     * @param point The new center point.
     * @returns This projection, after it has been changed.
     */
    setCenter(point: LatLonInterface): this;
    /**
     * Sets the nominal scale factor of this projection. At a scale factor of 1, a distance of one great-arc radian will
     * be projected to a distance of one pixel.
     * @param factor The new nominal scale factor.
     * @returns This projection, after it has been changed.
     */
    setScaleFactor(factor: number): this;
    /**
     * Sets the pre-projection (spherical) rotation of this projection as a vector `[lambda, phi, gamma]`. The full
     * rotation is an intrinsic rotation with angles applied in the order `lambda, phi, gamma`. The rotation uses the
     * standard geographic cartesian coordinate system, a right-handed coordinate system with the origin at the center of
     * the earth, the positive x axis passing through 0 degrees N, 0 degrees E, and the z axis passing through the North
     * Pole.
     * * `lambda`: Intrinsic rotation angle about the z axis. Positive rotation is in the counterclockwise direction when
     * looking down from above the axis.
     * * `phi`: Intrinsic rotation angle about the y axis. Positive rotation is in the clockwise direction when looking
     * down from above the axis.
     * * `gamma`: Intrinsic rotation angle about the x axis. Positive rotation is in the counterclockwise direction when
     * looking down from above the axis.
     * @param vec The pre-projection rotation, as a vector `[lambda, phi, gamma]`. The rotation angles should be
     * expressed in radians.
     * @returns This projection, after it has been changed.
     */
    setPreRotation(vec: ReadonlyFloat64Array): this;
    /**
     * Sets the post-projection (planar) translation of this projection.
     * @param vec The new post-projection translation, in pixels.
     * @returns This projection, after it has been changed.
     */
    setTranslation(vec: ReadonlyFloat64Array): this;
    /**
     * Sets the post-projection (planar) rotation of this projection.
     * @param rotation The new post-projection rotation angle, in radians.
     * @returns This projection, after it has been changed.
     */
    setPostRotation(rotation: number): this;
    /**
     * Sets whether this reflection should reflect the projected coordinate system across the x-axis. Setting this value
     * to true is useful in the situation where the projected coordinate system should use a positive-y-axis-down
     * convention.
     * @param val True if reflection is desired, false otherwise.
     * @returns This projection, after it has been changed.
     */
    setReflectY(val: boolean): this;
    /**
     * Copies all projection parameters from another projection. The parameters copied are: center, pre-projection
     * rotation angles, scale factor, post-projection translation, post-projection rotation angle, and reflectY.
     * @param other The projection from which to copy parameters.
     * @returns This projection, after it has been changed.
     */
    copyParametersFrom(other: GeoProjection): this;
}
/**
 * A partial implementation of a MutableGeoProjection. Subclasses should use the projectRaw() and invertRaw() methods
 * to define the type of projection to be implemented.
 */
declare abstract class AbstractGeoProjection implements MutableGeoProjection {
    private static readonly vec2Cache;
    private static readonly vec3Cache;
    private static readonly geoPointCache;
    protected readonly center: GeoPoint;
    protected readonly centerTranslation: Float64Array;
    protected scaleFactor: number;
    protected readonly preRotation: Float64Array;
    protected readonly translation: Float64Array;
    protected postRotation: number;
    protected rotationSin: number;
    protected rotationCos: number;
    protected reflectY: number;
    protected readonly preRotationForwardTransform: Transform3D;
    protected readonly preRotationReverseTransform: Transform3D;
    private readonly rotationCache;
    /** @inheritdoc */
    getCenter(): GeoPointReadOnly;
    /** @inheritdoc */
    getScaleFactor(): number;
    /** @inheritdoc */
    getPreRotation(): ReadonlyFloat64Array;
    /** @inheritdoc */
    getTranslation(): ReadonlyFloat64Array;
    /** @inheritdoc */
    getPostRotation(): number;
    /** @inheritdoc */
    getReflectY(): boolean;
    /** @inheritdoc */
    setCenter(point: LatLonInterface): this;
    /** @inheritdoc */
    setScaleFactor(factor: number): this;
    /** @inheritdoc */
    setPreRotation(vec: ReadonlyFloat64Array): this;
    /** @inheritdoc */
    setTranslation(vec: ReadonlyFloat64Array): this;
    /** @inheritdoc */
    setPostRotation(rotation: number): this;
    /** @inheritdoc */
    setReflectY(val: boolean): this;
    /** @inheritdoc */
    copyParametersFrom(other: GeoProjection): this;
    /**
     * Updates the pre-rotation transformation matrices.
     */
    protected updatePreRotationTransforms(): void;
    /**
     * Updates the translation vector to move the center of this projection to the origin.
     */
    protected updateCenterTranslation(): void;
    /**
     * Applies a raw projection.
     * @param vec - a [lon, lat] vector describing the geographic point to project.
     * @param out - a 2D vector to which to write the result.
     * @returns the projected point.
     */
    protected abstract projectRaw(vec: ReadonlyFloat64Array, out: Float64Array): Float64Array;
    /**
     * Inverts a raw projection.
     * @param vec - a 2D vector describing the projected point to invert.
     * @param out - a 2D vector to which to write the result.
     * @returns the inverted point.
     */
    protected abstract invertRaw(vec: ReadonlyFloat64Array, out: Float64Array): Float64Array;
    /**
     * Applies a forward rotation to a set of lat/lon coordinates using this projection's pre-projection rotation angles.
     * @param vec - the lat/lon coordinates to rotate, as a vector ([long, lat]).
     * @param out - the vector to which to write the result.
     * @returns the rotated lat/lon coordinates.
     */
    protected preRotateForward(vec: ReadonlyFloat64Array, out: Float64Array): Float64Array;
    /**
     * Applies a reverse rotation to a set of lat/lon coordinates using this projection's pre-projection rotation angles.
     * @param vec - the lat/lon coordinates to rotate, as a vector ([long, lat]).
     * @param out - the vector to which to write the result.
     * @returns the rotated lat/lon coordinates.
     */
    protected preRotateReverse(vec: ReadonlyFloat64Array, out: Float64Array): Float64Array;
    /** @inheritdoc */
    project(point: LatLonInterface | ReadonlyFloat64Array, out: Float64Array): Float64Array;
    /** @inheritdoc */
    invert<T extends GeoPoint | Float64Array>(vec: ReadonlyFloat64Array, out: T): T;
}
/**
 * A Mercator projection.
 */
declare class MercatorProjection extends AbstractGeoProjection {
    /**
     * Applies a raw projection.
     * @param vec - a [lon, lat] vector describing the geographic point to project.
     * @param out - a 2D vector to which to write the result.
     * @returns the projected point.
     */
    protected projectRaw(vec: ReadonlyFloat64Array, out: Float64Array): Float64Array;
    /**
     * Inverts a raw projection.
     * @param vec - a 2D vector describing the projected point to invert.
     * @param out - a 2D vector to which to write the result.
     * @returns the inverted point.
     */
    protected invertRaw(vec: ReadonlyFloat64Array, out: Float64Array): Float64Array;
}
/**
 * An orthographic projection.
 */
declare class OrthographicProjection extends AbstractGeoProjection {
    /**
     * Applies a raw projection.
     * @param vec - a [lon, lat] vector describing the geographic point to project.
     * @param out - a 2D vector to which to write the result.
     * @returns the projected point.
     */
    protected projectRaw(vec: ReadonlyFloat64Array, out: Float64Array): Float64Array;
    /**
     * Inverts a raw projection.
     * @param vec - a 2D vector describing the projected point to invert.
     * @param out - a 2D vector to which to write the result.
     * @returns the inverted point.
     */
    protected invertRaw(vec: ReadonlyFloat64Array, out: Float64Array): Float64Array;
}

/**
 * A function which handles resampled points.
 */
declare type GeodesicResamplerHandler = (point: GeoPointInterface, projected: Float64Array, index: number) => void;
/**
 * Resamples projected geodesic (great-circle) paths between defined endpoints into series of straight line segments.
 */
declare class GeodesicResampler {
    readonly minDistance: number;
    readonly dpTolerance: number;
    readonly maxDepth: number;
    private readonly cosMinDistance;
    private readonly dpTolSq;
    private geoPointCache;
    private vec2Cache;
    private vec3Cache;
    /**
     * Constructor.
     * @param minDistance The minimum geodesic distance this resampler enforces between two adjacent resampled points, in
     * great-arc radians.
     * @param dpTolerance The Douglas-Peucker tolerance this resampler uses when deciding whether to discard a resampled
     * point during the line simplification process.
     * @param maxDepth The maximum depth of the resampling algorithm used by this resampler. The number of resampled
     * points is bounded from above by 2^[maxDepth] - 1.
     */
    constructor(minDistance: number, dpTolerance: number, maxDepth: number);
    /**
     * Resamples a projected geodesic (great-circle) path.
     * @param projection The projection to use.
     * @param start The start of the path.
     * @param end The end of the path.
     * @param handler A function to handle the resampled points. The function is called once for each resampled point,
     * in order.
     * @throws Error when the start and end of the path are antipodal.
     */
    resample(projection: GeoProjection, start: LatLonInterface, end: LatLonInterface, handler: GeodesicResamplerHandler): void;
    /**
     * Resamples a projected geodesic (great-circle) path. This method will recursively split the path into two halves
     * and resample the midpoint. Recursion continues as long as the maximum depth has not been reached and at least one
     * of the following conditions is met:
     * * The distance from the midpoint to the endpoints is greater than or equal to the minimum resampling distance.
     * * The Douglas-Peucker metric of the projected midpoint is greater than or equal to the set tolerance.
     * @param projection The projection to use.
     * @param lat1 The latitude of the start of the path.
     * @param lon1 The longitude of the start of the path.
     * @param x1 The x-component of the Cartesian position vector of the start of the path.
     * @param y1 The y-component of the Cartesian position vector of the start of the path.
     * @param z1 The z-component of the Cartesian position vector of the start of the path.
     * @param projX1 The x-component of the projected location of the start of the path.
     * @param projY1 The y-component of the projected location of the start of the path.
     * @param lat2 The latitude of the end of the path.
     * @param lon2 The longitude of the end of the path.
     * @param x2 The x-component of the Cartesian position vector of the end of the path.
     * @param y2 The y-component of the Cartesian position vector of the end of the path.
     * @param z2 The z-component of the Cartesian position vector of the end of the path.
     * @param projX2 The x-component of the projected location of the end of the path.
     * @param projY2 The y-component of the projected location of the end of the path.
     * @param handler A function to handle the resampled points.
     * @param depth The current depth of the resampling algorithm.
     * @param index The index of the next resampled point.
     * @returns The index of the next resampled point.
     * @throws Error when the start and end of the path are antipodal.
     */
    private resampleHelper;
}

/**
 * A function which handles resampled points.
 * @param vector A vector which describes the projected path terminating at the resampled point.
 */
declare type GeoCircleResamplerHandler = (vector: Readonly<GeoCircleResamplerVector>) => void;
/**
 * A vector describing the projected path terminating at a point resampled by {@link GeoCircleResampler}.
 */
declare type GeoCircleResamplerVector = GeoCircleResamplerStartVector | GeoCircleResamplerLineVector | GeoCircleResamplerArcVector;
/** Base vector class. */
declare type GeoCircleResamplerBaseVector = {
    /** The type of this vector. */
    type: string;
    /** The resampled point that terminates this vector. */
    point: GeoPointInterface;
    /** The projected position, in pixel coordinates, of the resampled point that terminates this vector. */
    projected: ReadonlyFloat64Array;
    /** The index of the resampled point that terminates this vector. `0` is the first point, `1` is the second, and so on. */
    index: number;
};
/**
 * A vector describing the starting point of a path resampled by {@link GeoCircleResampler}.
 */
declare type GeoCircleResamplerStartVector = GeoCircleResamplerBaseVector & {
    /** The type of this vector. */
    type: 'start';
};
/**
 * A vector describing a projected straight line terminating at a point resampled by {@link GeoCircleResampler}.
 */
declare type GeoCircleResamplerLineVector = GeoCircleResamplerBaseVector & {
    /** The type of this vector. */
    type: 'line';
};
/**
 * A vector describing a projected circular arc terminating at a point resampled by {@link GeoCircleResampler}.
 */
declare type GeoCircleResamplerArcVector = GeoCircleResamplerBaseVector & {
    /** The type of this vector. */
    type: 'arc';
    /** The center of the projected arc, in pixel coordinates. */
    projectedArcCenter: ReadonlyFloat64Array;
    /** The radius of the projected arc, in pixels. */
    projectedArcRadius: number;
    /** The radial of the start of the projected arc, in radians. */
    projectedArcStartAngle: number;
    /** The radial of the end of the projected arc, in radians. */
    projectedArcEndAngle: number;
};
/**
 * Resamples projected great- and small-circle paths between defined endpoints into series of straight line segments and circular arcs.
 */
declare class GeoCircleResampler {
    readonly minDistance: number;
    readonly dpTolerance: number;
    readonly maxDepth: number;
    private readonly cosMinDistance;
    private readonly dpTolSq;
    private readonly geoPointCache;
    private readonly vec2Cache;
    private readonly vec3Cache;
    private readonly startVector;
    private readonly lineVector;
    private readonly arcVector;
    private readonly state;
    /**
     * Constructor.
     * @param minDistance The minimum great-circle distance this resampler enforces between two adjacent resampled
     * points, in great-arc radians.
     * @param dpTolerance The Douglas-Peucker tolerance, in pixels, this resampler uses when deciding whether to discard
     * a resampled point during the simplification process.
     * @param maxDepth The maximum depth of the resampling algorithm used by this resampler. The number of resampled
     * points is bounded from above by `2^[maxDepth] - 1`.
     */
    constructor(minDistance: number, dpTolerance: number, maxDepth: number);
    /**
     * Resamples a projected great- or small-circle path.
     * @param projection The projection to use.
     * @param circle The geo circle along which the path lies.
     * @param start The start of the path.
     * @param end The end of the path.
     * @param handler A function to handle the resampled points. The function is called once for each resampled point,
     * in order.
     */
    resample(projection: GeoProjection, circle: GeoCircle, start: LatLonInterface | ReadonlyFloat64Array, end: LatLonInterface | ReadonlyFloat64Array, handler: GeoCircleResamplerHandler): void;
    /**
     * Resamples a projected great- or small-circle path. This method will recursively split the path into two halves
     * and resample the midpoint. Based on the projected position of the midpoint relative to those of the start and end
     * points, the projected path is modeled as either a straight line from the start to the end or a circular arc
     * connecting the start, end, and midpoints. Recursion continues as long as the maximum depth has not been reached
     * and at least one of the following conditions is met:
     * * The distance from the midpoint to the endpoints is greater than or equal to the minimum resampling distance.
     * * If the path is modeled as a line: the distance from the projected midpoint to the model line is greater than
     * this resampler's Douglas-Peucker tolerance.
     * * If the path is modeled as an arc: the distance from the projected one-quarter or the three-quarter point along
     * the path to the model arc is greater than this resampler's Douglas-Peucker tolerance.
     * @param projection The projection to use.
     * @param circle The geo circle along which the path lies.
     * @param lat1 The latitude of the start of the path, in degrees.
     * @param lon1 The longitude of the start of the path, in degrees.
     * @param x1 The x-component of the Cartesian position vector of the start of the path.
     * @param y1 The y-component of the Cartesian position vector of the start of the path.
     * @param z1 The z-component of the Cartesian position vector of the start of the path.
     * @param projX1 The x-component of the projected location of the start of the path, in pixels.
     * @param projY1 The y-component of the projected location of the start of the path, in pixels.
     * @param lat2 The latitude of the end of the path, in degrees.
     * @param lon2 The longitude of the end of the path, in degrees.
     * @param x2 The x-component of the Cartesian position vector of the end of the path.
     * @param y2 The y-component of the Cartesian position vector of the end of the path.
     * @param z2 The z-component of the Cartesian position vector of the end of the path.
     * @param projX2 The x-component of the projected location of the end of the path, in pixels.
     * @param projY2 The y-component of the projected location of the end of the path, in pixels.
     * @param handler A function to handle the resampled points.
     * @param depth The current depth of the resampling algorithm.
     * @param state The current state of the resampling algorithm.
     * @returns The index of the next resampled point.
     */
    private resampleHelper;
    /**
     * Calls a handler function for a resampled point.
     * @param handler The handler function to call.
     * @param lat The latitude of the resampled point, in degrees.
     * @param lon The longitude of the resampled point, in degrees.
     * @param projX The x-coordinate of the projected resampled point, in pixels.
     * @param projY The y-coordinate of the projected resampled point, in pixels.
     * @param state The current state of the resampling algorithm.
     */
    private callHandler;
}

/**
 * Navigational mathematics functions.
 */
declare class NavMath {
    private static readonly vec3Cache;
    private static readonly geoPointCache;
    private static readonly geoCircleCache;
    /**
     * Clamps a value to a min and max.
     * @param val The value to clamp.
     * @param min The minimum value to clamp to.
     * @param max The maximum value to clamp to.
     * @returns The clamped value.
     */
    static clamp(val: number, min: number, max: number): number;
    /**
     * Normalizes a heading to a 0-360 range.
     * @param heading The heading to normalize.
     * @returns The normalized heading.
     */
    static normalizeHeading(heading: number): number;
    /**
     * Gets the turn radius for a given true airspeed.
     * @param airspeedTrue The true airspeed of the plane.
     * @param bankAngle The bank angle of the plane, in degrees.
     * @returns The airplane turn radius.
     */
    static turnRadius(airspeedTrue: number, bankAngle: number): number;
    /**
     * Gets the required bank angle for a given true airspeed and turn radius.
     * @param airspeedTrue The true airspeed of the plane.
     * @param radius The airplane turn radius.
     * @returns The required bank angle, in degrees.
     */
    static bankAngle(airspeedTrue: number, radius: number): number;
    /**
     * Get the turn direction for a given course change.
     * @param startCourse The start course.
     * @param endCourse The end course.
     * @returns The turn direction for the course change.
     */
    static getTurnDirection(startCourse: number, endCourse: number): 'left' | 'right';
    /**
     * Converts polar radians to degrees north.
     * @param radians The radians to convert.
     * @returns The angle, in degrees north.
     */
    static polarToDegreesNorth(radians: number): number;
    /**
     * Converts degrees north to polar radians.
     * @param degrees The degrees to convert.
     * @returns The angle radians, in polar.
     */
    static degreesNorthToPolar(degrees: number): number;
    /**
     * Calculates the distance along an arc on Earth's surface. The arc begins at the intersection of the great circle
     * passing through the center of a circle of radius `radius` meters in the direction of 'startBearing', and ends at
     * the intersection of the great circle passing through the center of the circle in the direction of 'endBearing',
     * proceeding clockwise (as viewed from above).
     * @param startBearing The degrees of the start of the arc.
     * @param endBearing The degrees of the end of the arc.
     * @param radius The radius of the arc, in meters.
     * @returns The arc distance.
     */
    static calculateArcDistance(startBearing: number, endBearing: number, radius: number): number;
    /**
     * Calculates the intersection of a line and a circle.
     * @param x1 The start x of the line.
     * @param y1 The start y of the line.
     * @param x2 The end x of the line.
     * @param y2 The end y of the line.
     * @param cx The circle center x.
     * @param cy The circle center y.
     * @param r The radius of the circle.
     * @param sRef The reference to the solution object to write the solution to.
     * @returns The number of solutions (0, 1 or 2).
     */
    static circleIntersection(x1: number, y1: number, x2: number, y2: number, cx: number, cy: number, r: number, sRef: CircleIntersection): 0 | 1 | 2;
    /**
     * Gets the degrees north that a point lies on a circle.
     * @param cx The x point of the center of the circle.
     * @param cy The y point of the center of the circle.
     * @param x The x point to get the bearing for.
     * @param y The y point to get the bearing for.
     * @returns The angle in degrees north that the point is relative to the center.
     */
    static northAngle(cx: number, cy: number, x: number, y: number): number;
    /**
     * Checks if a degrees north bearing is between two other degrees north bearings.
     * @param bearing The bearing in degrees north to check.
     * @param start The start bearing in degrees north.
     * @param end The end bearing, in degrees north.
     * @returns True if the bearing is between the two provided bearings, false otherwise.
     */
    static bearingIsBetween(bearing: number, start: number, end: number): boolean;
    /**
     * Converts a degrees north heading to a degrees north turn circle angle.
     * @param heading The heading to convert.
     * @param turnDirection The direction of the turn.
     * @returns A degrees north turn circle angle.
     */
    static headingToAngle(heading: number, turnDirection: 'left' | 'right'): number;
    /**
     * Converts a degrees north turn circle angle to a degrees north heading.
     * @param angle The turn circle angle to convert.
     * @param turnDirection The direction of the turn.
     * @returns A degrees north heading.
     */
    static angleToHeading(angle: number, turnDirection: 'left' | 'right'): number;
    /**
     * Calculates the wind correction angle.
     * @param course The current plane true course.
     * @param airspeedTrue The current plane true airspeed.
     * @param windDirection The direction of the wind, in degrees true.
     * @param windSpeed The current speed of the wind.
     * @returns The calculated wind correction angle.
     */
    static windCorrectionAngle(course: number, airspeedTrue: number, windDirection: number, windSpeed: number): number;
    /**
     * Calculates the cross track deviation from the provided leg fixes.
     * @param start The location of the starting fix of the leg.
     * @param end The location of the ending fix of the leg.
     * @param pos The current plane location coordinates.
     * @returns The amount of cross track deviation, in nautical miles.
     */
    static crossTrack(start: LatLonInterface, end: LatLonInterface, pos: LatLonInterface): number;
    /**
     * Calculates the along-track distance from a starting point to another point along a great-circle track running
     * through the starting point.
     * @param start The start of the great-circle track.
     * @param end The end of the great-circle track.
     * @param pos The point for which to calculate the along-track distance.
     * @returns The along-track distance, in nautical miles.
     */
    static alongTrack(start: LatLonInterface, end: LatLonInterface, pos: LatLonInterface): number;
    /**
     * Calculates the desired track from the provided leg fixes.
     * @param start The location of the starting fix of the leg.
     * @param end The location of the ending fix of the leg.
     * @param pos The current plane location coordinates.
     * @returns The desired track, in degrees true.
     */
    static desiredTrack(start: LatLonInterface, end: LatLonInterface, pos: LatLonInterface): number;
    /**
     * Gets the desired track for a given arc.
     * @param center The center of the arc.
     * @param turnDirection The direction of the turn.
     * @param pos The current plane position.
     * @returns The desired track.
     */
    static desiredTrackArc(center: LatLonInterface, turnDirection: 'left' | 'right', pos: LatLonInterface): number;
    /**
     * Gets the percentage along the arc path that the plane currently is.
     * @param start The start of the arc, in degrees north.
     * @param end The end of the arc, in degrees north.
     * @param center The center location of the arc.
     * @param turnDirection The direction of the turn.
     * @param pos The current plane position.
     * @returns The percentage along the arc the plane is.
     */
    static percentAlongTrackArc(start: number, end: number, center: LatLonInterface, turnDirection: 'left' | 'right', pos: LatLonInterface): number;
    /**
     * Gets a position given an arc and a distance from the arc start.
     * @param start The start bearing of the arc.
     * @param center The center of the arc.
     * @param radius The radius of the arc.
     * @param turnDirection The turn direction for the arc.
     * @param distance The distance along the arc to get the position for.
     * @param out The position to write to.
     * @returns The position along the arc that was written to.
     */
    static positionAlongArc(start: number, center: GeoPoint, radius: number, turnDirection: 'left' | 'right', distance: number, out: GeoPoint): GeoPoint;
    /**
     * Gets the cross track distance for a given arc.
     * @param center The center of the arc.
     * @param radius The radius of the arc, in meters.
     * @param pos The current plane position.
     * @returns The cross track distance, in NM.
     */
    static crossTrackArc(center: LatLonInterface, radius: number, pos: LatLonInterface): number;
    /**
     * Gets the total difference in degrees between two angles.
     * @param a The first angle.
     * @param b The second angle.
     * @returns The difference between the two angles, in degrees.
     */
    static diffAngle(a: number, b: number): number;
    /**
     * Finds side a given sides b, c, and angles beta, gamma.
     * @param b The length of side b, as a trigonometric ratio.
     * @param c The length of side c, as a trigonometric ratio.
     * @param beta The angle, in radians, of the opposite of side b.
     * @param gamma The angle, in radians, of the opposite of side c
     * @returns The length of side a, as a trigonometric ratio.
     */
    static napierSide(b: number, c: number, beta: number, gamma: number): number;
    /**
     * Calculates a normal vector to a provided course in degrees north.
     * @param course The course in degrees north.
     * @param turnDirection The direction of the turn to orient the normal.
     * @param outVector The normal vector for the provided course.
     */
    static normal(course: number, turnDirection: 'left' | 'right', outVector: Float64Array): void;
}
/**
 * A circle intersection solution.
 */
interface CircleIntersection {
    /** The x coordinate of the first solution point. */
    x1: number;
    /** The y coordinate of the first solution point. */
    y1: number;
    /** The x coordinate of the second solution point. */
    x2: number;
    /** The y coordinate of the second solution point. */
    y2: number;
}
/**
 * A representation of a vector.
 */
interface Vector {
    /** The x component of the vector. */
    x: number;
    /** The y component of the vector. */
    y: number;
}

/**
 * The possible reference norths for navigation angle units.
 */
declare enum NavAngleUnitReferenceNorth {
    True = "true",
    Magnetic = "magnetic"
}
/**
 * A navigation angle unit, which is a measure of angular degrees relative to either true or magnetic north.
 *
 * Unlike most other unit types, each instance of navigation angle unit contains state specific to that instance,
 * namely the location used to retrieve magnetic variation for conversions. Therefore, it is generally recommended
 * not to re-use the same NavAngleUnit instance to instantiate multiple NumberUnits.
 *
 * Conversions use the location of the NavAngleUnit instance whose conversion method is called; this also means that
 * when using `NumberUnit.asUnit()`, the location of the unit of the NumberUnit whose `asUnit()` method was called
 * will be used.
 */
declare class NavAngleUnit extends AbstractUnit<typeof NavAngleUnit.FAMILY> {
    static readonly FAMILY = "navangle";
    /** @inheritdoc */
    readonly family = "navangle";
    /** This location used to retrieve magnetic variation for conversions related to this unit. */
    readonly location: GeoPoint;
    constructor(type: NavAngleUnitReferenceNorth, location: LatLonInterface);
    constructor(type: NavAngleUnitReferenceNorth, lat: number, lon: number);
    /**
     * Checks whether this nav angle unit is relative to magnetic north.
     * @returns Whether this nav angle unit is relative to magnetic north.
     */
    isMagnetic(): boolean;
    /**
     * Converts a value of this unit to another unit. This unit's location is used for the conversion.
     * @param value The value to convert.
     * @param toUnit The unit to which to convert.
     * @returns The converted value.
     * @throws Error if attempting an invalid conversion.
     */
    convertTo(value: number, toUnit: Unit<typeof NavAngleUnit.FAMILY>): number;
    /**
     * Converts a value of another unit to this unit. This unit's location is used for the conversion.
     * @param value The value to convert.
     * @param fromUnit The unit from which to convert.
     * @returns The converted value.
     * @throws Error if attempting an invalid conversion.
     */
    convertFrom(value: number, fromUnit: Unit<typeof NavAngleUnit.FAMILY>): number;
    /** @inheritdoc */
    equals(other: Unit<string>): boolean;
    /**
     * Creates an instance of NavAngleUnit. The location of the unit is initialized to {0 N, 0 E}.
     * @param isMagnetic Whether the new unit is relative to magnetic north.
     * @returns An instance of NavAngleUnit.
     */
    static create(isMagnetic: boolean): NavAngleUnit;
}
/**
 * A Subject which provides a navigation angle value.
 */
declare class NavAngleSubject extends AbstractSubscribable<NumberUnitInterface<typeof NavAngleUnit.FAMILY, NavAngleUnit>> implements MutableSubscribable<NumberUnitInterface<typeof NavAngleUnit.FAMILY, NavAngleUnit>> {
    private readonly value;
    /** @inheritdoc */
    readonly isMutableSubscribable = true;
    /**
     * Constructor.
     * @param value The value of this subject.
     */
    private constructor();
    /**
     * Creates a NavAngleSubject.
     * @param initialVal The initial value.
     * @returns A NavAngleSubject.
     */
    static create(initialVal: NumberUnit<typeof NavAngleUnit.FAMILY, NavAngleUnit>): NavAngleSubject;
    /**
     * Creates a NavAngleSubject.
     * @param initialVal The initial value.
     * @returns A NavAngleSubject.
     * @deprecated Use `NavAngleSubject.create()` instead.
     */
    static createFromNavAngle(initialVal: NumberUnit<typeof NavAngleUnit.FAMILY, NavAngleUnit>): NavAngleSubject;
    /** @inheritdoc */
    get(): NumberUnitInterface<typeof NavAngleUnit.FAMILY, NavAngleUnit>;
    /**
     * Sets the new value and notifies the subscribers if the value changed.
     * @param value The new value.
     */
    set(value: NumberUnitInterface<typeof NavAngleUnit.FAMILY, NavAngleUnit>): void;
    /**
     * Sets the new value and notifies the subscribers if the value changed.
     * @param value The numeric part of the new value.
     * @param unit The unit type of the new value. Defaults to the unit type of the NumberUnit used to create this
     * subject.
     */
    set(value: number, unit?: NavAngleUnit): void;
    /**
     * Sets the new value and notifies the subscribers if the value changed.
     * @param value The numeric part of the new value.
     * @param lat The latitude of the new value's location.
     * @param lon The longitude of the new value's location.
     */
    set(value: number, lat: number, lon: number): void;
}

/**
 * A visitor function for geo k-d tree searches.
 * @param element A search result.
 * @param point The location of the search result, in cartesian form.
 * @param distance The great-circle distance, in great-arc radians, from the search result to the query point.
 * @param queryPoint The query point, in cartesian form.
 * @returns Whether to continue the search.
 */
declare type GeoKdTreeSearchVisitor<T> = (element: T, point: ReadonlyFloat64Array, distance: number, queryPoint: ReadonlyFloat64Array) => boolean;
/**
 * A filtering function for k-d tree searches.
 * @param element A candidate search result.
 * @param point The location of the candidate search result, in cartesian form.
 * @param distance The great-circle distance, in great-arc radians, from the candidate search result to the query point.
 * @param queryPoint The query point, in cartesian form.
 * @returns Whether to include the candidate in the final search results.
 */
declare type GeoKdTreeSearchFilter<T> = (element: T, point: ReadonlyFloat64Array, distance: number, queryPoint: ReadonlyFloat64Array) => boolean;
/**
 * A spatial tree which is keyed on points on Earth's surface and allows searching for elements based on the great-
 * circle distances from their keys to a query point.
 */
declare class GeoKdTree<T> {
    private readonly keyFunc;
    private static readonly vec3Cache;
    private readonly cartesianTree;
    /**
     * Constructor.
     * @param keyFunc A function which generates keys from elements. Keys are cartesian representations of points on
     * Earth's surface.
     * @throws Error if the dimension count is less than 2.
     */
    constructor(keyFunc: (element: T, out: Float64Array) => Float64Array);
    /**
     * Searches this tree for elements located near a query point and visits each of them with a function.
     * @param lat The latitude of the query point, in degrees.
     * @param lon The longitude of the query point, in degrees.
     * @param radius The radius around the query point to search, in great-arc radians.
     * @param visitor A visitor function. This function will be called once per element found within the search radius.
     * If the visitor returns `true`, then the search will continue; if the visitor returns `false`, the search will
     * immediately halt.
     */
    search(lat: number, lon: number, radius: number, visitor: GeoKdTreeSearchVisitor<T>): void;
    /**
     * Searches this tree for elements located near a query point and visits each of them with a function.
     * @param center The query point.
     * @param radius The radius around the query point to search, in great-arc radians.
     * @param visitor A visitor function. This function will be called once per element found within the search radius.
     * If the visitor returns `true`, then the search will continue; if the visitor returns `false`, the search will
     * immediately halt.
     */
    search(center: LatLonInterface | ReadonlyFloat64Array, radius: number, visitor: GeoKdTreeSearchVisitor<T>): void;
    /**
     * Searches this tree for elements located near a query point and returns them in order of increasing distance from
     * the query key.
     * @param lat The latitude of the query point, in degrees.
     * @param lon The longitude of the query point, in degrees.
     * @param radius The radius around the query point to search, in great-arc radians.
     * @param maxResultCount The maximum number of search results to return.
     * @param out An array in which to store the search results.
     * @param filter A function to filter the search results.
     * @returns An array containing the search results, in order of increasing distance from the query key.
     */
    search(lat: number, lon: number, radius: number, maxResultCount: number, out: T[], filter?: GeoKdTreeSearchFilter<T>): T[];
    /**
     * Searches this tree for elements located near a query point and returns them in order of increasing distance from
     * the query key.
     * @param center The query point.
     * @param radius The radius around the query point to search, in great-arc radians.
     * @param maxResultCount The maximum number of search results to return.
     * @param out An array in which to store the search results.
     * @param filter A function to filter the search results.
     * @returns An array containing the search results, in order of increasing distance from the query key.
     */
    search(center: LatLonInterface | ReadonlyFloat64Array, radius: number, maxResultCount: number, out: T[], filter?: GeoKdTreeSearchFilter<T>): T[];
    /**
     * Performs a tree search with a visitor function.
     * @param center The query point.
     * @param radiusCartesian The query radius.
     * @param visitor A visitor function. This function will be called once per element found within the search radius.
     * If the visitor returns `true`, then the search will continue; if the visitor returns `false`, the search will
     * immediately halt.
     */
    private doVisitorSearch;
    /**
     * Performs a tree search and returns an array of search results.
     * @param center The query point.
     * @param radiusCartesian The query radius.
     * @param maxResultCount The maximum number of search results to return.
     * @param out An array in which to store the search results.
     * @param filter A function to filter the search results.
     * @returns An array containing the search results, in order of increasing distance from the query key.
     */
    private doResultsSearch;
    /**
     * Inserts an element into this tree. This operation will trigger a rebalancing if, after the insertion, the length
     * of this tree's longest branch is more than twice the length of the shortest branch.
     * @param element The element to insert.
     */
    insert(element: T): void;
    /**
     * Inserts a batch of elements into this tree. This tree will be rebalanced after the elements are inserted.
     * @param elements An iterable of the elements to insert.
     */
    insertAll(elements: Iterable<T>): void;
    /**
     * Removes an element from this tree. This tree will be rebalanced after the element is removed.
     * @param element The element to remove.
     * @returns Whether the element was removed.
     */
    remove(element: T): boolean;
    /**
     * Removes a batch of elements from this tree. This tree will be rebalanced after the elements are removed.
     * @param elements An iterable of the elements to remove.
     * @returns Whether at least one element was removed.
     */
    removeAll(elements: Iterable<T>): boolean;
    /**
     * Removes elements from this tree, then inserts elements into this tree as a single operation. The tree will be
     * rebalanced at the end of the operation.
     *
     * Using this method is more efficient than calling `removeAll()` and `insertAll()` separately.
     * @param toRemove An iterable of the elements to remove.
     * @param toInsert An iterable of the elements to insert.
     */
    removeAndInsert(toRemove: Iterable<T>, toInsert: Iterable<T>): void;
    /**
     * Rebuilds and balances this tree.
     */
    rebuild(): void;
    /**
     * Removes all elements from this tree.
     */
    clear(): void;
}

/**
 * A subscribable which provides a sorted version of a source SubscribableArray.
 */
declare class SortedMappedSubscribableArray<T> extends AbstractSubscribableArray<T> {
    private readonly source;
    private readonly comparatorFunc;
    private readonly equalityFunc?;
    private sorted;
    private readonly sourceSub;
    /** @inheritdoc */
    get length(): number;
    /**
     * Constructor.
     * @param source The source array subject for this subscribable.
     * @param comparatorFunc A function which defines the relative sorting priority of two elements. The function should
     * return 0 if its arguments are to be sorted identically, a negative number if the first argument is to be sorted
     * before the second argument, and a positive number if the first argument is to be sorted after the second argument.
     * @param equalityFunc A function which checks if two elements are equal. Defaults to the strict equality comparison
     * (`===`) if not defined.
     */
    private constructor();
    /**
     * Creates a new SortedMappedSubscribableArray.
     * @param source The source array subject for the new mapped sorted array.
     * @param comparatorFunc A function which defines the relative sorting priority of two elements. The function should
     * return 0 if its arguments are to be sorted identically, a negative number if the first argument is to be sorted
     * before the second argument, and a positive number if the first argument is to be sorted after the second argument.
     * @param equalityFunc A function which checks if two elements are equal. Defaults to the strict equality comparison
     * (`===`) if not defined.
     * @returns A new SortedMappedSubscribableArray.
     */
    static create<CT>(source: SubscribableArray<CT>, comparatorFunc: (a: CT, b: CT) => number, equalityFunc?: (a: CT, b: CT) => boolean): SortedMappedSubscribableArray<CT>;
    /**
     * Responds to changes in this subscribable's source array.
     * @param index The index of the change.
     * @param type The type of change.
     * @param item The item(s) involved in the change, if any.
     */
    private onSourceChanged;
    /**
     * Inserts elements into this array.
     * @param elements An element or array of elements to insert.
     */
    private insert;
    /**
     * Removes elements from this array.
     * @param elements An element or array of elements to remove.
     */
    private remove;
    /** @inheritdoc */
    getArray(): readonly T[];
    /**
     * Destroys this subscribable. After destruction, this subscribable will no longer update in response to changes
     * made to its source.
     */
    destroy(): void;
}

/**
 * A subscribable which provides a filtered version of a source SubscribableArray.
 */
declare class FilteredMappedSubscribableArray<T> extends AbstractSubscribableArray<T> {
    private readonly source;
    private filterFunc;
    private filtered;
    private readonly sourceSub;
    /** @inheritdoc */
    get length(): number;
    /**
     * Private constructor for a FilteredMappedSubscribableArray.
     * @param source The source array subject for this subscribable.
     * @param filterFunc The filter function to use to prune members.  Should return false for filtered-out elements.
     */
    private constructor();
    /**
     * Public creation method for a new FilteredMappedSubscribableArray.
     * @param source The source array subject for the new mapped array.
     * @param filterFunc The filter function to use to prune members.  Should return false for filtered-out elements.
     * @returns A new SortedMappedSubscribableArray.
     */
    static create<CT>(source: SubscribableArray<CT>, filterFunc: (a: CT) => boolean): FilteredMappedSubscribableArray<CT>;
    /**
     * Responds to changes in this subscribable's source array.
     * @param index The index of the change.
     * @param type The type of change.
     * @param item The item(s) involved in the change, if any.
     */
    private onSourceChanged;
    /**
     * Set a new filter for this array.
     * @param filterFunc The new filter function.
     */
    setFilter(filterFunc: (a: T) => boolean): void;
    /**
     * Takes an element or array of elements and returns an array of only those passing the filter.
     * @param elements An element or array of elements to run through the filter.
     * @returns A new list composed of only those elements which pass the filter.
     */
    private filter;
    /**
     * Inserts elements into this array.
     * @param elements An element or array of elements to insert.
     */
    private insert;
    /**
     * Finds the index of the first element in this array which equals a query element.
     * @param element The query element.
     * @returns The index of the first matching element, or -1 if no such element.
     */
    private searchEquals;
    /**
     * Removes elements from this array.
     * @param elements An element or array of elements to remove.
     */
    private remove;
    /**
     * Removes a single element from the array.
     * @param element The element to remove.
     */
    private removeElement;
    /** @inheritdoc */
    getArray(): readonly T[];
    /**
     * Destroys this subscribable. After destruction, this subscribable will no longer update in response to changes
     * made to its source.
     */
    destroy(): void;
}

/**
 * Topics published by {@link FacilityRepository} on the event bus.
 */
interface FacilityRepositoryEvents {
    /** A facility was changed. The suffix of the topic specifies the ICAO of the changed facility. */
    [facility_changed: `facility_changed_${string}`]: Facility;
}
/** Facility types for which {@link FacilityRepository} supports spatial searches. */
declare type SearchableFacilityTypes = FacilityType.USR;
/**
 * A repository of facilities.
 */
declare class FacilityRepository {
    private readonly bus;
    private static readonly SYNC_TOPIC;
    private static readonly treeKeyFunc;
    private static INSTANCE;
    private readonly repos;
    private readonly trees;
    private ignoreSync;
    /**
     * Constructor.
     * @param bus The event bus.
     */
    private constructor();
    /**
     * Retrieves a facility from this repository.
     * @param icao The ICAO of the facility to retrieve.
     * @returns The requested user facility, or undefined if it was not found in this repository.
     */
    get(icao: string): Facility | undefined;
    /**
     * Searches for facilities around a point. Only supported for USR facilities.
     * @param type The type of facility for which to search.
     * @param lat The latitude of the query point, in degrees.
     * @param lon The longitude of the query point, in degrees.
     * @param radius The radius of the search, in great-arc radians.
     * @param visitor A visitor function. This function will be called once per element found within the search radius.
     * If the visitor returns `true`, then the search will continue; if the visitor returns `false`, the search will
     * immediately halt.
     * @throws Error if spatial searches are not supported for the specified facility type.
     */
    search(type: SearchableFacilityTypes, lat: number, lon: number, radius: number, visitor: GeoKdTreeSearchVisitor<Facility>): void;
    /**
     * Searches for facilities around a point. Only supported for USR facilities.
     * @param type The type of facility for which to search.
     * @param lat The latitude of the query point, in degrees.
     * @param lon The longitude of the query point, in degrees.
     * @param radius The radius of the search, in great-arc radians.
     * @param maxResultCount The maximum number of search results to return.
     * @param out An array in which to store the search results.
     * @param filter A function to filter the search results.
     * @throws Error if spatial searches are not supported for the specified facility type.
     */
    search(type: SearchableFacilityTypes, lat: number, lon: number, radius: number, maxResultCount: number, out: Facility[], filter?: GeoKdTreeSearchFilter<Facility>): Facility[];
    /**
     * Adds a facility to this repository and all other repositories synced with this one. If this repository already
     * contains a facility with the same ICAO as the facility to add, the existing facility will be replaced with the
     * new one.
     * @param fac The facility to add.
     * @throws Error if the facility has an invalid ICAO.
     */
    add(fac: Facility): void;
    /**
     * Removes a facility from this repository and all other repositories synced with this one.
     * @param fac The facility to remove.
     * @throws Error if the facility has an invalid ICAO.
     */
    remove(fac: Facility): void;
    /**
     * Iterates over every facility in this respository with a visitor function.
     * @param fn A visitor function.
     * @param types The types of facilities over which to iterate. Defaults to all facility types.
     */
    forEach(fn: (fac: Facility) => void, types?: FacilityType[]): void;
    /**
     * Adds a facility to this repository.
     * @param fac The facility to add.
     */
    private addToRepo;
    /**
     * Removes a facility from this repository.
     * @param fac The facility to remove.
     */
    private removeFromRepo;
    /**
     * Publishes a sync event over the event bus.
     * @param type The type of sync event.
     * @param facs The event's user facilities.
     */
    private pubSyncEvent;
    /**
     * A callback which is called when a sync event occurs.
     * @param data The event data.
     */
    private onSyncEvent;
    /**
     * Gets an instance of FacilityRepository.
     * @param bus The event bus.
     * @returns an instance of FacilityRepository.
     */
    static getRepository(bus: EventBus): FacilityRepository;
}

/**
 * A type map of search type to concrete search session type.
 */
declare type SessionTypeMap = {
    /** Plain search session. */
    [FacilitySearchType.All]: NearestSearchSession<any, any>;
    /** Airport search session. */
    [FacilitySearchType.Airport]: NearestAirportSearchSession;
    /** Intersection search session. */
    [FacilitySearchType.Intersection]: NearestIntersectionSearchSession;
    /** VOR search session. */
    [FacilitySearchType.Vor]: NearestVorSearchSession;
    /** NDB search session. */
    [FacilitySearchType.Ndb]: NearestSearchSession<string, string>;
    /** Boundary search session. */
    [FacilitySearchType.Boundary]: NearestBoundarySearchSession;
    /** Nearest user facility search session. */
    [FacilitySearchType.User]: NearestUserFacilitySearchSession;
};
/**
 * A type map of search type to concrete search session type.
 */
declare type SearchTypeMap = {
    /** Plain search session. */
    [FacilitySearchType.All]: Facility;
    /** Airport search session. */
    [FacilitySearchType.Airport]: AirportFacility;
    /** Intersection search session. */
    [FacilitySearchType.Intersection]: IntersectionFacility;
    /** VOR search session. */
    [FacilitySearchType.Vor]: VorFacility;
    /** NDB search session. */
    [FacilitySearchType.Ndb]: NdbFacility;
    /** Boundary search session. */
    [FacilitySearchType.Boundary]: BoundaryFacility;
    /** Nearest user facility search session. */
    [FacilitySearchType.User]: UserFacility;
};
/**
 * A type map of facility type to facility search type.
 */
declare const FacilityTypeSearchType: {
    /** Airport facility type. */
    LOAD_AIRPORT: FacilitySearchType;
    /** Intersection facility type. */
    LOAD_INTERSECTION: FacilitySearchType;
    /** NDB facility type. */
    LOAD_NDB: FacilitySearchType;
    /** VOR facility type. */
    LOAD_VOR: FacilitySearchType;
    /** USR facility type. */
    USR: FacilitySearchType;
};
/**
 * A class that handles loading facility data from the simulator.
 */
declare class FacilityLoader {
    private readonly facilityRepo;
    readonly onInitialized: () => void;
    private static readonly MAX_FACILITY_CACHE_ITEMS;
    private static readonly MAX_AIRWAY_CACHE_ITEMS;
    private static facilityListener;
    private static readonly requestQueue;
    private static readonly mismatchRequestQueue;
    private static readonly facCache;
    private static readonly typeMismatchFacCache;
    private static readonly airwayCache;
    private static readonly searchSessions;
    private static readonly facRepositorySearchTypes;
    private static repoSearchSessionId;
    private static isInitialized;
    private static readonly initPromiseResolveQueue;
    /**
     * Creates an instance of the FacilityLoader.
     * @param facilityRepo A local facility repository.
     * @param onInitialized A callback to call when the facility loader has completed initialization.
     */
    constructor(facilityRepo: FacilityRepository, onInitialized?: () => void);
    /**
     * Initializes this facility loader.
     */
    private static init;
    /**
     * Waits until this facility loader is initialized.
     * @returns A Promise which is fulfilled when this facility loader is initialized.
     */
    private awaitInitialization;
    /**
     * Retrieves a facility.
     * @param type The type of facility to retrieve.
     * @param icao The ICAO of the facility to retrieve.
     * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
     * retrieved.
     */
    getFacility<T extends FacilityType>(type: T, icao: string): Promise<FacilityTypeMap[T]>;
    /**
     * Retrieves a facility from the local facility repository.
     * @param type The type of facility to retrieve.
     * @param icao The ICAO of the facility to retrieve.
     * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
     * retrieved.
     */
    private getFacilityFromRepo;
    /**
     * Retrieves a facility from Coherent.
     * @param type The type of facility to retrieve.
     * @param icao The ICAO of the facility to retrieve.
     * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
     * retrieved.
     */
    private getFacilityFromCoherent;
    /**
     * Gets airway data from the sim.
     * @param airwayName The airway name.
     * @param airwayType The airway type.
     * @param icao The 12 character FS ICAO of at least one intersection in the airway.
     * @returns The retrieved airway.
     * @throws an error if no airway is returned
     */
    getAirway(airwayName: string, airwayType: number, icao: string): Promise<AirwayObject>;
    /**
     * Starts a nearest facilities search session.
     * @param type The type of facilities for which to search.
     * @returns A Promise which will be fulfilled with the new nearest search session.
     */
    startNearestSearchSession<T extends FacilitySearchType>(type: T): Promise<SessionTypeMap[T]>;
    /**
     * Starts a sim-side nearest facilities search session through Coherent.
     * @param type The type of facilities for which to search.
     * @returns A Promise which will be fulfilled with the new nearest search session.
     */
    private startCoherentNearestSearchSession;
    /**
     * Starts a repository facilities search session.
     * @param type The type of facilities for which to search.
     * @returns A Promise which will be fulfilled with the new nearest search session.
     * @throws Error if the search type is not supported.
     */
    private startRepoNearestSearchSession;
    /**
     * Gets a METAR for an airport.
     * @param airport An airport.
     * @returns The METAR for the airport, or undefined if none could be obtained.
     */
    getMetar(airport: AirportFacility): Promise<Metar | undefined>;
    /**
     * Gets a METAR for an airport.
     * @param ident An airport ident.
     * @returns The METAR for the airport, or undefined if none could be obtained.
     */
    getMetar(ident: string): Promise<Metar | undefined>;
    /**
     * Searches for the METAR issued for the closest airport to a given location.
     * @param lat The latitude of the center of the search, in degrees.
     * @param lon The longitude of the center of the search, in degrees.
     * @returns The METAR issued for the closest airport to the given location, or undefined if none could be found.
     */
    searchMetar(lat: number, lon: number): Promise<Metar | undefined>;
    /**
     * Cleans up a raw METAR object.
     * @param raw A raw METAR object.
     * @returns A cleaned version of the raw METAR object, or undefined if the raw METAR is empty.
     */
    private static cleanMetar;
    /**
     * Searches for ICAOs by their ident portion only.
     * @param filter The type of facility to filter by. Selecting ALL will search all facility type ICAOs.
     * @param ident The partial or complete ident to search for.
     * @param maxItems The max number of matches to return.
     * @returns A collection of matched ICAOs.
     */
    searchByIdent(filter: FacilitySearchType, ident: string, maxItems?: number): Promise<string[]>;
    /**
     * Searches for facilities matching a given ident, and returns the matching facilities, with nearest at the beginning of the array.
     * @param filter The type of facility to filter by. Selecting ALL will search all facility type ICAOs, except for boundary facilities.
     * @param ident The exact ident to search for. (ex: DEN, KDEN, ITADO)
     * @param lat The latitude to find facilities nearest to.
     * @param lon The longitude to find facilities nearest to.
     * @param maxItems The max number of matches to return.
     * @returns An array of matching facilities, sorted by distance to the given lat/lon, with nearest at the beginning of the array.
     */
    findNearestFacilitiesByIdent<T extends FacilitySearchTypeLatLon>(filter: T, ident: string, lat: number, lon: number, maxItems?: number): Promise<SearchTypeMap[T][]>;
    /**
     * A callback called when a facility is received from the simulator.
     * @param facility The received facility.
     */
    private static onFacilityReceived;
    /**
     * A callback called when a search completes.
     * @param results The results of the search.
     */
    private static onNearestSearchCompleted;
    /**
     * Adds a facility to the cache.
     * @param fac The facility to add.
     * @param isTypeMismatch Whether to add the facility to the type mismatch cache.
     */
    private static addToFacilityCache;
    /**
     * Adds an airway to the airway cache.
     * @param airway The airway to add.
     */
    private static addToAirwayCache;
}
/**
 * A session for searching for nearest facilities.
 */
interface NearestSearchSession<TAdded, TRemoved> {
    /**
     * Searches for nearest facilities from the specified point.
     * @param lat The latitude, in degrees.
     * @param lon The longitude, in degrees.
     * @param radius The radius around the point to search, in meters.
     * @param maxItems The maximum number of items.
     * @returns The nearest search results.
     */
    searchNearest(lat: number, lon: number, radius: number, maxItems: number): Promise<NearestSearchResults<TAdded, TRemoved>>;
}
/**
 * A session for searching for nearest facilities through Coherent.
 */
declare class CoherentNearestSearchSession<TAdded, TRemoved> implements NearestSearchSession<TAdded, TRemoved> {
    protected readonly sessionId: number;
    private readonly searchQueue;
    /**
     * Creates an instance of a CoherentNearestSearchSession.
     * @param sessionId The ID of the session.
     */
    constructor(sessionId: number);
    /** @inheritdoc */
    searchNearest(lat: number, lon: number, radius: number, maxItems: number): Promise<NearestSearchResults<TAdded, TRemoved>>;
    /**
     * A callback called by the facility loader when a nearest search has completed.
     * @param results The search results.
     */
    onSearchCompleted(results: NearestSearchResults<TAdded, TRemoved>): void;
}
/**
 * A session for searching for nearest airports.
 */
declare class NearestAirportSearchSession extends CoherentNearestSearchSession<string, string> {
    /**
     * Default filters for the nearest airports search session.
     */
    static Defaults: {
        ShowClosed: boolean;
        ClassMask: number;
        SurfaceTypeMask: number;
        ApproachTypeMask: number;
        MinimumRunwayLength: number;
        ToweredMask: number;
    };
    /**
     * Sets the filter for the airport nearest search.
     * @param showClosed Whether or not to show closed airports.
     * @param classMask A bitmask to determine which JS airport classes to show.
     */
    setAirportFilter(showClosed: boolean, classMask: number): void;
    /**
     * Sets the extended airport filters for the airport nearest search.
     * @param surfaceTypeMask A bitmask of allowable runway surface types.
     * @param approachTypeMask A bitmask of allowable approach types.
     * @param toweredMask A bitmask of untowered (1) or towered (2) bits.
     * @param minRunwayLength The minimum allowable runway length, in meters.
     */
    setExtendedAirportFilters(surfaceTypeMask: number, approachTypeMask: number, toweredMask: number, minRunwayLength: number): void;
}
/**
 * A session for searching for nearest intersections.
 */
declare class NearestIntersectionSearchSession extends CoherentNearestSearchSession<string, string> {
    /**
     * Default filters for the nearest intersections search session.
     */
    static Defaults: {
        TypeMask: number;
    };
    /**
     * Sets the filter for the intersection nearest search.
     * @param typeMask A bitmask to determine which JS intersection types to show.
     */
    setIntersectionFilter(typeMask: number): void;
}
/**
 * A session for searching for nearest VORs.
 */
declare class NearestVorSearchSession extends CoherentNearestSearchSession<string, string> {
    /**
     * Default filters for the nearest VORs search session.
     */
    static Defaults: {
        ClassMask: number;
        TypeMask: number;
    };
    /**
     * Sets the filter for the VOR nearest search.
     * @param classMask A bitmask to determine which JS VOR classes to show.
     * @param typeMask A bitmask to determine which JS VOR types to show.
     */
    setVorFilter(classMask: number, typeMask: number): void;
}
/**
 * A session for searching for nearest airspace boundaries.
 */
declare class NearestBoundarySearchSession extends CoherentNearestSearchSession<BoundaryFacility, number> {
    /**
     * Sets the filter for the boundary nearest search.
     * @param classMask A bitmask to determine which boundary classes to show.
     */
    setBoundaryFilter(classMask: number): void;
}
/**
 * A session for searching for nearest user facilities.
 */
declare class NearestUserFacilitySearchSession implements NearestSearchSession<string, string> {
    private readonly repo;
    private readonly sessionId;
    private filter;
    private readonly cachedResults;
    private searchId;
    /**
     * Creates an instance of a NearestUserSearchSession.
     * @param repo The facility repository in which to search.
     * @param sessionId The ID of the session.
     */
    constructor(repo: FacilityRepository, sessionId: number);
    /** @inheritdoc */
    searchNearest(lat: number, lon: number, radius: number, maxItems: number): Promise<NearestSearchResults<string, string>>;
    /**
     * Sets the filter for this search session.
     * @param filter A function to filter the search results.
     */
    setUserFacilityFilter(filter?: GeoKdTreeSearchFilter<UserFacility>): void;
}
/**
 * An airway.
 */
declare class AirwayObject {
    private _name;
    private _type;
    private _waypoints;
    /** Builds a Airway
     * @param name - the name of the new airway.
     * @param type - the type of the new airway.
     */
    constructor(name: string, type: number);
    /**
     * Gets the name of the airway
     * @returns the airway name
     */
    get name(): string;
    /**
     * Gets the type of the airway
     * @returns the airway type
     */
    get type(): number;
    /**
     * Gets the waypoints of this airway.
     * @returns the waypoints of this airway.
     */
    get waypoints(): IntersectionFacility[];
    /**
     * Sets the waypoints of this airway.
     * @param waypoints is the array of waypoints.
     */
    set waypoints(waypoints: IntersectionFacility[]);
}
/**
 * WT Airway Status Enum
 */
declare enum AirwayStatus {
    /**
     * @readonly
     * @property {number} INCOMPLETE - indicates waypoints have not been loaded yet.
     */
    INCOMPLETE = 0,
    /**
     * @readonly
     * @property {number} COMPLETE - indicates all waypoints have been successfully loaded.
     */
    COMPLETE = 1,
    /**
     * @readonly
     * @property {number} PARTIAL - indicates some, but not all, waypoints have been successfully loaded.
     */
    PARTIAL = 2
}
/**
 * The Airway Builder.
 */
declare class AirwayBuilder {
    private _initialWaypoint;
    private _initialData;
    private facilityLoader;
    private _waypointsArray;
    private _hasStarted;
    private _isDone;
    /** Creates an instance of the AirwayBuilder
     * @param _initialWaypoint is the initial intersection facility
     * @param _initialData is the intersection route to build from
     * @param facilityLoader is an instance of the facility loader
     */
    constructor(_initialWaypoint: IntersectionFacility, _initialData: AirwaySegment, facilityLoader: FacilityLoader);
    /**
     * Get whether this builder has started loading waypoints
     * @returns whether this builder has started
     */
    get hasStarted(): boolean;
    /**
     * Get whether this builder is done loading waypoints
     * @returns whether this builder is done loading waypoints
     */
    get isDone(): boolean;
    /**
     * Get the airway waypoints
     * @returns the airway waypoints, or null
     */
    get waypoints(): IntersectionFacility[] | null;
    /** Steps through the airway waypoints
     * @param stepForward is the direction to step; true = forward, false = backward
     * @param arrayInsertFunc is the arrayInsertFunc
     */
    _step(stepForward: boolean, arrayInsertFunc: (wpt: IntersectionFacility) => void): Promise<void>;
    /** Steps Forward through the airway waypoints
     * @returns the step forward function
     */
    _stepForward(): Promise<void>;
    /** Steps Backward through the airway waypoints
     * @returns the step backward function
     */
    _stepBackward(): Promise<void>;
    /**
     * Sets the array into which this builder will load waypoints.
     * @param array is the array into which the builder will load waypoints
     */
    setWaypointsArray(array: IntersectionFacility[]): void;
    /**
     * Begins loading waypoints for this builder's parent airway.
     * @returns a Promise to return a status code corresponding to Airway.Status when this builder has
     * finished loading waypoints.
     */
    startBuild(): Promise<AirwayStatus>;
}

/**
 * Utility functions for working with airport data.
 */
declare class AirportUtils {
    /**
     * Gets the longest runway of an airport.
     * @param facility The facility record for the airport.
     * @returns The longest runway as an AirportRunway, or null.
     */
    static getLongestRunway(facility: AirportFacility): AirportRunway | null;
    /**
     * Get a list of runways at an airport matching specific criteria.
     * @param facility The facility record for the airport.
     * @param minLength The minimum length of the runway, in feet.
     * @param surfaceTypes An optional bitfield of RunwaySurfaceCategory values to allow.
     * @returns A list of matching runways.
     */
    static getFilteredRunways(facility: AirportFacility, minLength: number, surfaceTypes?: number): AirportRunway[];
    /**
     * Checks to see whether an airport has a runway matching specific criteria.   This is a
     * lighter version of getFilteredRunways that doesn't do any extra assignments.
     * @param facility The facility record for the airport.
     * @param minLength The minimum length of the runway, in feet.
     * @param surfaceTypes An optional bitfield of RunwaySurfaceCategory values to allow.
     * @returns A boolean if a matching runway exists.
     */
    static hasMatchingRunway(facility: AirportFacility, minLength: number, surfaceTypes?: number): boolean;
}

/**
 * Types of airspaces.
 */
declare enum AirspaceType {
    None = 0,
    Center = 1,
    ClassA = 2,
    ClassB = 3,
    ClassC = 4,
    ClassD = 5,
    ClassE = 6,
    ClassF = 7,
    ClassG = 8,
    Tower = 9,
    Clearance = 10,
    Ground = 11,
    Departure = 12,
    Approach = 13,
    MOA = 14,
    Restricted = 15,
    Prohibited = 16,
    Warning = 17,
    Alert = 18,
    Danger = 19,
    Nationalpark = 20,
    ModeC = 21,
    Radar = 22,
    Training = 23,
    Max = 24
}
/**
 * An airspace.
 */
interface Airspace {
    /** The type of the airspace. */
    readonly type: AirspaceType;
    /** The name of the airspace. */
    readonly name: string;
    /** The type of the airspace. */
    readonly segments: readonly GeoPoint[];
    /**
     * Checks whether this airspace is the same as another airspace.
     * @param other The other airspace.
     * @returns whether this airspace is the same as another airspace.
     */
    equals(other: Airspace): boolean;
}

/**
 * A searcher for airspaces.
 */
declare class AirspaceSearcher {
    readonly cacheSize: number;
    /** The amount of time to wait for a search to finish before it times out, in milliseconds. */
    static readonly SEARCH_TIMEOUT = 5000;
    static readonly DEFAULT_CACHE_SIZE = 1000;
    private cache;
    private _isBusy;
    private queue;
    /**
     * Constructor.
     * @param cacheSize The maximum size of the Airspace cache.
     */
    constructor(cacheSize?: number);
    /**
     * Checks whether this searcher is currently busy with a search.
     * @returns whether this searcher is currently busy with a search.
     */
    isBusy(): boolean;
    /**
     * Searches for airspaces around a geographic point. If the searcher is not busy, the search will execute
     * immediately. If the search is busy, the search will be queued. Queued searches will be executed one at a time in
     * FIFO order as searches are finished.
     * @param center The center of the search area.
     * @returns a Promise which is fulfilled with an array of airspaces when the search finishes.
     */
    search(center: GeoPointInterface): Promise<Airspace[]>;
    /**
     * Enqueues a search operation.
     * @param center The center of the search area.
     * @param resolve The Promise resolve function to call with the search results.
     */
    private enqueueSearch;
    /**
     * Executes the next search operation in the queue, if one exists.
     */
    private processQueue;
    /**
     * Executes an airspace search.
     * @param center The center of the search area.
     * @param resolve The Promise resolve function to call with the search results.
     */
    private doSearch;
    /**
     * Executes a Coherent airspace search.
     * @param center The center of the search area.
     * @returns a Promise which is fulfilled with an array of Coherent airspace definitions when the search finishes.
     */
    private executeCoherentSearch;
    /**
     * Processes an array of Coherent airspace definitions into an array of Airspaces.
     * @param defs An array fo Coherent airspace definitions.
     * @returns an array of Airspaces corresponding to the supplied definitions.
     */
    private processCoherentDefs;
    /**
     * Adds an airspace to the cache. If the cache size exceeds the maximum after the operation, airspaces will be
     * removed from the cache in FIFO order to maintain the maximum cache size.
     * @param airspace The airspace to cache.
     */
    private cacheAirspace;
    /**
     * Generates a unique string ID for a Coherent airspace definition.
     * @param def The airspace definition.
     * @returns a unique string ID.
     */
    private static generateUID;
}

/**
 * A viewlistener that gets autopilot mode information.
 */
declare enum MSFSAPStates {
    LogicOn = 1,
    APOn = 2,
    FDOn = 4,
    FLC = 8,
    Alt = 16,
    AltArm = 32,
    GS = 64,
    GSArm = 128,
    Pitch = 256,
    VS = 512,
    Heading = 1024,
    Nav = 2048,
    NavArm = 4096,
    WingLevel = 8192,
    Attitude = 16384,
    ThrottleSpd = 32768,
    ThrottleMach = 65536,
    ATArm = 131072,
    YD = 262144,
    EngineRPM = 524288,
    TOGAPower = 1048576,
    Autoland = 2097152,
    TOGAPitch = 4194304,
    Bank = 8388608,
    FBW = 16777216,
    AvionicsManaged = 33554432,
    None = -2147483648
}

/**
 * Possible types of hold entries
 */
declare enum HoldEntryType {
    Direct = 0,
    Teardrop = 1,
    Parallel = 2,
    None = 3
}
declare enum HoldMaxSpeedRule {
    Faa = 0,
    Icao = 1
}
/**
 * Utilities for hold entries
 */
declare class HoldUtils {
    /**
     * Gets a hold direction UI string for a given inbound course.
     *
     * @param course The inbound course to get the string for.
     * @param short Whether to get the string in short form (single letter)
     *
     * @returns A UI human-readable course string.
     */
    static getDirectionString(course: number, short?: boolean): string;
    /**
     * Obtains hold speed (number and isMach) depending on altitude and speed rule (ICAO or FAA)
     *
     * @param altitude MSL altitude
     * @param rule     hold speed rule
     *
     * @returns hold speed and whether that number is in Mach
     */
    static getHoldSpeed(altitude: number, rule: HoldMaxSpeedRule): [speed: number, isMach: boolean];
}

declare enum RunwaySurfaceCategory {
    Unknown = 1,
    Hard = 2,
    Soft = 4,
    Water = 8
}
/**
 * Methods for working with Runways and Runway Designations.
 */
declare class RunwayUtils {
    private static readonly RUNWAY_DESIGNATOR_LETTERS;
    private static readonly SURFACES_HARD;
    private static readonly SURFACES_SOFT;
    private static readonly SURFACES_WATER;
    protected static tempGeoPoint: GeoPoint;
    /**
     * Gets the letter for a runway designator.
     * @param designator A runway designator.
     * @param lowerCase Whether the letter should be lower case. False by default.
     * @returns The letter for the specified runway designator.
     */
    static getDesignatorLetter(designator: RunwayDesignator, lowerCase?: boolean): string;
    /**
     * Creates an empty one-way runway.
     * @returns an empty one-way runway.
     */
    static createEmptyOneWayRunway(): OneWayRunway;
    /**
     * Utility method to return two one-way runways from a single runway facility
     * @param runway is the AirportRunway object to evaluate
     * @param index is the index of the AirportRunway in the Facility
     * @returns splitRunways array of OneWayRunway objects
     */
    static getOneWayRunways(runway: AirportRunway, index: number): OneWayRunway[];
    /**
     * Utility method to return the runway name from the number and designator (L/R/C/W)
     * @param runwayNumber is the integer part of a runway name (18, 26, 27, etc)
     * @param designator is the RunwayDesignator enum for the runway
     * @param padded Whether single-char runways should be 0-padded.
     * @param prefix A prefix to put before the runway name.
     * @returns the runway name string
     */
    static getRunwayNameString(runwayNumber: number, designator: RunwayDesignator, padded?: boolean, prefix?: string): string;
    /**
     * Gets a one-way runway from an airport that matches a runway designation by number and designator.
     * @param airport The airport facility in which to search for the match.
     * @param runwayNumber A runway number to match.
     * @param runwayDesignator A runway designator to match.
     * @returns The one-way runway which matches the designation, or undefined if no match could be found.
     */
    static matchOneWayRunway(airport: AirportFacility, runwayNumber: number, runwayDesignator: RunwayDesignator): OneWayRunway | undefined;
    /**
     * Gets a one-way runway from an airport that matches a runway designation string.
     * @param airport The airport facility in which to search for the match.
     * @param designation A runway designation.
     * @returns The one-way runway which matches the designation, or undefined if no match could be found.
     */
    static matchOneWayRunwayFromDesignation(airport: AirportFacility, designation: string): OneWayRunway | undefined;
    /**
     * Gets a one-way runway from an airport that matches a runway ident.
     * @param airport The airport facility in which to search for the match.
     * @param ident A runway ident.
     * @returns The one-way runway which matches the ident, or undefined if no match could be found.
     */
    static matchOneWayRunwayFromIdent(airport: AirportFacility, ident: string): OneWayRunway | undefined;
    /**
     * Utility method to return the procedures for a given runway.
     * @param procedures The procedures for the airport.
     * @param runway The given runway to find procedures for.
     * @returns A list of approach procedures for the given runway.
     */
    static getProceduresForRunway(procedures: readonly ApproachProcedure[], runway: AirportRunway): Array<ApproachProcedure>;
    /**
     * Gets the localizer frequency for a runway.
     * @param airport The airport to which the query runway belongs.
     * @param runway The query runway.
     * @returns The localizer frequency for the query runway, or undefined if one could not be found.
     */
    static getLocFrequency(airport: AirportFacility, runway: OneWayRunway): FacilityFrequency | undefined;
    /**
     * Gets the localizer frequency for a runway.
     * @param airport The airport to which the query runway belongs.
     * @param runwayDesignation The designation of the query runway.
     * @returns The localizer frequency for the query runway, or undefined if one could not be found.
     */
    static getLocFrequency(airport: AirportFacility, runwayDesignation: string): FacilityFrequency | undefined;
    /**
     * Gets the localizer frequency for a runway.
     * @param airport The airport to which the query runway belongs.
     * @param runwayNumber The number of the query runway.
     * @param runwayDesignator The designator of the query runway.
     * @returns The localizer frequency for the query runway, or undefined if one could not be found.
     */
    static getLocFrequency(airport: AirportFacility, runwayNumber: number, runwayDesignator: RunwayDesignator): FacilityFrequency | undefined;
    /**
     * Gets the back course frequency for a runway.
     * @param airport The airport to which the query runway belongs.
     * @param runwayNumber The number of the query runway.
     * @param runwayDesignator The designator of the query runway.
     * @returns The bc frequency for the query runway, or undefined if one could not be found.
     */
    static getBcFrequency(airport: AirportFacility, runwayNumber: number, runwayDesignator: RunwayDesignator): FacilityFrequency | undefined;
    /**
     * Get the opposite one way runway from a runway number and designator.
     * @param airport The airport to which the query runway belongs.
     * @param runwayNumber The number of the query runway.
     * @param runwayDesignator The designator of the query runway.
     * @returns The opposite one way runway for the query runway, or undefined if one could not be found.
     */
    static getOppositeOneWayRunway(airport: AirportFacility, runwayNumber: number, runwayDesignator: RunwayDesignator): OneWayRunway | undefined;
    /**
     * A comparer for sorting runways by number, and then by L, C, and R.
     * @param r1 The first runway to compare.
     * @param r2 The second runway to compare.
     * @returns -1 if the first is before, 0 if equal, 1 if the first is after.
     */
    static sortRunways(r1: OneWayRunway, r2: OneWayRunway): number;
    /**
     * Gets the ICAO string for the runway facility associated with a one-way runway.
     * @param airport The runway's parent airport.
     * @param runway A one-way runway.
     * @returns the ICAO string for the runway facility associated with the one-way runway.
     */
    static getRunwayFacilityIcao(airport: AirportFacility, runway: OneWayRunway): string;
    /**
     * Creates a runway waypoint facility from a runway.
     * @param airport The runway's parent airport.
     * @param runway A one-way runway.
     * @returns A runway waypoint facility corresponding to the runway.
     */
    static createRunwayFacility(airport: AirportFacility, runway: OneWayRunway): RunwayFacility;
    /**
     * Gets an alpha code from a runway number.
     * @param number is the runway number.
     * @returns a letter.
     */
    static getRunwayCode(number: number): string;
    /**
     * Gets the runway surface category from a runway based on its surface type.
     * @param runway An {@link AirportRunway}.
     * @returns The surface category of that runway.
     */
    static getSurfaceCategory(runway: AirportRunway): RunwaySurfaceCategory;
}

/**
 * Interface specification for a nearest search subscription.
 */
interface NearestSubscription<T extends Facility> extends SubscribableArray<T> {
    /** Whether the search has started. */
    started: boolean;
    /** The method for starting a search. */
    start: () => Promise<void>;
    /** The method for updating a search. */
    update: (lat: number, lon: number, radius: number, maxItems: number) => Promise<void>;
}
/**
 * A class for tracking a nearest facility session and making it available as a
 * subscribable array of facilities.
 */
declare abstract class AbstractNearestSubscription<T extends Facility, TAdded, TRemoved> extends AbstractSubscribableArray<T> implements NearestSubscription<T> {
    protected readonly facilityLoader: FacilityLoader;
    protected readonly type: FacilitySearchType;
    protected readonly facilities: T[];
    protected readonly facilityIndex: Map<TRemoved, T>;
    protected session: NearestSearchSession<TAdded, TRemoved> | undefined;
    private searchInProgress;
    /**
     * Creates an instance of a NearestSubscription.
     * @param facilityLoader An instance of the facility loader to search with.
     * @param type The type of facility to search for.
     */
    constructor(facilityLoader: FacilityLoader, type: FacilitySearchType);
    /** @inheritdoc */
    get length(): number;
    /**
     * Whether or not this subscription has been started.
     * @returns True if started, false otherwise.
     */
    get started(): boolean;
    /** @inheritdoc */
    getArray(): readonly T[];
    /**
     * Starts the search subscription.
     */
    start(): Promise<void>;
    /**
     * Updates the nearest search subscription.
     * @param lat The latitude of the current search position.
     * @param lon The longitude of the current search position.
     * @param radius The radius of the search, in meters.
     * @param maxItems The maximum number of items to return in the search.
     */
    update(lat: number, lon: number, radius: number, maxItems: number): Promise<void>;
    /**
     * A callback called when results are received.
     * @param results The results that were received.
     */
    protected abstract onResults(results: NearestSearchResults<TAdded, TRemoved>): Promise<void>;
    /**
     * Adds a facility to the collection.
     * @param facility The facility to add.
     * @param key The key to track this facility by.
     */
    protected addFacility(facility: T, key: TRemoved): void;
    /**
     * Removes a facility from the collection.
     * @param key The key of the facility to remove.
     */
    protected removeFacility(key: TRemoved): void;
}
/**
 * A nearest search subscription for waypoint facilites, including logic for further filtering
 * of results beyond what the sim search API gives us.
 */
declare abstract class NearestWaypointSubscription<T extends Facility> extends AbstractNearestSubscription<T, string, string> {
    private filterCb?;
    private facilityCache;
    /**
     * Creates a new NearestWaypointSubscription.
     * @param facilityLoader An instance of the facility loader to search with.
     * @param type The type of facility to search for.
     * @param filterCb An optional callback for filtering the results.
     */
    constructor(facilityLoader: FacilityLoader, type?: FacilitySearchType, filterCb?: (facility: T) => boolean);
    /**
     * Change the search filter and trigger a refresh of the search results.
     * @param filter The new search filter to use.
     */
    setFilterCb(filter: (facility: T) => boolean): void;
    /** @inheritdoc */
    protected onResults(results: NearestSearchResults<string, string>): Promise<void>;
}
/**
 * A nearest search subscription for airport facilites.
 */
declare class NearestAirportSubscription extends NearestWaypointSubscription<AirportFacility> {
    /**
     * Creates a new NearestAirportSubscription.
     * @param facilityLoader The facility loader to use with this instance.
     * @param filterCb An optional filter to use for additional search criteria.
     */
    constructor(facilityLoader: FacilityLoader, filterCb?: (facility: AirportFacility) => boolean);
    /**
     * Sets the airport search filter.
     * @param showClosed Whether or not to return closed airports in the search.
     * @param classMask A bitmask representing the classes of airports to show.
     */
    setFilter(showClosed: boolean, classMask: number): void;
    /**
     * Sets the extended airport filters for the airport nearest search.
     * @param surfaceTypeMask A bitmask of allowable runway surface types.
     * @param approachTypeMask A bitmask of allowable approach types.
     * @param toweredMask A bitmask of untowered (1) or towered (2) bits.
     * @param minRunwayLength The minimum allowable runway length, in meters.
     */
    setExtendedFilters(surfaceTypeMask: number, approachTypeMask: number, toweredMask: number, minRunwayLength: number): void;
}
/**
 * A nearest search subscription for intersection facilites.
 */
declare class NearestIntersectionSubscription extends NearestWaypointSubscription<IntersectionFacility> {
    /**
     * Creates a new NearestIntersectionSubscription.
     * @param facilityLoader The facility loader to use with this instance.
     */
    constructor(facilityLoader: FacilityLoader);
    /**
     * Sets the intersection search filter.
     * @param typeMask A bitmask representing the classes of intersections to show.
     */
    setFilter(typeMask: number): void;
}
/**
 * A nearest search subscription for VOR facilites.
 */
declare class NearestVorSubscription extends NearestWaypointSubscription<VorFacility> {
    /**
     * Creates a new NearestVorSubscription.
     * @param facilityLoader The facility loader to use with this instance.
     */
    constructor(facilityLoader: FacilityLoader);
}
/**
 * A nearest search subscription for NDB facilites.
 */
declare class NearestNdbSubscription extends NearestWaypointSubscription<NdbFacility> {
    /**
     * Creates a new NearestNdbSubscription.
     * @param facilityLoader The facility loader to use with this instance.
     */
    constructor(facilityLoader: FacilityLoader);
}
/**
 * A wrapper for a {@link NearestSearchSession} that automatically adjusts the number of
 * search results requested from the sim to minimize search load while still attempting to
 * provide the total number of results needed by the user.
 */
declare class AdaptiveNearestSubscription<T extends Facility> extends AbstractSubscribableArray<T> implements NearestSubscription<T> {
    private subscription;
    private absoluteMaxItems;
    private static readonly RAMP_UP_FACTOR;
    private static readonly RAMP_DOWN_FACTOR;
    /** The array that holds the results of our latest search. */
    private facilities;
    /**
     * This array provides a backing store for what is essentially a "virtual" array
     * representing the aggregate of our search results to the client. Since we need to
     * limit the number of results returned we will carefully manage notifications when
     * anything changes to only expose the requested number of elements.
     */
    private shadowFacilities;
    /** The number of items requested on the last call to update. */
    private lastMaxRequested;
    /** The number of items we are requesting from the inner search to meet current demands. */
    private derivedMaxItems;
    /** Whether we have a search in progress already. */
    private searchInProgress;
    /** A reusable GeoPoint for sorting by distance. */
    private pos;
    /**
     * Creates an instance of AdaptiveNearestSubscription.
     * @param subscription A {@link NearestSubscription} to use as our inner search.
     * @param absoluteMaxItems The maximum number of results to request in any search.
     */
    constructor(subscription: AbstractNearestSubscription<T, any, any>, absoluteMaxItems: number);
    /** @inheritdoc */
    get length(): number;
    /** @inheritdoc */
    getArray(): readonly T[];
    /**
     * Whether or not the inner search has started.
     * @returns True if started, false otherwise.
     */
    get started(): boolean;
    /**
     * Start the inner search subscription.
     */
    start(): Promise<void>;
    /**
     * Cause the inner subscription to update.
     * @param lat The latitude of the current search position.
     * @param lon The longitude of the current search position.
     * @param radius The radius of the search, in meters.
     * @param maxItems The maximum number of items to return in the search.
     */
    update(lat: number, lon: number, radius: number, maxItems: number): Promise<void>;
    /**
     * Responds to changes in our inner search and updates our facilities store accordingly.
     * @param index The index of the changed item.
     * @param type The type of change.
     * @param item The item(s) involved in the change, if any.
     */
    private onSourceChanged;
    /**
     * Notify our subscribers of changes to the virtual search results.
     * @param index The index of the changed item.
     * @param type The type of change.
     * @param item The item(s) involved in the change, if any.
     */
    private notifySubscribers;
}

/**
 * A vector describing one edge of a boundary shape.
 */
declare type LodBoundaryVector = {
    /** The path of this vector, or undefined if this is a starting vector. */
    circle?: GeoCircle;
    /** The end point of this vector. */
    end: GeoPointInterface;
};
/**
 * A single contiguous boundary shape.
 */
declare type LodBoundaryShape = LodBoundaryVector[];
/**
 * A boundary (airspace) with pre-processed LODs.
 */
declare class LodBoundary {
    readonly facility: BoundaryFacility;
    private static readonly geoCircleCache;
    private static readonly edgeCache;
    private static readonly queue;
    /** The Douglas-Peucker thresholds, in great-arc radians, used by each of this boundary's LOD levels. */
    readonly lodDistanceThresholds: readonly number[];
    private readonly lodVectorCountTargets;
    /** This boundary's LOD levels. Each LOD level contains one or more boundary shapes. */
    readonly lods: readonly (readonly Readonly<LodBoundaryShape>[])[];
    /**
     * Constructor.
     * @param facility This boundary's facility object.
     * @param lodDistanceThresholds The Douglas-Peucker thresholds, in great-arc radians, used by each LOD level. If
     * undefined or an empty array, only one LOD level (LOD0) will be created with a distance threshold of 0.
     * @param lodVectorCountTargets The vector count targets for each LOD level. The number of vectors per shape after
     * simplification will not exceed the LOD levels' target. Non-positive targets are interpreted as unlimited.
     * If undefined, all LOD levels will be assigned an unlimited vector count target.
     */
    constructor(facility: BoundaryFacility, lodDistanceThresholds?: readonly number[], lodVectorCountTargets?: readonly number[]);
    /**
     * Processes this boundary's LOD levels.
     * @returns This boundary's processed LOD levels.
     */
    private processLods;
    /**
     * Processes this boundary's facility's vectors into boundary shapes.
     * @param vectors The vectors to process.
     * @returns Boundary shapes corresponding to this boundary's facility's vectors.
     */
    private processShapes;
    /**
     * Processes a single, non-circle boundary shape from this boundary's facility's vectors.
     * @param shape The shape to be processed.
     * @param vectors The array containing the facility boundary vectors making up the shape.
     * @param index The index of the first facility boundary vector which makes up the shape.
     * @returns The index of the last facility boundary vector which makes up the shape.
     */
    private processShape;
    /**
     * Processes a single circle boundary shape from this boundary's facility's vectors.
     * @param shape The shape to be processed.
     * @param vectors The array containing the facility boundary vectors making up the shape.
     * @param index The index of the first facility boundary vector which makes up the shape.
     * @returns The index of the last facility boundary vector which makes up the shape.
     */
    private processCircle;
    /**
     * Simplifies boundary shapes using the Douglas-Peucker algorithm.
     * @param shapes The boundary shapes to simplify.
     * @param distanceThreshold The Douglas-Peucker distance threshold, in great-arc radians.
     * @param vectorCountTarget The vector count target for the simplified shapes. An undefined value is interpreted as
     * an unlimited target.
     * @returns The simplified boundary shapes.
     */
    private simplifyShapes;
    /**
     * Simplifies a boundary shape using the Douglas-Peucker algorithm.
     * @param shape The boundary shape to simplify.
     * @param distanceThreshold The Douglas-Peucker distance threshold, in great-arc radians.
     * @param vectorCountTarget The vector count target for the simplified shape. An undefined value is interpreted as
     * an unlimited target.
     * @returns The simplified boundary shape.
     */
    private simplifyShape;
    /**
     * Simplifies a sequence of vectors in a boundary shape using the Douglas-Peucker algorithm.
     * @param distanceThreshold The Douglas-Peucker distance threshold, in great-arc radians.
     * @param shape The boundary shape containing the vectors to simplify.
     * @param startIndex The index of the first vector in the sequence to simplify, inclusive.
     * @param endIndex The index of the last vector in the sequence to simplify, exclusive.
     * @param retain An array of boolean values indicating which vectors in the shape to retain after simplification.
     */
    private simplify;
    /**
     * Simplifies a sequence of vectors in a boundary shape using the Douglas-Peucker algorithm to a target vector count.
     * @param distanceThreshold The Douglas-Peucker distance threshold, in great-arc radians.
     * @param vectorCountTarget The vector count target for the simplified shape.
     * @param shape The boundary shape containing the vectors to simplify.
     * @param startIndex The index of the first vector in the sequence to simplify, inclusive.
     * @param endIndex The index of the last vector in the sequence to simplify, exclusive.
     * @param retain An array of boolean values indicating which vectors in the shape to retain after simplification.
     */
    private simplifyToVectorCount;
    /**
     * Computes an edge and inserts it into a priority queue if the distance from the edge to the farthest vector is
     * greater than a specified distance threshold.
     * @param distanceThreshold The Douglas-Peucker distance threshold, in great-arc radians.
     * @param shape The boundary shape containing the vectors to simplify.
     * @param startIndex The index of the vector at the start of the edge.
     * @param endIndex The index of the vector at the end of the edge.
     * @param queue The priority queue into which to insert the edge.
     * @param edgeIndex The index from which to retrieve an edge from the edge cache, if needed.
     */
    private computeAndInsertEdgeToQueue;
    /**
     * Finds the vector in a boundary shape containing the farthest point from a reference.
     * @param shape The shape containing the vectors to search.
     * @param startIndex The index of the first vector to search, inclusive.
     * @param endIndex The index of the last vector to search, exclusive.
     * @param reference The reference to which to measure distance.
     * @returns The index of the vector containing the farthest point from a reference, and the corresponding distance in great-arc radians.
     */
    private findFarthestVector;
    /**
     * Calculates the maximum distance from a vector in a boundary shape to a reference.
     * @param shape The shape containing the vector to query.
     * @param index The index of the vector to query.
     * @param reference The reference to which to measure the distance.
     * @returns The maximum distance from the vector to the reference, in great-arc radians.
     */
    private getDistanceFromReference;
    /**
     * Rebuilds vectors for a simplified shape.
     * @param shape The original shape.
     * @param retain An array of boolean values indicating which vectors in the shape to retain after simplification.
     * @param simplified The simplified shape to which to add the rebuilt vectors.
     */
    private rebuildSimplifiedVectors;
    /**
     * Copies a boundary shape vector.
     * @param source The vector to copy.
     * @returns A copy of `source`.
     */
    private static copyVector;
    /**
     * Creates an edge.
     * @returns An edge.
     */
    private static createEdge;
}

/**
 * A cache of LodBoundary objects.
 */
declare class LodBoundaryCache {
    readonly size: number;
    readonly lodDistanceThresholds: readonly number[];
    readonly lodVectorCountTargets: readonly number[];
    private readonly cache;
    /**
     * Constructor.
     * @param size The maximum size of this cache.
     * @param lodDistanceThresholds The Douglas-Peucker distance thresholds, in great-arc radians, for each LOD level
     * used by this cache's LodBoundary objects.
     * @param lodVectorCountTargets The vector count targets for each LOD level used by this cache's LodBoundary objects.
     */
    constructor(size: number, lodDistanceThresholds: readonly number[], lodVectorCountTargets: readonly number[]);
    /**
     * Retrieves a LodBoundary from this cache corresponding to a boundary facility. If the requested LodBoundary does
     * not exist, it will be created and added to this cache.
     * @param facility A boundary facility.
     * @returns The LodBoundary corresponding to `facility`.
     */
    get(facility: BoundaryFacility): LodBoundary;
    /**
     * Creates a new LodBoundary and adds it to this cache.
     * @param facility The facility from which to create the new LodBoundary.
     * @returns The newly created LodBoundary.
     */
    private create;
}

/**
 * Results of a nearest LodBoundary search.
 */
declare type NearestLodBoundarySearchResults = {
    /** The boundaries found in these search results that were not returned in the last search. */
    added: readonly LodBoundary[];
    /** The unique IDs of the boundaries returned in the last search that are not found in these search results. */
    removed: readonly number[];
};
/**
 * A nearest search session for boundaries (airspaces) in the form of LodBoundary objects.
 */
declare class NearestLodBoundarySearchSession {
    private readonly cache;
    private readonly session;
    readonly frameBudget: number;
    /**
     * Constructor.
     * @param cache The boundary cache this search session uses.
     * @param session The nearest boundary facility search session this search session uses.
     * @param frameBudget The maximum amount of time allotted per frame to retrieve and process LodBoundary objects, in
     * milliseconds.
     */
    constructor(cache: LodBoundaryCache, session: NearestBoundarySearchSession, frameBudget: number);
    /**
     * Searches for the nearest boundaries around a specified location.
     * @param lat The latitude of the search center, in degrees.
     * @param lon The longitude of the search center, in degrees.
     * @param radius The radius of the search, in meters.
     * @param maxItems The maximum number of items for which to search.
     * @returns The nearest search results.
     */
    searchNearest(lat: number, lon: number, radius: number, maxItems: number): Promise<NearestLodBoundarySearchResults>;
    /**
     * Sets this session's boundary class filter. The new filter takes effect with the next search executed in this
     * session.
     * @param classMask A bitmask defining the boundary classes to include in the search (`0`: exclude, `1`: include).
     * The bit index for each boundary class is equal to the value of the corresponding `BoundaryType` enum.
     */
    setFilter(classMask: number): void;
}

/**
 * A collection of unique string waypoint type keys.
 */
declare enum WaypointTypes {
    Custom = "Custom",
    Airport = "Airport",
    NDB = "NDB",
    VOR = "VOR",
    Intersection = "Intersection",
    Runway = "Runway",
    User = "User",
    Visual = "Visual",
    FlightPlan = "FlightPlan",
    VNAV = "VNAV"
}
/**
 * A navigational waypoint.
 */
interface Waypoint {
    /** The geographic location of the waypoint. */
    readonly location: Subscribable<GeoPointInterface>;
    /** A unique string ID assigned to this waypoint. */
    readonly uid: string;
    /**
     * Checks whether this waypoint and another are equal.
     * @param other The other waypoint.
     * @returns whether this waypoint and the other are equal.
     */
    equals(other: Waypoint): boolean;
    /** The unique string type of this waypoint. */
    readonly type: string;
}
/**
 * An abstract implementation of Waypoint.
 */
declare abstract class AbstractWaypoint implements Waypoint {
    abstract get location(): Subscribable<GeoPointInterface>;
    abstract get uid(): string;
    abstract get type(): string;
    equals(other: Waypoint): boolean;
}
/**
 * A waypoint with custom defined lat/lon coordinates.
 */
declare class CustomWaypoint extends AbstractWaypoint {
    private readonly _location;
    private readonly _uid;
    /**
     * Constructor.
     * @param lat The latitude of this waypoint.
     * @param lon The longitude of this waypoint.
     * @param uidPrefix The prefix of this waypoint's UID.
     */
    constructor(lat: number, lon: number, uidPrefix: string);
    /**
     * Constructor.
     * @param location A subscribable which provides the location of this waypoint.
     * @param uid This waypoint's UID.
     */
    constructor(location: Subscribable<GeoPointInterface>, uid: string);
    /** @inheritdoc */
    get location(): Subscribable<GeoPointInterface>;
    /** @inheritdoc */
    get uid(): string;
    /** @inheritdoc */
    get type(): string;
}
/**
 * A waypoint associated with a facility.
 */
declare class FacilityWaypoint<T extends Facility = Facility> extends AbstractWaypoint {
    private readonly bus;
    private _facility;
    private readonly _location;
    private readonly _type;
    private facChangeSub?;
    /**
     * Constructor.
     * @param facility The facility associated with this waypoint.
     * @param bus The event bus.
     */
    constructor(facility: T, bus: EventBus);
    /** @inheritdoc */
    get location(): Subscribable<GeoPointInterface>;
    /** @inheritdoc */
    get uid(): string;
    /** @inheritdoc */
    get type(): string;
    /**
     * The facility associated with this waypoint.
     */
    get facility(): Subscribable<T>;
    /**
     * Gets a waypoint type from a facility.
     * @param facility A facility.
     * @returns The waypoint type corresponding to the facility.
     */
    private static getType;
}
/**
 * A flight path waypoint.
 */
declare class FlightPathWaypoint extends CustomWaypoint {
    static readonly UID_PREFIX = "FLPTH";
    /** The ident string of this waypoint. */
    readonly ident: string;
    /** @inheritdoc */
    get type(): string;
    /**
     * Constructor.
     * @param lat The latitude of this waypoint.
     * @param lon The longitude of this waypoint.
     * @param ident The ident string of this waypoint.
     */
    constructor(lat: number, lon: number, ident: string);
    /**
     * Constructor.
     * @param location A subscribable which provides the location of this waypoint.
     * @param uid This waypoint's UID.
     * @param ident The ident string of this waypoint.
     */
    constructor(location: Subscribable<GeoPointInterface>, uid: string, ident: string);
}
/**
 * A VNAV TOD/BOD waypoint.
 */
declare class VNavWaypoint extends AbstractWaypoint {
    private static readonly uidMap;
    private static readonly vec3Cache;
    private static readonly geoPointCache;
    private static readonly geoCircleCache;
    private readonly _location;
    private readonly _uid;
    /** @inheritdoc */
    get type(): string;
    /**
     * Constructor.
     * @param leg The leg that the VNAV waypoint is contained in.
     * @param distanceFromEnd The distance along the flight path from the end of the leg to the location of the waypoint,
     * in meters.
     * @param type The type of VNAV leg.
     */
    constructor(leg: LegDefinition, distanceFromEnd: number, type: 'tod' | 'bod');
    /**
     * Gets the waypoint's location in space.
     * @param leg The leg that the waypoint resides in.
     * @param distanceFromEnd The distance along the flight path from the end of the leg to the location of the waypoint,
     * in meters.
     * @returns The waypoint's location.
     */
    private getWaypointLocation;
    /** @inheritdoc */
    get location(): Subscribable<GeoPointInterface>;
    /** @inheritdoc */
    get uid(): string;
}

/**
 * A cache of facility waypoints.
 */
interface FacilityWaypointCache {
    /**
     * Gets a waypoint from the cache for a specific facility. If one does not exist, a new waypoint will be created.
     * @param facility The facility for which to get a waypoint.
     * @returns A waypoint.
     */
    get<T extends Facility>(facility: Facility): FacilityWaypoint<T>;
}

/**
 * A default implementation of {@link FacilityWaypointCache}.
 */
declare class DefaultFacilityWaypointCache implements FacilityWaypointCache {
    private readonly bus;
    readonly size: number;
    private static INSTANCE;
    private readonly cache;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param size The maximum size of this cache.
     */
    private constructor();
    /** @inheritdoc */
    get<T extends Facility>(facility: Facility): FacilityWaypoint<T>;
    /**
     * Adds a waypoint to this cache. If the size of the cache is greater than the maximum after the new waypoint is
     * added, a waypoint will be removed from the cache in FIFO order.
     * @param facility The facility associated with the waypoint to add.
     * @param waypoint The waypoint to add.
     */
    private addToCache;
    /**
     * Gets a FacilityWaypointCache instance.
     * @param bus The event bus.
     * @returns A FacilityWaypointCache instance.
     */
    static getCache(bus: EventBus): FacilityWaypointCache;
}

/**
 * A cache for LodBoundary objects.
 */
declare class DefaultLodBoundaryCache {
    static readonly SIZE = 500;
    static readonly DISTANCE_THRESHOLDS: readonly number[];
    static readonly VECTOR_COUNT_TARGETS: readonly number[];
    private static INSTANCE?;
    /**
     * Gets an instance of DefaultLodBoundaryCache.
     * @returns An instance of DefaultLodBoundaryCache.
     */
    static getCache(): LodBoundaryCache;
}

/**
 * A flight path vector turn direction.
 */
declare type VectorTurnDirection = 'left' | 'right';
/**
 * The transition type to which a flight path vector belongs.
 */
declare enum FlightPathVectorFlags {
    None = 0,
    /** A turn to a specific course. */
    TurnToCourse = 1,
    /** An arcing turn to a specific point. */
    Arc = 2,
    /** A direct course to a specific point. */
    Direct = 4,
    /** A path to intercept a specific course. */
    InterceptCourse = 8,
    /** Inbound leg of a hold. */
    HoldInboundLeg = 16,
    /** Outbound leg of a hold. */
    HoldOutboundLeg = 32,
    /** A direct hold entry. */
    HoldDirectEntry = 64,
    /** A teardrop hold entry. */
    HoldTeardropEntry = 128,
    /** A parallel hold entry. */
    HoldParallelEntry = 256,
    /** A course reversal. */
    CourseReversal = 512,
    /** A turn from one leg to another. */
    LegToLegTurn = 1024,
    /** An anticipated turn from one leg to another. */
    AnticipatedTurn = 2048,
    /** A fallback path. */
    Fallback = 4096
}
/**
 * A basic flight path vector.
 */
interface BaseFlightPathVector {
    /** The type of vector. */
    vectorType: string;
    /** Bit flags describing the vector. */
    flags: number;
    /** The latitude of the start of the vector. */
    startLat: number;
    /** The longitude of the start of the vector. */
    startLon: number;
    /** The latitude of the end of the vector. */
    endLat: number;
    /** The longitude of the end of the vector. */
    endLon: number;
    /** The total distance of the vector, in meters. */
    distance: number;
}
/**
 * A flight path vector whose path is defined by a geo circle.
 */
interface CircleVector extends BaseFlightPathVector {
    /** The type of vector. */
    vectorType: 'circle';
    /** The radius of the circle, in great-arc radians. */
    radius: number;
    /** The x-coordinate of the center of the circle. */
    centerX: number;
    /** The y-coordinate of the center of the circle. */
    centerY: number;
    /** The z-coordinate of the center of the circle. */
    centerZ: number;
}
/**
 * A flight path vector within a leg flight path calculation.
 */
declare type FlightPathVector = CircleVector;
/**
 * The details of procedures selected in the flight plan.
 */
declare class ProcedureDetails {
    /** The origin runway object, consisting of the index of the origin runway
     * in the origin runway information and the direction */
    originRunway: OneWayRunway | undefined;
    /** The ICAO for the facility associated with the departure procedure. */
    departureFacilityIcao: string | undefined;
    /** The index of the departure in the origin airport information. */
    departureIndex: number;
    /** The index of the departure transition in the origin airport departure information. */
    departureTransitionIndex: number;
    /** The index of the selected runway in the original airport departure information. */
    departureRunwayIndex: number;
    /** The ICAO for the facility associated with the arrival procedure. */
    arrivalFacilityIcao: string | undefined;
    /** The index of the arrival in the destination airport information. */
    arrivalIndex: number;
    /** The index of the arrival transition in the destination airport arrival information. */
    arrivalTransitionIndex: number;
    /** The index of the selected runway transition at the destination airport arrival information. */
    arrivalRunwayTransitionIndex: number;
    /** The ICAO for the facility associated with the approach procedure. */
    approachFacilityIcao: string | undefined;
    /** The index of the apporach in the destination airport information.*/
    approachIndex: number;
    /** The index of the approach transition in the destination airport approach information.*/
    approachTransitionIndex: number;
    /**
     * The destination runway object, consisting of the index of the destination runway
     * in the destination runway information and the direction
     */
    destinationRunway: OneWayRunway | undefined;
}
/**
 * A prototype for signalling application-specific type metadata for plan segments.
 */
declare enum FlightPlanSegmentType {
    Origin = "Origin",
    Departure = "Departure",
    Enroute = "Enroute",
    Arrival = "Arrival",
    Approach = "Approach",
    Destination = "Destination",
    MissedApproach = "MissedApproach",
    RandomDirectTo = "RandomDirectTo"
}
/**
 * A segment of a flight plan.
 */
declare class FlightPlanSegment {
    segmentIndex: number;
    offset: number;
    legs: LegDefinition[];
    segmentType: FlightPlanSegmentType;
    airway?: string | undefined;
    /**
     * Creates a new FlightPlanSegment.
     * @param segmentIndex The index of the segment within the flight plan.
     * @param offset The leg offset within the original flight plan that
     * the segment starts at.
     * @param legs The legs in the flight plan segment.
     * @param segmentType The type of segment this is.
     * @param airway The airway associated with this segment, if any.
     */
    constructor(segmentIndex: number, offset: number, legs: LegDefinition[], segmentType?: FlightPlanSegmentType, airway?: string | undefined);
    /** An empty flight plan segment. */
    static Empty: FlightPlanSegment;
}
/**
 * Metadata about a particular flight plan leg.
 */
interface LegCalculations {
    /** The initial DTK of the leg. */
    initialDtk: number | undefined;
    /** The leg's total distance in meters, not cut short by ingress/egress turn radii. */
    distance: number;
    /** The cumulative distance in meters up to this point in the flight plan. */
    cumulativeDistance: number;
    /** The leg's total distance in meters, with leg transition turns take into account. */
    distanceWithTransitions: number;
    /** The cumulative distance in meters up to this point, with leg transition turns taken into account. */
    cumulativeDistanceWithTransitions: number;
    /** The latitude of the start of the leg. */
    startLat: number | undefined;
    /** The longitude of the start of the leg. */
    startLon: number | undefined;
    /** The latitude of the end of the leg. */
    endLat: number | undefined;
    /** The longitude of the end of the leg. */
    endLon: number | undefined;
    /** The calculated flight path for the leg. */
    flightPath: FlightPathVector[];
    /** The leg's flight path ingress transition. */
    ingress: FlightPathVector[];
    /** The index of the flight path vector in `flightPath` to which the ingress transition is joined. */
    ingressJoinIndex: number;
    /** The leg's flight path between the ingress and egress transitions. */
    ingressToEgress: FlightPathVector[];
    /** The index of the flight path vector in `flightPath` to which the egress transition is joined. */
    egressJoinIndex: number;
    /** The leg's flight path egress transition. */
    egress: FlightPathVector[];
    /** Whether the leg's flight path ends in a fallback state. */
    endsInFallback: boolean;
}
/**
 * Bitflags describing a leg definition.
 */
declare enum LegDefinitionFlags {
    None = 0,
    DirectTo = 1,
    MissedApproach = 2,
    Obs = 4,
    VectorsToFinal = 8
}
/**
 * Vertical metadata about a flight plan leg.
 */
interface VerticalData {
    /** The type of altitude restriction for the leg. */
    altDesc: AltitudeRestrictionType;
    /** The first altitude field for restrictions. */
    altitude1: number;
    /** The second altitude field for restrictions. */
    altitude2: number;
    /** The optional speed restriction for this leg. */
    speed?: number;
    /** The speed type/unit. */
    speedDesc?: SpeedType;
    /** The FPA for this constraint, optional. */
    fpa?: number;
}
declare enum SpeedType {
    IAS = 0,
    MACH = 1
}
/**
 * A definition of a leg in a flight plan.
 */
interface LegDefinition {
    /** The display name of the leg. */
    readonly name?: string;
    /** The calculated leg data. */
    calculated?: LegCalculations;
    /** The leg of the flight plan. */
    leg: Readonly<FlightPlanLeg>;
    /** Leg definition flags. */
    readonly flags: number;
    /** Vertical Leg Data. All the fields should be readonly except for calculated fields like `fpa`. */
    readonly verticalData: Readonly<VerticalData> & Pick<VerticalData, 'fpa'>;
}

/**
 * Builds circle vectors.
 */
declare class CircleVectorBuilder {
    private static readonly geoCircleCache;
    /**
     * Builds a circle vector and adds it to a sequence.
     * @param vectors The flight path vector sequence to which to add the vector.
     * @param index The index in the sequence at which to add the vector.
     * @param direction The direction of the circle.
     * @param radius The radius of the circle, in meters.
     * @param center The center of the circle.
     * @param start The start point.
     * @param end The end point.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The number of vectors added to the sequence, which is always equal to 1.
     */
    build(vectors: FlightPathVector[], index: number, direction: VectorTurnDirection, radius: number, center: ReadonlyFloat64Array | LatLonInterface, start: ReadonlyFloat64Array | LatLonInterface, end: ReadonlyFloat64Array | LatLonInterface, flags?: number): 1;
    /**
     * Builds a circle vector and adds it to a sequence.
     * @param vectors The flight path vector sequence to which to add the vector.
     * @param index The index in the sequence at which to add the vector.
     * @param circle The circle which defines the vector path.
     * @param start The start point.
     * @param end The end point.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The number of vectors added to the sequence, which is always equal to 1.
     */
    build(vectors: FlightPathVector[], index: number, circle: GeoCircle, start: ReadonlyFloat64Array | LatLonInterface, end: ReadonlyFloat64Array | LatLonInterface, flags?: number): 1;
    /**
     * Sets the parameters for a circle vector in a flight path vector sequence. If a circle vector does not exist at the
     * specified index in the sequence, a new one will be created.
     * @param vectors A flight path vector sequence.
     * @param index The index in the sequence at which to set the circle vector.
     * @param direction The direction of the circle.
     * @param radius The radius of the circle, in meters.
     * @param center The center of the circle.
     * @param start The start point.
     * @param end The end point.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The set circle vector.
     */
    private setFromPoints;
    /**
     * Sets the parameters for a circle vector in a flight path vector sequence. If a circle vector does not exist at the
     * specified index in the sequence, a new one will be created.
     * @param vectors A flight path vector sequence.
     * @param index The index in the sequence at which to set the circle vector.
     * @param circle The circle which defines the vector path.
     * @param start The start point.
     * @param end The end point.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The set circle vector.
     */
    private setFromCircle;
}
/**
 * Builds great-circle paths between defined start and end points.
 */
declare class GreatCircleBuilder {
    private static readonly vec3Cache;
    private static readonly geoPointCache;
    private static readonly geoCircleCache;
    private readonly circleVectorBuilder;
    /**
     * Builds a sequence of vectors representing a great-circle path between two points. The great circle path chosen is
     * the shortest great-circle path between the two points.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param end The end point.
     * @param initialCourse The initial true course bearing. Used to define a unique great-circle path when `start` and
     * `end` are antipodal.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @throws Error if `start` and `end` are antipodal and `initialCourse` is undefined.
     */
    build(vectors: FlightPathVector[], index: number, start: ReadonlyFloat64Array | LatLonInterface, end: ReadonlyFloat64Array | LatLonInterface, initialCourse?: number, flags?: number): number;
    /**
     * Builds a sequence of vectors representing a great-circle path between two points.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param path The great-circle path.
     * @param end The end point.
     * @param flags The flags to set on the vector. Defaults to none (0).
     */
    build(vectors: FlightPathVector[], index: number, start: ReadonlyFloat64Array | LatLonInterface, path: GeoCircle, end: ReadonlyFloat64Array | LatLonInterface, flags?: number): number;
    /**
     * Builds a sequence of vectors representing a great-circle path between two points. The end point is chosen such
     * that it is offset from the start point by a specified distance.
     * @param vectors
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param path The great-circle path.
     * @param distance The distance along the path between the start and end points, in meters.
     * @param flags The flags to set on the vector. Defaults to none (0).
     */
    build(vectors: FlightPathVector[], index: number, start: ReadonlyFloat64Array | LatLonInterface, path: GeoCircle, distance: number, flags?: number): number;
    /**
     * Builds a sequence of vectors representing the shortest great-circle path between two points.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param end The end point.
     * @param initialCourse The initial true course bearing. Used to define a unique great-circle path when `start` and
     * `end` are antipodal.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The number of vectors added to the sequence.
     * @throws Error if `start` and `end` are antipodal and `initialCourse` is undefined.
     */
    private buildFromEndpoints;
    /**
     * Builds a sequence of vectors representing a great-circle path from a start point to either a defined endpoint
     * or a distance offset.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param path The great-circle path.
     * @param endArg The end point or distance offset.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The number of vectors added to the sequence.
     * @throws Error if `path` is not a great circle.
     */
    private buildFromPath;
}
/**
 * Builds constant-radius turns toward specified course bearings.
 */
declare class TurnToCourseBuilder {
    private static readonly geoPointCache;
    private readonly circleVectorBuilder;
    /**
     * Adds a turn from a defined start point and initial course to a specific final course to a flight path vector
     * sequence. If the difference between the initial and final course is small enough such that the start and end of
     * the turn are identical, no turn will be added to the vector sequence.
     * @param vectors The flight path vector sequence to which to add the turn.
     * @param index The index in the sequence at which to add the turn.
     * @param start The start point of the turn.
     * @param radius The radius of the turn, in meters.
     * @param direction The direction of the turn.
     * @param fromCourse The initial true course at the start of the turn.
     * @param toCourse The final true course at the end of the turn.
     * @param flags The flags to set on the turn vector. Defaults to the `TurnToCourse` flag.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors: FlightPathVector[], index: number, start: ReadonlyFloat64Array | LatLonInterface, radius: number, direction: VectorTurnDirection, fromCourse: number, toCourse: number, flags?: FlightPathVectorFlags): number;
}
/**
 * Builds great-circle paths to intercept other geo circles.
 */
declare class CircleInterceptBuilder {
    private static readonly geoCircleCache;
    private static readonly intersectionCache;
    private readonly greatCircleBuilder;
    private readonly circleVectorBuilder;
    /**
     * Builds a sequence of vectors representing a great-circle path from a defined start point to an intersection with
     * another geo circle.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param course The initial true course bearing.
     * @param circle The circle to intercept.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The number of vectors added to the sequence.
     */
    build(vectors: FlightPathVector[], index: number, start: ReadonlyFloat64Array | LatLonInterface, course: number, circle: GeoCircle, flags?: number): number;
    /**
     * Builds a sequence of vectors representing a path from a defined start point to an intersection with another geo
     * circle.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The initial path.
     * @param circle The circle to intercept.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The number of vectors added to the sequence.
     * @throws Error if `start` does not lie on `startPath`.
     */
    build(vectors: FlightPathVector[], index: number, start: ReadonlyFloat64Array | LatLonInterface, startPath: GeoCircle, circle: GeoCircle, flags?: number): number;
}
/**
 * Builds constant-radius turns to join great-circle paths.
 */
declare class TurnToJoinGreatCircleBuilder {
    private static readonly vec3Cache;
    private static readonly geoCircleCache;
    private readonly circleVectorBuilder;
    /**
     * Builds an arc representing a turn from a defined start point and initial course toward a defined target great-
     * circle path, ending at the point in the turn circle which is closest to the target path.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startCourse The initial true course bearing.
     * @param endPath The great-circle path defining the target course.
     * @param radius The radius of the turn, in meters.
     * @param flags The flags to set on the turn vector. Defaults to the `TurnToCourse` flag.
     * @returns The number of vectors added to the sequence, which is always equal to 1.
     * @throws Error if `endPath` is not a great circle.
     */
    build(vectors: FlightPathVector[], index: number, start: ReadonlyFloat64Array | LatLonInterface, startCourse: number, endPath: GeoCircle, radius: number, flags?: number): 1;
    /**
     * Builds an arc representing a turn from a defined start point and initial course toward a defined target great-
     * circle path, ending at the point in the turn circle which is closest to the target path.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param endPath The great-circle path defining the target course.
     * @param radius The radius of the turn, in meters.
     * @param flags The flags to set on the turn vector. Defaults to the `TurnToCourse` flag.
     * @returns The number of vectors added to the sequence, which is always equal to 1.
     * @throws Error if `startPath` or `endPath` is not a great circle, or if `start` does not lie on `startPath`.
     */
    build(vectors: FlightPathVector[], index: number, start: ReadonlyFloat64Array | LatLonInterface, startPath: GeoCircle, endPath: GeoCircle, radius: number, flags?: number): 1;
}
/**
 * Builds paths to connect two geo circles.
 */
declare class ConnectCirclesBuilder {
    private static readonly vec3Cache;
    private static readonly geoCircleCache;
    private static readonly intersectionCache;
    private readonly circleVectorBuilder;
    /**
     * Builds a sequence of vectors representing a path which consists of a single geo circle which connects two other
     * circles and optionally paths to link the connecting circle with a start point on the from circle and an end point
     * on the to circle.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param fromCircle The circle from which to add the connecting circle.
     * @param toCircle The circle to which to add the connecting circle.
     * @param radius The radius, in meters, of the circle to join the two circles. If not defined, defaults to pi / 2
     * times the radius of the Earth (and therefore the connecting circle will be a great circle).
     * @param from The starting point along `fromCircle`. If not defined, this will be assumed to be equal to the
     * point where the connecting circle meets `fromCircle`.
     * @param to The ending point along `toCircle`. If not defined, this will be assumed to be equal to the point where
     * the connecting circle meets `toCircle`.
     * @param fromCircleVectorFlags The flags to set on the vector along `fromCircle`. Defaults to none (0).
     * @param toCircleVectorFlags The flags to set on the vector along the `toCircle`. Defaults to none (0).
     * @param connectVectorFlags The flags to set on the vector connecting `fromCircle` to `toCircle`. Defaults to none
     * (0).
     * @returns The number of vectors added to the sequence.
     */
    build(vectors: FlightPathVector[], index: number, fromCircle: GeoCircle, toCircle: GeoCircle, radius?: number, from?: ReadonlyFloat64Array | LatLonInterface, to?: ReadonlyFloat64Array | LatLonInterface, fromCircleVectorFlags?: number, toCircleVectorFlags?: number, connectVectorFlags?: number): number;
    /**
     * Finds a GeoCircle which connects (is tangent to) two other circles.
     * @param fromCircle The circle at the beginning of the connecting circle.
     * @param toCircle The circle at the end of the connecting circle.
     * @param radius The desired radius of the connecting circle, in great-arc radians.
     * @param out A GeoCircle object to which to write the result.
     * @param from The starting point along `fromCircle`. If not defined, this will be assumed to be equal to the
     * point where the connecting circle meets `fromCircle`.
     * @param to The ending point along `toCircle`. If not defined, this will be assumed to be equal to the point where
     * the connecting circle meets `toCircle`.
     * @returns a GeoCircle which connects the two circles, or null if one could not be found.
     */
    private findCircleToJoinCircles;
    /**
     * Calculates the total distance along the joining path between two circles.
     * @param fromCircle The circle at the beginning of the connecting circle.
     * @param toCircle The circle at the end of the connecting circle.
     * @param joinCircle The connecting circle.
     * @param from The starting point along `fromCircle`. If not defined, this will be assumed to be equal to the
     * point where the connecting circle meets `fromCircle`.
     * @param to The ending point along `toCircle`. If not defined, this will be assumed to be equal to the point where
     * the connecting circle meets `toCircle`.
     * @returns the total distance along the joining path, in great-arc radians.
     */
    private calculateJoinCirclesPathDistance;
}
/**
 * Builds paths connecting initial great circle paths to final great circle paths via a turn starting at the start
 * point and a turn ending at the end point, connected by a great-circle path.
 */
declare class TurnToJoinGreatCircleAtPointBuilder {
    private static readonly vec3Cache;
    private static readonly geoCircleCache;
    private readonly connectCirclesBuilder;
    /**
     * Builds a sequence of vectors representing a path from a defined start point and initial course which turns and
     * connects with another turn via a great-circle path to terminate at a defined end point and final course.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param startTurnRadius The radius of the initial turn, in meters.
     * @param startTurnDirection The direction of the initial turn.
     * @param end The end point.
     * @param endPath The great-circle path defining the final course.
     * @param endTurnRadius The radius of the final turn, in meters.
     * @param endTurnDirection The direction of the final turn.
     * @param startTurnVectorFlags The flags to set on the initial turn vector. Defaults to none (0).
     * @param endTurnVectorFlags The flags to set on the final turn vector. Defaults to none (0).
     * @param connectVectorFlags The flags to set on the vector along the great-circle path connecting the turns.
     * Defaults to none (0).
     * @returns The number of vectors added to the sequence.
     */
    build(vectors: FlightPathVector[], index: number, start: ReadonlyFloat64Array | LatLonInterface, startPath: GeoCircle, startTurnRadius: number, startTurnDirection: VectorTurnDirection, end: ReadonlyFloat64Array | LatLonInterface, endPath: GeoCircle, endTurnRadius: number, endTurnDirection: VectorTurnDirection, startTurnVectorFlags?: number, endTurnVectorFlags?: number, connectVectorFlags?: number): number;
}
/**
 * Builds paths connecting initial great-circle paths to final great-circle paths via a turn starting at the start
 * point followed by an angled intercept path which intercepts the final path before the end point.
 */
declare class InterceptGreatCircleToPointBuilder {
    private static readonly vec3Cache;
    private static readonly geoCircleCache;
    private static readonly intersectionCache;
    private readonly circleVectorBuilder;
    private readonly turnToJoinGreatCircleBuilder;
    /**
     * Builds a sequence of vectors representing a path from a defined start point and initial course which turns and
     * intercepts a final course at a specified angle using a great-circle path. Optionally includes a final turn from
     * the intercept path to the final course.
     *
     * If an intercept angle greater than the minimum angle is required to intercept the final course before the end
     * point, no vectors will be calculated.
     *
     * If the initial and final courses are parallel, no vectors will be calculated.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param startTurnRadius The radius of the initial turn, in meters.
     * @param startTurnDirection The direction of the initial turn. If not defined, the direction of the initial turn
     * will be automatically selected.
     * @param interceptAngle The angle at which to intercept the final path, in degrees. Will be clamped to the range
     * `[0, 90]`.
     * @param end The end point.
     * @param endPath The great-circle path defining the final course.
     * @param endTurnRadius The radius of the final turn, in meters, or `undefined` if a turn to join the final path
     * should not be calculated.
     * @param startTurnVectorFlags The flags to set on the initial turn vector. Defaults to none (0).
     * @param interceptVectorFlags The flags to set on the vector along the intercept path. Defaults to none (0).
     * @param endTurnVectorFlags The flags to set on the final turn vector. Defaults to none (0). Ignored if a turn to
     * join the final path is not calculated.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors: FlightPathVector[], index: number, start: ReadonlyFloat64Array | LatLonInterface, startPath: GeoCircle, startTurnRadius: number, startTurnDirection: VectorTurnDirection | undefined, interceptAngle: number, end: ReadonlyFloat64Array | LatLonInterface, endPath: GeoCircle, endTurnRadius?: number, startTurnVectorFlags?: number, interceptVectorFlags?: number, endTurnVectorFlags?: number): number;
}
/**
 * Builds paths connecting initial great-circle paths to final great-circle paths terminating at defined end points.
 */
declare class JoinGreatCircleToPointBuilder {
    private static readonly INTERCEPT_ANGLE;
    private static readonly vec3Cache;
    private static readonly geoCircleCache;
    private static readonly intersectionCache;
    private readonly circleVectorBuilder;
    private readonly greatCircleBuilder;
    private readonly turnToJoinGreatCircleBuilder;
    private readonly interceptGreatCircleToPointBuilder;
    private readonly directToPointBuilder;
    /**
     * Builds a sequence of vectors representing a path from a defined start point and initial course which turns and
     * joins a great-circle path which terminates at a defined end point.
     *
     * This method will first attempt to connect the starting point and final path with a single constant-radius turn
     * of at least the minimum turn radius and in the desired direction that joins the final path before the end point.
     * If this is not possible, then what happens next depends on the `preferSingleTurn` argument:
     * * If it is `true`, then another path connecting the starting point and final path with a single constant-radius
     * turn will be computed - this path will respect the minimum turn radius but not necessarily the desired turn
     * direction.
     * * If it is `false`, then a path to intercept the final path at a 45-degree angle will be computed. If such a path
     * is not possible or if the intercept point lies after the end point, and `allowDirectFallback` is `true`, a direct
     * course to the end point will be computed. If `allowDirectFallback` is `false` and all attempts to compute a path
     * have failed, then no vectors will be built.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param end The end point.
     * @param endPath The great-circle path defining the final course.
     * @param desiredTurnDirection The desired initial turn direction. If not defined, the most efficient turn direction
     * that satisfies the constraints will be chosen.
     * @param minTurnRadius The minimum turn radius, in meters. Defaults to 0.
     * @param preferSingleTurn Whether to prefer flight path solutions that consist of a single constant-radius turn
     * from the initial to final course. Defaults to `false`.
     * @param allowDirectFallback Whether the computed path should fall back to a direct course to the end point if the
     * final path cannot be joined before the end point. Defaults to `true`.
     * @param intersection The point of intersection between the start and end paths closest to the start point. If
     * not defined, it will be calculated.
     * @param flags The flags to set on the vectors. Defaults to none (0).
     * @param includeTurnToCourseFlag Whether to include the `TurnToCourse` flag on the turn vectors. True by default.
     * @param includeDirectFlag Whether to include the `Direct` flag on vectors when falling back to a direct course.
     * Defaults to `true`.
     * @param includeInterceptFlag Whether to include the `InterceptCourse` flag on vectors when building an intercept
     * path. Defaults to `true`.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors: FlightPathVector[], index: number, start: ReadonlyFloat64Array | LatLonInterface, startPath: GeoCircle, end: ReadonlyFloat64Array | LatLonInterface, endPath: GeoCircle, desiredTurnDirection?: VectorTurnDirection, minTurnRadius?: number, preferSingleTurn?: boolean, allowDirectFallback?: boolean, intersection?: ReadonlyFloat64Array, flags?: number, includeTurnToCourseFlag?: boolean, includeDirectFlag?: boolean, includeInterceptFlag?: boolean): number;
}
/**
 * Builds procedure turns.
 */
declare class ProcedureTurnBuilder {
    private static readonly vec3Cache;
    private static readonly geoPointCache;
    private static readonly geoCircleCache;
    private static readonly intersectionCache;
    private readonly greatCircleBuilder;
    private readonly circleVectorBuilder;
    /**
     * Builds a sequence of vectors representing a procedure turn from a defined starting point and initial course to a
     * defined end point and final course. A procedure turn begins with a variable-length leg from the start point along
     * the initial course followed by an initial turn to intercept the outbound leg of the procedure turn, then a
     * variable-length outbound leg, a 180-degree turn, a variable-length inbound leg, and finally a turn to intercept
     * the final course at the end point. If a full set of vectors cannot be computed given the restraints imposed by the
     * path geometry and the desired turn radius, parts of the turn beginning with the inbound leg of the procedure turn
     * may be altered or omitted entirely.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param end The end point.
     * @param endPath The great-circle path defining the final course.
     * @param outboundCourse The true course, in degrees, of the outbound leg of the turn.
     * @param desiredTurnRadius The desired turn radius, in meters.
     * @param desiredTurnDirection The desired turn direction.
     * @param initialCourse The initial course. If not defined, it will be calculated from `startPath` and `start`.
     * @param finalCourse The final course. If not defined, it will be calculated from `endPath` and `end`.
     * @param flags The flags to set on the vectors. Defaults to the `CourseReversal` flag.
     * @param includeTurnToCourseFlag Whether to include the `TurnToCourse` flag on the turn vectors. True by default.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors: FlightPathVector[], index: number, start: ReadonlyFloat64Array | LatLonInterface, startPath: GeoCircle, end: ReadonlyFloat64Array | LatLonInterface, endPath: GeoCircle, outboundCourse: number, desiredTurnRadius: number, desiredTurnDirection?: VectorTurnDirection, initialCourse?: number, finalCourse?: number, flags?: FlightPathVectorFlags, includeTurnToCourseFlag?: boolean): number;
}
/**
 * Builds paths directly connecting a defined initial point and course and a defined end point.
 */
declare class DirectToPointBuilder {
    private static readonly vec3Cache;
    private static readonly geoPointCache;
    private static readonly geoCircleCache;
    private readonly circleVectorBuilder;
    private readonly greatCircleBuilder;
    /**
     * Builds a sequence of vectors representing a path which consists of an optional turn from an initial point and
     * course toward an end point followed by an optional great-circle path terminating at the end point.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startCourse The initial course.
     * @param end The end point.
     * @param desiredTurnRadius The desired turn radius, in meters.
     * @param desiredTurnDirection The desired turn direction. If undefined, a turn direction will be chosen such that
     * the initial turn is always toward the end point.
     * @param flags The flags to set on the vectors. Defaults to none (0).
     * @param includeTurnToCourseFlag Whether to include the `TurnToCourse` flag on the turn vectors. Defaults to `true`.
     * @param includeDirectFlag Whether to include the `Direct` flag on the vectors. Defaults to `true`.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors: FlightPathVector[], index: number, start: ReadonlyFloat64Array | LatLonInterface, startCourse: number, end: ReadonlyFloat64Array | LatLonInterface, desiredTurnRadius: number, desiredTurnDirection?: VectorTurnDirection, flags?: number, includeTurnToCourseFlag?: boolean, includeDirectFlag?: boolean): number;
    /**
     * Builds a sequence of vectors representing a path which consists of an optional turn from an initial point and
     * course toward an end point followed by an optional great-circle path terminating at the end point.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param end The end point.
     * @param desiredTurnRadius The desired turn radius, in meters.
     * @param desiredTurnDirection The desired turn direction. If undefined, a turn direction will be chosen such that
     * the initial turn is always toward the end point.
     * @param flags The flags to set on the vectors. Defaults to none (0).
     * @param includeTurnToCourseFlag Whether to include the `TurnToCourse` flag on the turn vectors. Defaults to `true`.
     * @param includeDirectFlag Whether to include the `Direct` flag on the vectors. Defaults to `true`.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors: FlightPathVector[], index: number, start: ReadonlyFloat64Array | LatLonInterface, startPath: GeoCircle, end: ReadonlyFloat64Array | LatLonInterface, desiredTurnRadius: number, desiredTurnDirection?: VectorTurnDirection, flags?: number, includeTurnToCourseFlag?: boolean, includeDirectFlag?: boolean): number;
}

/**
 * The state of a calculating flight path.
 */
interface FlightPathState {
    /** The current position of the flight path. */
    currentPosition: GeoPoint | undefined;
    /** The current true course bearing of the flight path. */
    currentCourse: number | undefined;
    /** Whether the flight path is in a fallback state. */
    isFallback: boolean;
    /** The position of the airplane. */
    readonly planePosition: GeoPointReadOnly;
    /** The true heading of the airplane. */
    readonly planeHeading: number;
    /** The altitude of the airplane. */
    readonly planeAltitude: NumberUnitReadOnly<UnitFamily.Distance>;
    /** The ground speed of the airplane. */
    readonly planeSpeed: NumberUnitReadOnly<UnitFamily.Speed>;
    /** The climb rate of the airplane. */
    readonly planeClimbRate: NumberUnitReadOnly<UnitFamily.Speed>;
    /** The desired turn radius. */
    readonly desiredTurnRadius: NumberUnitReadOnly<UnitFamily.Distance>;
}
/**
 * A flight path calculator for individual flight plan legs.
 */
interface FlightPathLegCalculator {
    /**
     * Calculates flight path vectors for a flight plan leg and adds the calculations to the leg.
     * @param legs A sequence of flight plan legs.
     * @param calculateIndex The index of the leg to calculate.
     * @param activeLegIndex The index of the active leg.
     * @param state The current flight path state.
     * @returns The flight plan leg calculations.
     */
    calculate(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState, resolveIngressToEgress?: boolean): LegCalculations;
}
/**
 * Abstract implementation of FlightPathLegCalculator.
 */
declare abstract class AbstractFlightPathLegCalculator implements FlightPathLegCalculator {
    protected readonly facilityCache: Map<string, Facility>;
    protected readonly skipWhenActive: boolean;
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     * @param skipWhenActive Whether this calculator will skip calculations for active legs when the leg has already
     * been calculated. False by default.
     */
    constructor(facilityCache: Map<string, Facility>, skipWhenActive?: boolean);
    /**
     * Gets a geographical position from an ICAO string.
     * @param icao An ICAO string.
     * @param out A GeoPoint object to which to write the result.
     * @returns The geographical position corresponding to the ICAO string, or undefined if one could not be obtained.
     */
    protected getPositionFromIcao(icao: string, out: GeoPoint): GeoPoint | undefined;
    /**
     * Gets the geographic position for a flight plan leg terminator.
     * @param leg A flight plan leg.
     * @param icao The ICAO string of the leg's terminator fix.
     * @param out A GeoPoint object to which to write the result.
     * @returns The position of the leg terminator, or undefined if it could not be determined.
     */
    protected getTerminatorPosition(leg: FlightPlanLeg, icao: string, out: GeoPoint): GeoPoint | undefined;
    /**
     * Gets the true course for a flight plan leg. If the leg defines an origin or fix VOR facility, then the magnetic
     * variation defined at the VOR is used to adjust magnetic course, otherwise the computed magnetic variation for the
     * specified point is used.
     * @param leg A flight plan leg.
     * @param point The location from which to get magnetic variation, if an origin VOR is not found.
     * @returns the true course for the flight plan leg.
     */
    protected getLegTrueCourse(leg: FlightPlanLeg, point: LatLonInterface): number;
    /** @inheritdoc */
    calculate(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState, resolveIngressToEgress?: boolean): LegCalculations;
    /**
     * Checks whether vector calculations should be skipped when the leg to calculate is the active leg.
     * @param legs A sequence of flight plan legs.
     * @param calculateIndex The index of the leg to calculate.
     * @param activeLegIndex The index of the active leg.
     * @param state The current flight path state.
     * @returns Whether to skip vector calculations.
     */
    protected shouldSkipWhenActive(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState): boolean;
    /**
     * Calculates flight path vectors for a flight plan leg.
     * @param legs A sequence of flight plan legs.
     * @param calculateIndex The index of the leg to calculate.
     * @param activeLegIndex The index of the active leg.
     * @param state The current flight path state.
     * @returns The number of vectors added to the sequence.
     */
    protected abstract calculateVectors(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState): void;
    /**
     * Calculates the ingress to egress vectors for a flight plan leg and adds them to a leg calculation.
     * @param legCalc The calculations for a flight plan leg.
     */
    protected resolveIngressToEgress(legCalc: LegCalculations): void;
}
/**
 * Calculates flight path vectors for discontinuity legs.
 */
declare class DiscontinuityLegCalculator extends AbstractFlightPathLegCalculator {
    /** @inheritdoc */
    protected calculateVectors(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState): void;
}
/**
 * Calculates flight path vectors for track to fix legs.
 */
declare class TrackToFixLegCalculator extends AbstractFlightPathLegCalculator {
    private readonly geoPointCache;
    private readonly greatCircleBuilder;
    private readonly directToPointBuilder;
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache: Map<string, Facility>);
    /** @inheritdoc */
    protected calculateVectors(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState): void;
}
/**
 * Calculates flight path vectors for direct to fix legs.
 */
declare class DirectToFixLegCalculator extends AbstractFlightPathLegCalculator {
    protected readonly vec3Cache: Float64Array[];
    protected readonly geoPointCache: GeoPoint[];
    protected readonly geoCircleCache: GeoCircle[];
    protected readonly directToPointBuilder: DirectToPointBuilder;
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache: Map<string, Facility>);
    /** @inheritdoc */
    protected calculateVectors(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState): void;
}
/**
 * Calculates flight path vectors for legs which define a turn ending at a defined terminator fix.
 */
declare abstract class TurnToFixLegCalculator extends AbstractFlightPathLegCalculator {
    protected readonly vec3Cache: Float64Array[];
    protected readonly geoPointCache: GeoPoint[];
    protected readonly geoCircleCache: GeoCircle[];
    protected readonly circleVectorBuilder: CircleVectorBuilder;
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache: Map<string, Facility>);
    /** @inheritdoc */
    protected calculateVectors(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState): void;
    /**
     * Gets the center of the turn defined by a flight plan leg.
     * @param leg A flight plan leg.
     * @returns The center of the turn defined by the flight plan leg, or undefined if it could not be determined.
     */
    protected abstract getTurnCenter(leg: FlightPlanLeg): LatLonInterface | undefined;
    /**
     * Gets the radius of the turn defined by a flight plan leg.
     * @param leg A flight plan leg.
     * @param center The center of the turn.
     * @returns The radius of the turn defined by the flight plan leg, or undefined if it could not be determined.
     */
    protected abstract getTurnRadius(leg: FlightPlanLeg, center: LatLonInterface): number | undefined;
}
/**
 * Calculates flight path vectors for radius to fix legs.
 */
declare class RadiusToFixLegCalculator extends TurnToFixLegCalculator {
    protected readonly geoPointCache: GeoPoint[];
    /** @inheritdoc */
    protected getTurnCenter(leg: FlightPlanLeg): LatLonInterface | undefined;
    /** @inheritdoc */
    protected getTurnRadius(leg: FlightPlanLeg, center: LatLonInterface): number | undefined;
}
/**
 * Calculates flight path vectors for arc to fix legs.
 */
declare class ArcToFixLegCalculator extends TurnToFixLegCalculator {
    /** @inheritdoc */
    protected getTurnCenter(leg: FlightPlanLeg): LatLonInterface | undefined;
    /** @inheritdoc */
    protected getTurnRadius(leg: FlightPlanLeg, center: LatLonInterface): number | undefined;
}
/**
 * Information about a geo circle path to intercept.
 */
declare type CircleInterceptPathInfo = {
    /** The geo circle defining the path to intercept. */
    circle: GeoCircle | undefined;
    /** The start of the path to intercept. */
    start: LatLonInterface | undefined;
    /** The end of the path to intercept. */
    end: LatLonInterface | undefined;
};
/**
 * Calculates flight path vectors for legs which define a great-circle path terminating at an intercept with another
 * geo circle.
 */
declare abstract class CircleInterceptLegCalculator extends AbstractFlightPathLegCalculator {
    protected readonly includeInitialTurn: boolean;
    private readonly vec3Cache;
    private readonly geoPointCache;
    private readonly geoCircleCache;
    private readonly intersectionCache;
    private readonly turnBuilder;
    private readonly directToPointBuilder;
    private readonly interceptBuilder;
    private readonly interceptInfo;
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     * @param includeInitialTurn Whether this calculator should calculate an initial turn toward the intercept course.
     */
    constructor(facilityCache: Map<string, Facility>, includeInitialTurn: boolean);
    /** @inheritdoc */
    protected calculateVectors(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState): void;
    private readonly handleInvalidInterceptCache;
    /**
     * Checks if a path to intercept cannot be intercepted from a defined starting point and intercept course, and
     * calculates a fallback intercept point if so.
     * @param start The start point.
     * @param interceptPath The great-circle path defining the intercept course.
     * @param pathToInterceptCircle The geo circle defining the path to intercept.
     * @param pathToInterceptStart The start of the path to intercept.
     * @param pathToInterceptEnd The end of the path to intercept.
     * @param pathToInterceptAngularWidth The angular width of the path to intercept, in radians.
     * @param onlyHandleInitialPointPastIntercept Whether to only handle cases where the start point is located beyond
     * the path to intercept as measured along the intercept course.
     * @param forceFallback Whether to treat the case where the path to intercept can be intercepted from the starting
     * point and intercept course as a fallback case. If `true`, the natural intercept point will be returned as the
     * fallback intercept point.
     * @param out The vector to which to write the result.
     * @returns The fallback intercept point, or `undefined` if a fallback is not necessary.
     */
    private calculateFallbackIntercept;
    /**
     * Gets the true intercept course bearing defined by a flight plan leg.
     * @param legs A sequence of leg definitions.
     * @param index The index in the sequence of the leg from which to get the course.
     * @param state The current flight path state.
     * @returns The true intercept course bearing defined by the flight plan leg, or undefined if it could not be
     * determined.
     */
    protected abstract getInterceptCourse(legs: LegDefinition[], index: number, state: FlightPathState): number | undefined;
    /**
     * Gets the geo circle path to intercept defined by a flight plan leg.
     * @param legs A sequence of leg definitions.
     * @param index The index in the sequence of the leg from which to get the course.
     * @param state The current flight path state.
     * @param out The path info object to which to write the result.
     * @returns Information on the geo circle path to intercept defined by the flight plan leg.
     */
    protected abstract getInterceptPathInfo(legs: LegDefinition[], index: number, state: FlightPathState, out: CircleInterceptPathInfo): CircleInterceptPathInfo;
}
/**
 * Calculates flight path vectors for course to DME legs.
 */
declare class CourseToDmeLegCalculator extends CircleInterceptLegCalculator {
    private readonly dmeCircle;
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache: Map<string, Facility>);
    /** @inheritdoc */
    protected getInterceptCourse(legs: LegDefinition[], index: number): number | undefined;
    /** @inheritdoc */
    protected getInterceptPathInfo(legs: LegDefinition[], index: number, state: FlightPathState, out: CircleInterceptPathInfo): CircleInterceptPathInfo;
}
/**
 * Calculates flight path vectors for course to radial intercept legs.
 */
declare class CourseToRadialLegCalculator extends CircleInterceptLegCalculator {
    private readonly radialCircle;
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache: Map<string, Facility>);
    /** @inheritdoc */
    protected getInterceptCourse(legs: LegDefinition[], index: number): number | undefined;
    /** @inheritdoc */
    protected getInterceptPathInfo(legs: LegDefinition[], index: number, state: FlightPathState, out: CircleInterceptPathInfo): CircleInterceptPathInfo;
}
/**
 * Calculates flight path vectors for course to intercept legs.
 */
declare class CourseToInterceptLegCalculator extends CircleInterceptLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache: Map<string, Facility>);
    /** @inheritdoc */
    protected getInterceptCourse(legs: LegDefinition[], index: number, state: FlightPathState): number | undefined;
    /** @inheritdoc */
    protected getInterceptPathInfo(legs: LegDefinition[], index: number, state: FlightPathState, out: CircleInterceptPathInfo): CircleInterceptPathInfo;
    private readonly predictLegPathCache;
    /**
     * Predicts the path of a leg. If a prediction cannot be made, NaN will be written to all fields of the result.
     * @param legs A leg sequence.
     * @param index The index of the leg in the sequence.
     * @param out A GeoCircle to which to write the result.
     * @returns the predicted path of the leg.
     */
    private predictLegPath;
}
/**
 * Calculates flight path vectors for fix to DME legs.
 */
declare class FixToDmeLegCalculator extends AbstractFlightPathLegCalculator {
    private readonly vec3Cache;
    private readonly geoPointCache;
    private readonly geoCircleCache;
    private readonly intersectionCache;
    private readonly greatCircleBuilder;
    private readonly directToPointBuilder;
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache: Map<string, Facility>);
    /** @inheritdoc */
    protected calculateVectors(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState): void;
}
/**
 * Calculates flight path vectors for track from fix legs.
 */
declare class TrackFromFixLegCalculator extends AbstractFlightPathLegCalculator {
    private readonly vec3Cache;
    private readonly geoPointCache;
    private readonly geoCircleCache;
    private readonly greatCircleBuilder;
    private readonly directToPointBuilder;
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache: Map<string, Facility>);
    /** @inheritdoc */
    protected calculateVectors(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState): void;
}
/**
 * Calculates flight path vectors for course to fix legs.
 */
declare class CourseToFixLegCalculator extends AbstractFlightPathLegCalculator {
    private static readonly FALLBACK_INELIGIBLE_LEG_TYPES;
    private readonly vec3Cache;
    private readonly geoPointCache;
    private readonly geoCircleCache;
    private readonly intersectionCache;
    private readonly circleVectorBuilder;
    private readonly greatCircleBuilder;
    private readonly joinGreatCircleToPointBuilder;
    private readonly procTurnBuilder;
    private readonly directToPointBuilder;
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache: Map<string, Facility>);
    /** @inheritdoc */
    protected calculateVectors(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState): void;
}
/**
 * Calculates flight path vectors for procedure turn legs.
 */
declare class ProcedureTurnLegCalculator extends AbstractFlightPathLegCalculator {
    protected readonly geoPointCache: GeoPoint[];
    protected readonly geoCircleCache: GeoCircle[];
    protected readonly greatCircleBuilder: GreatCircleBuilder;
    protected readonly joinGreatCircleToPointBuilder: JoinGreatCircleToPointBuilder;
    protected readonly procTurnBuilder: ProcedureTurnBuilder;
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache: Map<string, Facility>);
    protected calculateVectors(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState): void;
    /**
     * Predicts the final true course of a leg at its terminator fix.
     * @param legs A leg sequence.
     * @param index The index of the leg in the sequence.
     * @param terminator The location of the leg's terminator fix.
     * @returns the predicted final course of a leg at its terminator fix, or undefined if a prediction cannot be made.
     */
    private predictLegFinalTrueCourse;
    /**
     * Predicts the initial true course of a leg at its origin fix.
     * @param legs A leg sequence.
     * @param index The index of the leg in the sequence.
     * @param origin The location of the leg's origin.
     * @returns the predicted final course of a leg at its terminator fix, or undefined if a prediction cannot be made.
     */
    private predictLegInitialTrueCourse;
}
/**
 * Calculates flight path vectors for course to manual legs.
 */
declare class CourseToManualLegCalculator extends AbstractFlightPathLegCalculator {
    protected readonly geoPointCache: GeoPoint[];
    protected readonly greatCircleBuilder: GreatCircleBuilder;
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache: Map<string, Facility>);
    protected calculateVectors(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState): void;
}
/**
 * Calculates flight path vectors for course to altitude legs.
 */
declare class CourseToAltitudeLegCalculator extends AbstractFlightPathLegCalculator {
    protected readonly vec3Cache: Float64Array[];
    protected readonly geoPointCache: GeoPoint[];
    protected readonly geoCircleCache: GeoCircle[];
    protected readonly greatCircleBuilder: GreatCircleBuilder;
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache: Map<string, Facility>);
    protected calculateVectors(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState): void;
}
/**
 * Calculates flight path vectors for hold legs.
 */
declare class HoldLegCalculator extends AbstractFlightPathLegCalculator {
    protected readonly geoPointCache: GeoPoint[];
    protected readonly geoCircleCache: GeoCircle[];
    protected readonly greatCircleBuilder: GreatCircleBuilder;
    protected readonly circleVectorBuilder: CircleVectorBuilder;
    protected readonly turnToCourseBuilder: TurnToCourseBuilder;
    protected readonly joinGreatCircleToPointBuilder: JoinGreatCircleToPointBuilder;
    protected readonly procTurnBuilder: ProcedureTurnBuilder;
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache: Map<string, Facility>);
    protected calculateVectors(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState): void;
}

/**
 * Options for the flight path calculator.
 */
interface FlightPathCalculatorOptions {
    /** The default climb rate, if the plane is not yet at flying speed. */
    defaultClimbRate: number;
    /** The default speed, if the plane is not yet at flying speed. */
    defaultSpeed: number;
    /** The bank angle with which to calculate turns. */
    bankAngle: number;
}
/**
 * Calculates the flight path vectors for a given set of legs.
 */
declare class FlightPathCalculator {
    private readonly facilityLoader;
    private readonly bus;
    private readonly facilityCache;
    private readonly legCalculatorMap;
    private readonly turnCalculator;
    private readonly state;
    private readonly options;
    private readonly calculateQueue;
    private isBusy;
    /**
     * Creates an instance of the FlightPathCalculator.
     * @param facilityLoader The facility loader to use with this instance.
     * @param options The options to use with this flight path calculator.
     * @param bus An instance of the EventBus.
     */
    constructor(facilityLoader: FacilityLoader, options: FlightPathCalculatorOptions, bus: EventBus);
    /**
     * Method to update this calculator's options.
     * @param newOptions A Partial FlightPathCalculatorOptions object.
     */
    private setOptions;
    /**
     * Creates a map from leg types to leg calculators.
     * @returns A map from leg types to leg calculators.
     */
    protected createLegCalculatorMap(): Record<LegType, FlightPathLegCalculator>;
    /**
     * Calculates a flight path for a given set of flight plan legs.
     * @param legs The legs of the flight plan to calculate.
     * @param activeLegIndex The index of the active leg.
     * @param initialIndex The index of the leg at which to start the calculation.
     * @param count The number of legs to calculate.
     * @returns A Promise which is fulfilled when the calculation is finished.
     */
    calculateFlightPath(legs: LegDefinition[], activeLegIndex: number, initialIndex?: number, count?: number): Promise<void>;
    /**
     * Executes a calculate operation. When the operation is finished, the next operation in the queue, if one exists,
     * will be started.
     * @param resolve The Promise resolve function to invoke when the calculation is finished.
     * @param reject The Promise reject function to invoke when an error occurs during calculation.
     * @param legs The legs of the flight plan to calculate.
     * @param activeLegIndex The index of the active leg.
     * @param initialIndex The index of the leg at which to start the calculation.
     * @param count The number of legs to calculate.
     * @returns A Promise which is fulfilled when the calculate operation is finished, or rejected if an error occurs
     * during calculation.
     */
    private doCalculate;
    /**
     * Loads facilities required for flight path calculations from the flight plan.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     * @param count The number of legs to calculate.
     */
    private loadFacilities;
    /**
     * Stages a facility to be loaded.
     * @param icao The ICAO of the facility.
     * @param facilityPromises The array of facility load promises to push to.
     */
    private stageFacilityLoad;
    /**
     * Initializes the current lat/lon.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     */
    private initCurrentLatLon;
    /**
     * Initializes the current course.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     */
    private initCurrentCourse;
    /**
     * Initializes the fallback state.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     */
    private initIsFallback;
    /**
     * Calculates flight paths for a sequence of flight plan legs.
     * @param legs A sequence of flight plan legs.
     * @param activeLegIndex The index of the active leg.
     * @param initialIndex The index of the first leg to calculate.
     * @param count The number of legs to calculate.
     */
    private calculateLegPaths;
    /**
     * Calculates a flight path for a leg in a sequence of legs.
     * @param legs A sequence of flight plan legs.
     * @param calculateIndex The index of the leg to calculate.
     * @param activeLegIndex The index of the active leg.
     */
    private calculateLegPath;
    /**
     * Resolves the ingress to egress vectors for a set of flight plan legs.
     * @param legs A sequence of flight plan legs.
     * @param initialIndex The index of the first leg to resolve.
     * @param count The number of legs to resolve.
     */
    private resolveLegsIngressToEgress;
    /**
     * Updates leg distances with turn anticipation.
     * @param legs A sequence of flight plan legs.
     * @param initialIndex The index of the first leg to update.
     * @param count The number of legs to update.
     */
    private updateLegDistances;
}

/**
 * Control Events for the Flight Path Calculator.
 */
interface FlightPathCalculatorControlEvents {
    /** Event to set some or all FlightPathCalculatorOptions. */
    flightpath_set_options: Partial<FlightPathCalculatorOptions>;
}

/**
 * A flight path calculator for turns between legs.
 */
declare class FlightPathTurnCalculator {
    private static readonly vector3Cache;
    private static readonly geoPointCache;
    private static readonly geoCircleCache;
    private static readonly intersectionVecArrayCache;
    private static readonly intersectionGeoPointArrayCache;
    private readonly procTurnBuilder;
    /**
     * Computes leg to leg turns for a given sequence of legs. Turns will only be calculated between legs with defined
     * flight path vectors and no pre-existing egress/ingress transition (unless it is a leg-to-leg turn) at the junction
     * of the turn.
     * @param legs A sequence of legs.
     * @param startIndex The index of the first leg for which to compute turns.
     * @param count The total number of legs for which to compute turns.
     * @param desiredTurnRadius The desired turn radius, in meters.
     */
    computeTurns(legs: LegDefinition[], startIndex: number, count: number, desiredTurnRadius: number): void;
    /**
     * Calculates a leg-to-leg turn between two track vectors.
     * @param legs The sequence of legs to which the turn belongs.
     * @param fromIndex The index of the leg on which the turn begins.
     * @param toIndex The index of the leg on which the turn ends.
     * @param fromTrack The track vector on which the turn begins.
     * @param toTrack The track vector on which the turn ends.
     * @param desiredTurnRadius The desired turn radius, in meters.
     * @param isRestrictedByPrevTurn Whether turn anticipation is restricted by the previous leg-to-leg turn. If `true`,
     * turn anticipation will be restricted so that the turn does not overlap the previous turn if they share a common
     * flight path vector.
     * @param previousTanTheta The tangent of the theta value of the previous turn. Theta is defined as the (acute)
     * angle between either `fromTrack` or `toTrack` and the great circle passing through the turn vertex (where the two
     * tracks meet) and the center of the turn. If this value is defined and `isRestrictedByPrevTurn` is `true`, the
     * anticipation of both turns will be adjusted if necessary such that the turns do not overlap if they share a common
     * flight path vector. If the value is undefined, the anticipation of the current turn will be restricted by the
     * previous turn, if necessary, without changing the anticipation of the previous turn.
     * @returns The index of the last leg in the sequence for which a turn ending on that leg was computed.
     */
    private computeTrackTrackTurn;
    /**
     * Computes a leg-to-leg course reversal.
     * @param legs The sequence of legs to which the turn belongs.
     * @param fromIndex The index of the leg on which the turn begins.
     * @param toIndex The index of the leg on which the turn ends.
     * @param fromTrack The track vector on which the turn begins.
     * @param toTrack The track vector on which the turn ends.
     * @param fromTrackBearing The true course bearing of the track vector on which the turn begins, at the end of the vector.
     * @param toTrackBearing The true course bearing of the track vector on which the turn ends, at the beginning of the vector.
     * @param desiredTurnRadius The desired turn radius, in meters.
     * @returns The index of the last leg in the sequence for which a turn ending on that leg was computed.
     */
    private computeTrackTrackCourseReversal;
    /**
     * Calculates a leg to leg turn between an arc vector and a track vector.
     * @param legs The sequence of legs to which the turn belongs.
     * @param fromIndex The index of the leg on which the turn begins.
     * @param toIndex The index of the leg on which the turn ends.
     * @param arc The arc vector.
     * @param track The track vector.
     * @param isArcFirst Whether the arc vector precedes the track vector (i.e. whether the arc vector is the vector on
     * which the turn begins).
     * @param desiredTurnRadius The desired turn radius, in meters.
     * @returns the index of the last leg in the sequence for which a turn ending on that leg was computed.
     */
    private computeArcTrackTurn;
    /**
     * Removes all ingress and egress flight path vectors from a pair of legs at their junction.
     * @param fromLegCalc The calculations for the leg on which the turn begins.
     * @param toLegCalc The calculations for the leg on which the turn ends.
     */
    private setEmptyTurn;
    private static readonly setAnticipatedTurnCache;
    /**
     * Adds flight path vectors to a pair of legs for an anticipated leg to leg turn.
     * @param fromLegCalc The calculations for the leg on which the turn begins.
     * @param toLegCalc The calculations for the leg on which the turn ends.
     * @param direction The direction of the turn.
     * @param radius The radius of the turn, in meters.
     * @param center The location of the center of the turn.
     * @param start The location of the start of the turn.
     * @param middle The location of the midpoint of the turn.
     * @param end The location of the end of the turn.
     */
    private setAnticipatedTurn;
}

/**
 * Utility class for working with flight path calculations.
 */
declare class FlightPathUtils {
    private static readonly vec3Cache;
    private static readonly geoPointCache;
    private static readonly geoCircleCache;
    /**
     * Creates an empty arc vector.
     * @returns An empty arc vector.
     */
    static createEmptyCircleVector(): CircleVector;
    /**
     * Sets the parameters of a circle vector.
     * @param vector The circle vector to set.
     * @param circle The GeoCircle defining the vector's path.
     * @param start The start of the vector.
     * @param end The end of the vector.
     * @param flags The flags to set on the vector.
     * @returns The circle vector, after its parameters have been set.
     */
    static setCircleVector(vector: CircleVector, circle: GeoCircle, start: ReadonlyFloat64Array | LatLonInterface, end: ReadonlyFloat64Array | LatLonInterface, flags: number): CircleVector;
    /**
     * Checks whether a circle vector describes a great-circle path.
     * @param vector A flight path circle vector.
     * @returns Whether the vector describes a great-circle path.
     */
    static isVectorGreatCircle(vector: CircleVector): boolean;
    /**
     * Sets the parameters of a GeoCircle from a flight path circle vector.
     * @param vector A flight path circle vector.
     * @param out The GeoCircle to set.
     * @returns The GeoCircle, after its parameters have been set.
     */
    static setGeoCircleFromVector(vector: CircleVector, out: GeoCircle): GeoCircle;
    /**
     * Gets the initial true course bearing of a flight path vector.
     * @param vector A flight path vector.
     * @returns The initial true course bearing of the vector, or undefined if one could not be calculated.
     */
    static getVectorInitialCourse(vector: FlightPathVector): number;
    /**
     * Gets the final true course bearing of a flight path vector.
     * @param vector A flight path vector.
     * @returns The final true course bearing of the vector, or `undefined` if one could not be calculated.
     */
    static getVectorFinalCourse(vector: FlightPathVector): number;
    /**
     * Gets the final position of a calculated leg.
     * @param legCalc A set of leg calculations.
     * @param out The GeoPoint object to which to write the result.
     * @returns The final position of the leg, or `undefined` if one could not be obtained.
     */
    static getLegFinalPosition(legCalc: LegCalculations, out: GeoPoint): GeoPoint | undefined;
    /**
     * Gets the final true course of a calculated leg.
     * @param legCalc A set of leg calculations.
     * @returns The final true course of the leg, or `undefined` if one could not be obtained.
     */
    static getLegFinalCourse(legCalc: LegCalculations): number | undefined;
    /**
     * Gets the circle describing the path of a turn.
     * @param center The center of the turn.
     * @param radius The radius of the turn, in great-arc radians.
     * @param turnDirection The direction of the turn.
     * @param out A GeoCircle object to which to write the result.
     * @returns The circle describing the path of the turn.
     */
    static getTurnCircle(center: ReadonlyFloat64Array | LatLonInterface, radius: number, turnDirection: VectorTurnDirection, out: GeoCircle): GeoCircle;
    /**
     * Reverses the direction of a turn circle while keeping the turn center and turn radius constant.
     * @param circle The turn circle to reverse.
     * @param out A GeoCircle object to which to write the result.
     * @returns A turn circle which has the same turn center and turn radius, but the opposite direction as `circle`.
     */
    static reverseTurnCircle(circle: GeoCircle, out: GeoCircle): GeoCircle;
    /**
     * Gets the direction of a turn described by a circle.
     * @param circle The geo circle describing the turn.
     * @returns The direction of the turn described by the circle.
     */
    static getTurnDirectionFromCircle(circle: GeoCircle): VectorTurnDirection;
    /**
     * Gets the radius of a turn described by a circle.
     * @param circle The geo circle describing the turn.
     * @returns The radius of the turn described by the circle, in great-arc radians.
     */
    static getTurnRadiusFromCircle(circle: GeoCircle): number;
    /**
     * Gets the center of a turn described by a circle.
     * @param circle The geo circle describing the turn.
     * @param out A GeoPoint or 3D vector object to which to write the result.
     * @returns The center of a turn described by the circle.
     */
    static getTurnCenterFromCircle<T extends GeoPoint | Float64Array>(circle: GeoCircle, out: T): T;
    /**
     * Calculates and returns a circle describing a turn starting from a path at a specified point.
     * @param start The starting point of the turn.
     * @param path The circle describing the path from which the turn starts.
     * @param turnRadius The radius of the turn, in great-arc radians.
     * @param turnDirection The direction of the turn.
     * @param out A GeoCircle object to which to write the result.
     * @returns The circle describing the path of the specified turn.
     */
    static getTurnCircleStartingFromPath(start: ReadonlyFloat64Array | LatLonInterface, path: GeoCircle, turnRadius: number, turnDirection: VectorTurnDirection, out: GeoCircle): GeoCircle;
    /**
     * Gets the signed distance along an arc from a defined start point to a query point. The start, query, and end
     * points will be projected onto the arc's parent circle if they do not already lie on it. A negative distance
     * indicates that the query point lies somewhere before the start of the arc but after the point on the arc's parent
     * circle that is diametrically opposed to the midpoint of the arc.
     * @param circle The arc's parent circle.
     * @param start The start point of the arc.
     * @param end The end point of the arc.
     * @param pos The query point.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `query` are equal.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns The signed distance along the arc from the start point to the query point, in great-arc radians.
     */
    static getAlongArcSignedDistance(circle: GeoCircle, start: ReadonlyFloat64Array | LatLonInterface, end: ReadonlyFloat64Array | LatLonInterface, pos: ReadonlyFloat64Array | LatLonInterface, tolerance?: number): number;
    /**
     * Gets the normalized distance along an arc from a defined start point to a query point. The start, query, and end
     * points will be projected onto the arc's parent circle if they do not already lie on it. The distance is normalized
     * such that 1 equals the arc length from the start point to the end point. A negative distance indicates that the
     * query point lies somewhere before the start of the arc but after the point on the arc's parent circle that is
     * diametrically opposed to the midpoint of the arc.
     * @param circle The arc's parent circle.
     * @param start The start point of the arc.
     * @param end The end point of the arc.
     * @param pos The query point.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `query` are equal.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns The normalized distance along the arc from the start point to the query point.
     */
    static getAlongArcNormalizedDistance(circle: GeoCircle, start: ReadonlyFloat64Array | LatLonInterface, end: ReadonlyFloat64Array | LatLonInterface, pos: ReadonlyFloat64Array | LatLonInterface, tolerance?: number): number;
    /**
     * Checks if a point lies between the start and end points of an arc along a geo circle. The start, end, and query
     * points will be projected onto the arc's parent circle if they do not already lie on it.
     * @param circle The arc's parent circle.
     * @param start The start point of the arc.
     * @param end The end point of the arc.
     * @param pos The query point.
     * @param inclusive Whether the arc includes the start and end points. Defaults to `true`.
     * @param tolerance The error tolerance, in great-arc radians. Defaults to {@link GeoCircle.ANGULAR_TOLERANCE}.
     * @returns Whether the query point lies between the start and end points of the specified arc.
     */
    static isPointAlongArc(circle: GeoCircle, start: ReadonlyFloat64Array | LatLonInterface, end: ReadonlyFloat64Array | LatLonInterface, pos: ReadonlyFloat64Array | LatLonInterface, inclusive?: boolean, tolerance?: number): boolean;
    /**
     * Checks if a point lies between the start and end points (inclusive) of an arc along a geo circle. The start and
     * query points will be projected onto the arc's parent circle if they do not already lie on it.
     * @param circle The arc's parent circle.
     * @param start The start point of the arc.
     * @param angularWidth The angular width of the arc, in radians.
     * @param pos The query point.
     * @param inclusive Whether the arc includes the start and end points. Defaults to `true`.
     * @param tolerance The error tolerance, in great-arc radians. Defaults to {@link GeoCircle.ANGULAR_TOLERANCE}.
     * @returns Whether the query point lies between the start and end points (inclusive) of the specified arc.
     */
    static isPointAlongArc(circle: GeoCircle, start: ReadonlyFloat64Array | LatLonInterface, angularWidth: number, pos: ReadonlyFloat64Array | LatLonInterface, inclusive?: boolean, tolerance?: number): boolean;
    /**
     * Resolves the ingress to egress vectors for a set of flight plan leg calculations. This operation will populate the
     * `ingressToEgress` array with a sequence of vectors connecting the ingress transition to the egress transition
     * while following the flight path defined by the vectors in the `flightPath` array.
     * @param legCalc A set of flight plan leg calculations.
     * @returns The flight plan leg calculations, after the ingress to egress vectors have been resolved.
     */
    static resolveIngressToEgress<T extends LegCalculations>(legCalc: T): T;
}

declare enum PlanChangeType {
    Added = "Added",
    Inserted = "Inserted",
    Removed = "Removed",
    Changed = "Changed",
    Cleared = "Cleared"
}
declare enum ActiveLegType {
    Lateral = "Lateral",
    Vertical = "Vertical",
    Calculating = "Calculating"
}
declare enum OriginDestChangeType {
    OriginAdded = "OriginAdded",
    OriginRemoved = "OriginRemoved",
    DestinationAdded = "DestinationAdded",
    DestinationRemoved = "DestinationRemoved"
}
/** Direct To Metadata for Flight Plan. */
interface DirectToData {
    /** The segment index of the direct to target. */
    segmentIndex: number;
    /** The segment leg index of the direct to target. */
    segmentLegIndex: number;
}
/**
 * Events generated by changes in the flight plan.
 */
interface PlanEvents {
    /**
     * An event generated when there is a change in a leg.
     * @param segmentIndex The index of the segment.
     * @param index The index of the leg.
     * @param type The type of change.
     * @param leg The leg that was changed.
     */
    onLegChanged?(segmentIndex: number, index: number, type: PlanChangeType, leg?: LegDefinition): void;
    /**
     * An event generated when there is a change in a segment.
     * @param index The index of the segment.
     * @param type The type of change.
     * @param segment The segment that was changed.
     */
    onSegmentChanged?(index: number, type: PlanChangeType, segment?: FlightPlanSegment): void;
    /**
     * An event generated when an active leg is changed.
     * @param index The index of the leg.
     * @param segmentIndex The index of the flight plan segment.
     * @param previousSegmentIndex The index of the previously active segment.
     * @param previousLegIndex The index of the previously active leg in the previously active segment.
     * @param type The type of leg that was changed.
     */
    onActiveLegChanged?(index: number, segmentIndex: number, legIndex: number, previousSegmentIndex: number, previousLegIndex: number, type: ActiveLegType): void;
    /**
     * An event fired when a flight plan vectorization completes.
     * @param index The index that the path was generated from.
     */
    onCalculated?(index?: number): void;
    /**
     * An event fired when the origin or destination changes.
     * @param type The origin/destination change type.
     * @param airport The airport that was changed.
     */
    onOriginDestChanged?(type: OriginDestChangeType, airport?: string): void;
    /**
     * An event fired when the procedure details change.
     * @param details The details that were changed.
     */
    onProcedureDetailsChanged?(details: ProcedureDetails): void;
    /**
     * An event fired when user data is set in the plan.
     * @param key The key of the user data.
     * @param data The data that was set.
     */
    onUserDataSet?(key: string, data: any): void;
    /**
     * An event fired when user data is deleted in the plan.
     * @param key The key of the user data to delete.
     */
    onUserDataDelete?(key: string): void;
    /**
     * An event fired when direct to data is changed in the plan.
     * @param directToData The direct to data.
     */
    onDirectDataChanged?(directToData: DirectToData): void;
}
/**
 * A flight plan managed by the flight plan system.
 */
declare class FlightPlan {
    planIndex: number;
    calculator: FlightPathCalculator;
    private onLegNameRequested;
    private _originAirport?;
    /** The ICAO of the origin airport in the flight plan, if any. */
    get originAirport(): string | undefined;
    private _destinationAirport?;
    /** The ICAO of the destination airport in the flight plan, if any. */
    get destinationAirport(): string | undefined;
    private _activeLateralLeg;
    /** The global index of the currently active lateral navigation leg. */
    get activeLateralLeg(): number;
    private _activeVerticalLeg;
    /** The global index of the currently active vertical navigation leg. */
    get activeVerticalLeg(): number;
    private _activeCalculatingLeg;
    /** The global index of the currently active calculating leg. */
    get activeCalculatingLeg(): number;
    /** The direct to metadata for this plan. */
    readonly directToData: DirectToData;
    /**
     * Gets the current number of legs in the flight plan.
     * @returns The number of legs in the plan.
     */
    get length(): number;
    /**
     * Gets the current number of segments in the flight plan.
     * @returns The number of legs in the plan.
     */
    get segmentCount(): number;
    /** Events fired when the plan is modified. */
    events: PlanEvents;
    /** The details about the selected procedures. */
    readonly procedureDetails: ProcedureDetails;
    /** The flight plan segments that make up this flight plan. */
    private readonly planSegments;
    /** User assignable data. */
    private readonly userData;
    /**
     * Creates an instance of a FlightPlan.
     * @param planIndex The index within the flight planner of this flight plan.
     * @param calculator The flight path calculator to use to calculate the flight path.
     * @param onLegNameRequested A callback fired when a flight plan leg is to be named.
     */
    constructor(planIndex: number, calculator: FlightPathCalculator, onLegNameRequested: ((leg: FlightPlanLeg) => string | undefined));
    /**
     * Gets this flight plan's legs.
     * @param reverse Whether to get the legs in reverse order. False by default.
     * @param startIndex The global leg index of the leg with which to start. Defaults to 0 if `reverse` is false or
     * `this.length` if `reverse` is true.
     * @returns A generator which yields this flight plan's legs.
     */
    legs(reverse?: boolean, startIndex?: number): Generator<LegDefinition, void>;
    /**
     * Gets this flight plan's legs in forward order.
     * @param startIndex The global leg index of the leg with which to start. Defaults to 0.
     * @yields This flight plan's legs in forward order.
     */
    private _legs;
    /**
     * Gets this flight plan's legs in reverse order.
     * @param startIndex The global leg index of the leg with which to start. Defaults to `this.length - 1`.
     * @yields This flight plan's legs in reverse order.
     */
    private _legsReverse;
    /**
     * Gets the segments for the flightplan.
     * @yields The flight plan segments.
     */
    segments(): Generator<FlightPlanSegment, void>;
    /**
     * Gets all of the segments of a given type.
     * @param segmentType The type of the segments to retrieve.
     * @yields The segments of the requested type.
     */
    segmentsOfType(segmentType: FlightPlanSegmentType): Generator<FlightPlanSegment, void>;
    /**
     * Adds a segment to the flight plan at a specified index.
     * @param segmentIndex The index of the flight plan segment.
     * @param segmentType The type of segment this will be.
     * @param airway The airway this segment is made up of, if any.
     * @param notify Whether or not to send notifications after the operation.
     * @returns The new flight plan segment.
     */
    addSegment(segmentIndex: number, segmentType?: FlightPlanSegmentType, airway?: string, notify?: boolean): FlightPlanSegment;
    /**
     * Inserts a segment into the flight plan at the specified index and
     * reflows the subsequent segments.
     * @param segmentIndex The index to insert the flight plan segment.
     * @param segmentType The type of segment this will be.
     * @param airway The airway this segment is made up of, if any
     * @param notify Whether or not to send notifications after the operation.
     * @returns The new flight plan segment.
     */
    insertSegment(segmentIndex: number, segmentType?: FlightPlanSegmentType, airway?: string, notify?: boolean): FlightPlanSegment;
    /**
     * Reflows the flight plan segments after an insert.
     */
    private reflowSegments;
    /**
     * Deletes a segment from the flight plan, leaving an empty segment at the specified index.
     * @param segmentIndex The index of the segment to remove.
     * @param notify Whether or not to send notifications after the operation.
     */
    deleteSegment(segmentIndex: number, notify?: boolean): void;
    /**
     * Removes a segment from the flight plan and reflows the segments following
     * the removed segment, not leaving an empty segment at the specified index.
     * @param segmentIndex The index of the segment to remove.
     * @param notify Whether or not to send notifications after the operation.
     */
    removeSegment(segmentIndex: number, notify?: boolean): void;
    /**
     * Gets a flight plan segment from the plan.
     * @param segmentIndex The index of the segment to get; if not specified returns the active segment.
     * @returns The requested flight plan segment.
     * @throws An error if the flight plan segment could not be found.
     */
    getSegment(segmentIndex?: number): FlightPlanSegment;
    /**
     * Adds a leg to the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param leg The leg to add to the plan.
     * @param segmentLegIndex The index of the leg in the segment to insert. Will add to the end of the segment if omitted.
     * @param flags Leg definition flags to apply to the new leg. Defaults to `None` (0).
     * @param notify Whether or not to send notifications after the operation.
     * @returns the leg that was added.
     */
    addLeg(segmentIndex: number, leg: FlightPlanLeg, segmentLegIndex?: number, flags?: number, notify?: boolean): LegDefinition;
    /**
     * Gets a leg from the flight plan.
     * @param segmentIndex The index of the segment containing the leg to get.
     * @param segmentLegIndex The index of the leg to get in its segment.
     * @returns A flight plan leg.
     * @throws An error if the leg could not be found.
     */
    getLeg(segmentIndex: number, segmentLegIndex: number): LegDefinition;
    /**
     * Gets a leg from the flight plan.
     * @param globalLegIndex The global leg index of the leg to get.
     * @returns A flight plan leg.
     * @throws An error if the leg could not be found.
     */
    getLeg(globalLegIndex: number): LegDefinition;
    /**
     * Attempts to get a leg from the flight plan.
     * @param segmentIndex The index of the segment containing the leg to get.
     * @param segmentLegIndex The index of the leg to get in its segment.
     * @returns A flight plan leg, or `null` if one could not be found at the specified index.
     */
    tryGetLeg(segmentIndex: number, segmentLegIndex: number): LegDefinition | null;
    /**
     * Attempts to get a leg from the flight plan.
     * @param globalLegIndex The global leg index of the leg to get.
     * @returns A flight plan leg, or `null` if one could not be found at the specified index.
     */
    tryGetLeg(globalLegIndex: number): LegDefinition | null;
    /**
     * Attempts to get a leg from the flight plan.
     * @param arg1 The global leg index of the leg to get, or the index of the segment containing the leg to get.
     * @param arg2 The index of the leg to get in its segment.
     * @returns A flight plan leg, or `null` if one could not be found at the specified index.
     */
    private _tryGetLeg;
    /**
     * Removes a leg from the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param segmentLegIndex The index of the leg in the segment to remove. Will remove from the end of the segment if ommitted.
     * @param notify Whether or not to send notifications after the operation.
     * @returns the leg that was removed, or null if a leg was not removed.
     */
    removeLeg(segmentIndex: number, segmentLegIndex?: number, notify?: boolean): LegDefinition | null;
    /**
     * Calculates the flight path for the plan.
     * @param globalLegIndex The global leg index to start calculating from.
     * @param notify Whether or not to send notifications after the operation.
     */
    calculate(globalLegIndex?: number, notify?: boolean): Promise<void>;
    /**
     * Sets the origin airport in the flight plan.
     * @param facilityIcao The origin airport to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setOriginAirport(facilityIcao: string, notify?: boolean): void;
    /**
     * Removes the origin airport from the flight plan.
     * @param notify Whether or not to send notifications after the operation.
     */
    removeOriginAirport(notify?: boolean): void;
    /**
     * Sets the destination airport in the flight plan.
     * @param facilityIcao The destination airport to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setDestinationAirport(facilityIcao: string, notify?: boolean): void;
    /**
     * Removes the destination airport from the flight plan.
     * @param notify Whether or not to send notifications after the operation.
     */
    removeDestinationAirport(notify?: boolean): void;
    /**
     * Sets the active lateral leg index in the flight plan.
     * @param globalLegIndex The global leg index to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setLateralLeg(globalLegIndex: number, notify?: boolean): void;
    /**
     * Sets the active lateral leg index in the flight plan.
     * @param globalLegIndex The global leg index to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setVerticalLeg(globalLegIndex: number, notify?: boolean): void;
    /**
     * Sets the active calculating leg index in the flight plan.
     * @param globalLegIndex The global leg index to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setCalculatingLeg(globalLegIndex: number, notify?: boolean): void;
    /**
     * Sets the flight plan procedure details.
     * @param details The details of the flight plan's procedures.
     * @param notify Whether or not to send notifications after the operation.
     */
    setProcedureDetails(details: Partial<ProcedureDetails>, notify?: boolean): void;
    /**
     * Gets the global index of a flight plan leg in this flight plan.
     * @param leg A flight plan leg definition.
     * @returns the global index of the leg, or -1 if the leg is not in this flight plan.
     */
    getLegIndexFromLeg(leg: LegDefinition): number;
    /**
     * Gets the flight plan segment to which a leg belongs.
     * @param leg A flight plan leg definition.
     * @returns The segment to which the leg belongs, or null if the leg is not in this flight plan.
     */
    getSegmentFromLeg(leg: LegDefinition): FlightPlanSegment | null;
    /**
     * Gets the segment index for a given global leg index.
     * @param globalLegIndex The global leg index to get the segment index for.
     * @returns The segment index for the given global leg index, or -1 if not found.
     */
    getSegmentIndex(globalLegIndex: number): number;
    /**
     * Gets the segment leg index (the index of the leg in its segment) for a given global leg index.
     * @param globalLegIndex The global leg index to get the segment leg index for.
     * @returns The segment leg index, or -1 if not found.
     */
    getSegmentLegIndex(globalLegIndex: number): number;
    /**
     * Gets the leg immediately previous to a position in this flight plan specified by segment index and leg index.
     * @param segmentIndex A segment index.
     * @param legIndex A leg index.
     * @returns the leg immediately previous to the specified position, or null if there is no such leg.
     */
    getPrevLeg(segmentIndex: number, legIndex: number): LegDefinition | null;
    /**
     * Gets the leg immediately after a position in this flight plan specified by segment index and leg index.
     * @param segmentIndex A segment index.
     * @param legIndex A leg index.
     * @returns the leg immediately after the specified position, or null if there is no such leg.
     */
    getNextLeg(segmentIndex: number, legIndex: number): LegDefinition | null;
    /**
     * Sets the direct to data for this plan.
     * @param globalLegIndex The global leg index of the direct to target, or -1 if the direct to data is to be cleared.
     * @param notify Whether to send an event for this change. Defaults to true.
     */
    setDirectToData(globalLegIndex: number, notify?: boolean): void;
    /**
     * Sets the direct to data for this plan.
     * @param segmentIndex The segment index of the direct to target, or -1 if the direct to data is to be cleared.
     * @param segmentLegIndex The segment leg index of the direct to target, or -1 if the direct to data is to be
     * cleared.
     * @param notify Whether to send an event for this change. Defaults to true.
     */
    setDirectToData(segmentIndex: number, segmentLegIndex: number, notify?: boolean): void;
    /**
     * Sets the direct to data for this plan.
     * @param leg The target leg of the direct to, or null if the direct to data is to be cleared.
     * @param notify Whether to send an event for this change. Defaults to true.
     */
    setDirectToData(leg: LegDefinition | null, notify?: boolean): void;
    /**
     * Sets the vertical data for this plan leg.
     * @param segmentIndex The segment index of the leg in the plan to add vertical data to.
     * @param segmentLegIndex The segment leg index of the leg in the plan to add vertical data to.
     * cleared.
     * @param verticalData The Vertical Data for this leg.
     * @param notify Whether to send an event for this change. Defaults to true.
     */
    setLegVerticalData(segmentIndex: number, segmentLegIndex: number, verticalData: VerticalData, notify?: boolean): void;
    /**
     * Sets the vertical data for this plan leg.
     * @param globalLegIndex The global leg index in the plan for the leg to add vertical data to.
     * @param verticalData The Vertical Data for this leg.
     * @param notify Whether to send an event for this change. Defaults to true.
     */
    setLegVerticalData(globalLegIndex: number, verticalData: VerticalData, notify?: boolean): void;
    /**
     * Sets the airway for a segment.
     * @param segmentIndex A segment index.
     * @param airway The airway name.
     * @param notify is whether to send an event for this change
     */
    setAirway(segmentIndex: number, airway?: string, notify?: boolean): void;
    /**
     * Sets user data in the flight plan.
     * @param key The key of the user data.
     * @param data The data to set.
     * @param notify Whether or not to notify subscribers.
     */
    setUserData<T>(key: string, data: T, notify?: boolean): void;
    /**
     * Sets user data in the flight plan.
     * @param key The key of the user data.
     * @param notify Whether or not to notify subscribers.
     */
    deleteUserData(key: string, notify?: boolean): void;
    /**
     * Gets user data from the flight plan.
     * @param key The key of the user data.
     * @returns The user data, if found.
     */
    getUserData<T>(key: string): T | undefined;
    /**
     * Reflows all flight plan segment offsets after a plan change.
     */
    private reflowSegmentOffsets;
    /**
     * Sets the origin runway in procedure details.
     * @param runway The oneway runway to set as the origin, or undefined
     * @param notify Whether or not to notify subscribers.
     */
    setOriginRunway(runway?: OneWayRunway | undefined, notify?: boolean): void;
    /**
     * Sets the destination runway in procedure details.
     * @param runway The oneway runway to set as the destination, or undefined
     * @param notify Whether or not to notify subscribers.
     */
    setDestinationRunway(runway?: OneWayRunway | undefined, notify?: boolean): void;
    /**
     * Sets the departure procedure details.
     * @param facilityIcao The facility ICAO of the facility containing the procedure
     * @param departureIndex The index of the departure in the origin airport information
     * @param departureTransitionIndex The index of the departure transition in the origin airport departure information
     * @param departureRunwayIndex The index of the selected runway in the original airport departure information
     * @param notify Whether or not to notify subscribers.
     */
    setDeparture(facilityIcao?: string | undefined, departureIndex?: number, departureTransitionIndex?: number, departureRunwayIndex?: number, notify?: boolean): void;
    /**
     * Sets the arrival procedure details.
     * @param facilityIcao The facility ICAO of the facility containing the procedure
     * @param arrivalIndex The index of the arrival in the destination airport information
     * @param arrivalTransitionIndex index of the arrival transition in the destination airport arrival information
     * @param arrivalRunwayTransitionIndex The index of the selected runway transition at the destination airport arrival information
     * @param notify Whether or not to notify subscribers
     */
    setArrival(facilityIcao?: string | undefined, arrivalIndex?: number, arrivalTransitionIndex?: number, arrivalRunwayTransitionIndex?: number, notify?: boolean): void;
    /**
     * Sets the approach procedure details.
     * @param facilityIcao The facility ICAO of the facility containing the procedure
     * @param approachIndex The index of the apporach in the destination airport information
     * @param approachTransitionIndex The index of the approach transition in the destination airport approach information
     * @param notify Whether or not to notify subscribers
     */
    setApproach(facilityIcao?: string | undefined, approachIndex?: number, approachTransitionIndex?: number, notify?: boolean): void;
    /**
     * Copies the flight plan.
     * @param planIndex The flight plan index to assign to this plan, or the same plan
     * index if not provided.
     * @returns The copied flight plan.
     */
    copy(planIndex?: number): FlightPlan;
    /**
     * Creates a default instance of a flight plan leg.
     * @param partial A portion of leg options to apply.
     * @returns A default instance of a flight plan leg.
     */
    static createLeg: (partial: Partial<FlightPlanLeg>) => FlightPlanLeg;
}

/** A noop interface for global type guards */
interface EventTypes {
}
/**
 * A generic class for injecting pacing logic into a publisher.
 */
interface PublishPacer<E extends EventTypes> {
    canPublish<K extends keyof E>(topic: K, data: E[K]): boolean;
}
/**
 * A PublishPacer that only allows publishing on an interval.
 */
declare class IntervalPacer<E> {
    private interval;
    private lastPublished;
    /**
     * Create an IntervalPacer.
     * @param msec Time to wait between publishs in ms
     */
    constructor(msec: number);
    /**
     * Determine whether the data can be published based on the time since its
     * prior publish.
     * @param topic The topic data would be sent on.
     * @param data The data which would be sent.
     * @returns A bool indicating if the data should be published.
     */
    canPublish<K extends keyof E>(topic: keyof E, data: E[K]): boolean;
}
/**
 * A PublishPacer that only allows publishing when a value has changed
 * by a specifed amount from the prior publish.
 */
declare class DeltaPacer<E> {
    private delta;
    private lastPublished;
    /**
     * Create a DeltaPacer.
     * @param delta The difference required for publishing to be allowed.
     */
    constructor(delta: number);
    /**
     * Determine whether the data can be published based on its delta from the
     * pror publish.
     * @param topic The topic data would be sent on.
     * @param data The data which would be sent.
     * @returns A bool indicating if the data should be published.
     */
    canPublish<K extends keyof E>(topic: keyof E, data: number): boolean;
}

/**
 * A basic implementation of {@link Consumer}.
 */
declare class BasicConsumer<T> implements Consumer<T> {
    private readonly subscribe;
    private state;
    private readonly currentHandler?;
    /** @inheritdoc */
    readonly isConsumer = true;
    private readonly activeSubs;
    /**
     * Creates an instance of a Consumer.
     * @param subscribe A function which subscribes a handler to the source of this consumer's events.
     * @param state The state for the consumer to track.
     * @param currentHandler The current build filter handler stack, if any.
     */
    constructor(subscribe: (handler: Handler<T>, paused: boolean) => Subscription, state?: any, currentHandler?: ((data: T, state: any, next: Handler<T>) => void) | undefined);
    /** @inheritdoc */
    handle(handler: Handler<T>, paused?: boolean): Subscription;
    /** @inheritdoc */
    off(handler: Handler<T>): void;
    /** @inheritdoc */
    atFrequency(frequency: number, immediateFirstPublish?: boolean): Consumer<T>;
    /**
     * Gets a handler function for a 'atFrequency' filter.
     * @param frequency The frequency, in Hz, to cap to.
     * @returns A handler function for a 'atFrequency' filter.
     */
    private getAtFrequencyHandler;
    /** @inheritdoc */
    withPrecision(precision: number): Consumer<T>;
    /**
     * Gets a handler function for a 'withPrecision' filter.
     * @param precision The decimal precision to snap to.
     * @returns A handler function for a 'withPrecision' filter.
     */
    private getWithPrecisionHandler;
    /** @inheritdoc */
    whenChangedBy(amount: number): Consumer<T>;
    /**
     * Gets a handler function for a 'whenChangedBy' filter.
     * @param amount The minimum amount threshold below which the consumer will not consume.
     * @returns A handler function for a 'whenChangedBy' filter.
     */
    private getWhenChangedByHandler;
    /** @inheritdoc */
    whenChanged(): Consumer<T>;
    /**
     * Gets a handler function for a 'whenChanged' filter.
     * @returns A handler function for a 'whenChanged' filter.
     */
    private getWhenChangedHandler;
    /** @inheritdoc */
    onlyAfter(deltaTime: number): Consumer<T>;
    /**
     * Gets a handler function for an 'onlyAfter' filter.
     * @param deltaTime The minimum delta time between events.
     * @returns A handler function for an 'onlyAfter' filter.
     */
    private getOnlyAfterHandler;
    /**
     * Builds a handler stack from the current handler.
     * @param data The data to send in to the handler.
     * @param handler The handler to use for processing.
     */
    private with;
}

/**
 * Valid type arguments for Set/GetSimVarValue
 */
declare enum SimVarValueType {
    Number = "number",
    Percent = "percent",
    Degree = "degrees",
    Knots = "knots",
    Feet = "feet",
    Meters = "meters",
    FPM = "feet per minute",
    Radians = "radians",
    InHG = "inches of mercury",
    MB = "Millibars",
    Bool = "Bool",
    Celsius = "celsius",
    MHz = "MHz",
    KHz = "KHz",
    NM = "nautical mile",
    String = "string",
    RPM = "Rpm",
    PPH = "Pounds per hour",
    GPH = "gph",
    Farenheit = "farenheit",
    PSI = "psi",
    GAL = "gallons",
    LBS = "pounds",
    Hours = "Hours",
    Volts = "Volts",
    Amps = "Amperes",
    Seconds = "seconds",
    Enum = "Enum",
    LLA = "latlonalt",
    MetersPerSecond = "meters per second",
    Mach = "mach",
    Pounds = "pounds",
    SlugsPerCubicFoot = "slug per cubic foot"
}
/**
 * The definition of a simvar and associated value type.
 */
declare type SimVarDefinition = {
    /** The name of the simvar. */
    name: string;
    /** The value to be used to retrieve this simvar. */
    type: SimVarValueType;
};

/**
 * A basic event-bus publisher.
 */
declare class BasePublisher<E> {
    private bus;
    private publisher;
    private publishActive;
    private pacer;
    /**
     * Creates an instance of BasePublisher.
     * @param bus The common event bus.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(bus: EventBus, pacer?: PublishPacer<E> | undefined);
    /**
     * Start publishing.
     */
    startPublish(): void;
    /**
     * Stop publishing.
     */
    stopPublish(): void;
    /**
     * Tells whether or not the publisher is currently active.
     * @returns True if the publisher is active, false otherwise.
     */
    isPublishing(): boolean;
    /**
     * A callback called when the publisher receives an update cycle.
     */
    onUpdate(): void;
    /**
     * Publish a message if publishing is acpive
     * @param topic The topic key to publish to.
     * @param data The data type for chosen topic.
     * @param sync Whether or not the event should be synced to other instruments. Defaults to `false`.
     * @param isCached Whether or not the event should be cached. Defaults to `true`.
     */
    protected publish<K extends keyof E>(topic: K, data: E[K], sync?: boolean, isCached?: boolean): void;
}
/**
 * A publisher that sends a constant stream of random numbers.
 */
declare class RandomNumberPublisher extends BasePublisher<MockEventTypes> {
    /**
     * Start publishing random numbers.
     */
    startPublish(): void;
    /**
     * Async thread that publishes random numbers
     * @param ms - Milliseconds to sleep between publishes
     */
    private publishRandomNumbers;
}
/**
 * An entry for a sim var publisher topic.
 */
declare type SimVarPublisherEntry<T> = SimVarDefinition & {
    /**
     * A function which maps the raw simvar value to the value to be published to the event bus. If not defined, the
     * raw simvar value will be published to the bus as-is.
     */
    map?: (value: any) => T;
};
/**
 * A base class for publishers that need to handle simvars with built-in
 * support for pacing callbacks.
 */
declare class SimVarPublisher<E> extends BasePublisher<E> {
    protected readonly simvars: Map<keyof E & string, SimVarPublisherEntry<any>>;
    protected readonly subscribed: Set<keyof E & string>;
    /**
     * Create a SimVarPublisher
     * @param simVarMap A map of simvar event type keys to a SimVarDefinition.
     * @param bus The EventBus to use for publishing.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(simVarMap: Map<keyof E & string, SimVarDefinition>, bus: EventBus, pacer?: PublishPacer<E>);
    /**
     * Responds to when one of this publisher's topics is subscribed to for the first time.
     * @param topic The topic that was subscribed to.
     */
    protected onTopicSubscribed(topic: keyof E & string): void;
    /**
     * NOOP - For backwards compatibility.
     * @deprecated
     * @param data Key of the event type in the simVarMap
     */
    subscribe(data: keyof E): void;
    /**
     * NOOP - For backwards compatibility.
     * @deprecated
     * @param data Key of the event type in the simVarMap
     */
    unsubscribe(data: keyof E): void;
    /**
     * Publish all subscribed data points to the bus.
     */
    onUpdate(): void;
    /**
     * Publishes data to the event bus for a topic.
     * @param topic The topic to publish.
     */
    protected publishTopic(topic: keyof E & string): void;
    /**
     * Gets the current value for a topic.
     * @param topic A topic.
     * @returns The current value for the specified topic.
     */
    protected getValue<K extends keyof E & string>(topic: K): E[K] | undefined;
    /**
     * Gets the value of the SimVar
     * @param entry The SimVar definition entry
     * @returns The value of the SimVar
     */
    private getSimVarValue;
}

/**
 * H:Event events from the EventBus.
 */
declare type HEvent = {
    /** An H:Event event. */
    hEvent: string;
};
/**
 * A publisher for publishing H:Events on the bus.
 */
declare class HEventPublisher extends BasePublisher<HEvent> {
    /**
     * Dispatches an H:Event to the event bus.
     * @param hEvent The H:Event to dispatch.
     * @param sync Whether this event should be synced (optional, default false)
     */
    dispatchHEvent(hEvent: string, sync?: boolean): void;
}

/**
 * Base events related to air data computer information.
 */
interface BaseAdcEvents {
    /** The airplane's indicated airspeed, in knots. */
    ias: number;
    /** The airplane's true airspeed, in knots. */
    tas: number;
    /** The airplane's indicated altitude, in feet. */
    indicated_alt: number;
    /** The airplane's pressure altitude, in feet. */
    pressure_alt: number;
    /** The airplane's vertical speed, in feet per minute. */
    vertical_speed: number;
    /** The airplane's radio altitude, in feet. */
    radio_alt: number;
    /** The current altimeter baro setting, in inches of mercury. */
    altimeter_baro_setting_inhg: number;
    /** The current altimeter baro setting, in millibars. */
    altimeter_baro_setting_mb: number;
    /** The current preselected altimeter baro setting, in inches of mercury. */
    altimeter_baro_preselect_inhg: number;
    /** Whether the altimeter baro setting is set to STD (true=STD, false=set pressure). */
    altimeter_baro_is_std: boolean;
    /** The ambient temperature, in degrees Celsius. */
    ambient_temp_c: number;
    /** The ambient pressure, in inches of mercury. */
    ambient_pressure_inhg: number;
    /** The current ISA temperature, in degrees Celsius. */
    isa_temp_c: number;
    /** The current ram air temperatuer, in degrees Celsius. */
    ram_air_temp_c: number;
    /** The ambient wind velocity, in knots. */
    ambient_wind_velocity: number;
    /** The ambient wind direction, in degrees true. */
    ambient_wind_direction: number;
    /** Whether the plane is on the ground. */
    on_ground: boolean;
    /** The angle of attack. */
    aoa: number;
    /** The stall aoa of the current aircraft configuration. */
    stall_aoa: number;
    /** The speed of the aircraft in mach. */
    mach_number: number;
    /**
     * The conversion factor from mach to knots indicated airspeed in the airplane's current environment. In other
     * words, the speed of sound in knots indicated airspeed.
     */
    mach_to_kias_factor: number;
}
/**
 * Topics indexed by airspeed indicator.
 */
declare type AdcAirspeedIndexedTopics = 'ias' | 'tas' | 'mach_to_kias_factor';
/** Topics indexed by altimeter. */
declare type AdcAltimeterIndexedTopics = 'indicated_alt' | 'altimeter_baro_setting_inhg' | 'altimeter_baro_setting_mb' | 'altimeter_baro_preselect_inhg' | 'altimeter_baro_is_std';
/**
 * Topics related to air data computer information that are indexed.
 */
declare type AdcIndexedTopics = AdcAirspeedIndexedTopics | AdcAltimeterIndexedTopics;
/**
 * Indexed events related to air data computer information.
 */
declare type AdcIndexedEvents = {
    [P in keyof Pick<BaseAdcEvents, AdcIndexedTopics> as IndexedEventType<P>]: BaseAdcEvents[P];
};
/**
 * Events related to air data computer information.
 */
interface AdcEvents extends BaseAdcEvents, AdcIndexedEvents {
}
/**
 * A publisher for air data computer information.
 */
declare class AdcPublisher extends SimVarPublisher<AdcEvents> {
    private mach;
    private needUpdateMach;
    /**
     * Creates an AdcPublisher.
     * @param bus The event bus to which to publish.
     * @param airspeedIndicatorCount The number of airspeed indicators.
     * @param altimeterCount The number of altimeters.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus: EventBus, airspeedIndicatorCount: number, altimeterCount: number, pacer?: PublishPacer<AdcEvents>);
    /** @inheritdoc */
    protected onTopicSubscribed(topic: keyof AdcEvents): void;
    /** @inheritdoc */
    onUpdate(): void;
}

/**
 * Base events related to attitude and heading of the airplane.
 */
interface BaseAhrsEvents {
    /** The heading of the airplane, in degrees magnetic. */
    hdg_deg: number;
    /** A heading of the airplane, in degrees true. */
    hdg_deg_true: number;
    /** The pitch of the airplane, in degrees. Positive values indicate downward pitch. */
    pitch_deg: number;
    /** The roll (bank) of the airplane, in degrees. Positive values indicate leftward roll. */
    roll_deg: number;
    /** A turn coordinator ball value. */
    turn_coordinator_ball: number;
    /** The turn rate of the airplane, in degrees per second. */
    delta_heading_rate: number;
}
/**
 * Topics that are indexed by attitude indicator.
 */
declare type AhrsAttitudeIndexedTopics = 'pitch_deg' | 'roll_deg';
/**
 * Topics that are indexed by direction indicator.
 */
declare type AhrsDirectionIndexedTopics = 'hdg_deg' | 'hdg_deg_true' | 'delta_heading_rate';
/**
 * All topics related to attitude and heading of the airplane that are indexed.
 */
declare type AhrsIndexedTopics = AhrsAttitudeIndexedTopics | AhrsDirectionIndexedTopics;
/**
 * Indexed events related to attitude and heading of the airplane.
 */
declare type AhrsIndexedEvents = {
    [P in keyof Pick<BaseAhrsEvents, AhrsIndexedTopics> as IndexedEventType<P>]: BaseAhrsEvents[P];
};
/**
 * Events related to attitude and heading of the airplane.
 */
interface AhrsEvents extends BaseAhrsEvents, AhrsIndexedEvents {
}
/**
 * A publisher for AHRS information.
 */
declare class AhrsPublisher extends SimVarPublisher<AhrsEvents> {
    private magVar;
    private needUpdateMagVar;
    /**
     * Creates an AhrsPublisher.
     * @param bus The event bus to which to publish.
     * @param attitudeIndicatorCount The number of attitude indicators.
     * @param directionIndicatorCount The number of direction indicators.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus: EventBus, attitudeIndicatorCount: number, directionIndicatorCount: number, pacer?: PublishPacer<AhrsEvents>);
    /** @inheritdoc */
    protected onTopicSubscribed(topic: keyof AhrsEvents): void;
    /** @inheritdoc */
    onUpdate(): void;
}

/**
 * any kind of initable instrument
 */
interface Instrument {
    /** the init function */
    init: () => void;
    /** the update function */
    onUpdate: () => void;
}
/**
 * InstrumentBackplane provides a common control point for aggregating and
 * managing any number of publishers.  This can be used as an "update loop"
 * corral", amongst other things.
 */
declare class InstrumentBackplane {
    private publishers;
    private instruments;
    /**
     * Create an InstrumentBackplane
     */
    constructor();
    /**
     * Initialize all the things. This is initially just a proxy for the
     * private initPublishers() and initInstruments() methods.
     *
     * This should be simplified.
     */
    init(): void;
    /**
     * Update all the things.  This is initially just a proxy for the private
     * updatePublishers() and updateInstruments() methods.
     *
     * This should be simplified.
     */
    onUpdate(): void;
    /**
     * Add a publisher to the backplane.
     * @param name - a symbolic name for the publisher for reference
     * @param publisher - a publisher extending BasePublisher
     */
    addPublisher(name: string, publisher: BasePublisher<any>): void;
    /**
     * Add an instrument to the backplane.
     * @param name - a symbolic name for the publisher for reference
     * @param instrument - an instrument implementing Instrment
     */
    addInstrument(name: string, instrument: Instrument): void;
    /**
     * Initialize all of the publishers that you hold.
     */
    private initPublishers;
    /**
     * Initialize all of the instruments that you hold.
     */
    private initInstruments;
    /**
     * Update all of the publishers that you hold.
     */
    private updatePublishers;
    /**
     * Update all of the instruments that you hold.
     */
    private updateInstruments;
}

/**
 * An interface that describes GNSS event bus events.
 */
interface GNSSEvents {
    /** A GNSS location change event. */
    ['gps-position']: LatLongAlt;
    /** The current zulu time change event. */
    zulu_time: number;
    /** The current time of day change event. */
    time_of_day: number;
    /** The plane ground track, in degrees true north. */
    track_deg_true: number;
    /** The plane ground track, in degrees magnetic north. */
    track_deg_magnetic: number;
    /** The plane ground speed, in knots. */
    ground_speed: number;
    /** The current magnetic variation at the plane position. */
    magvar: number;
}
/**
 * A publisher for basic GNSS information.
 */
declare class GNSSPublisher extends BasePublisher<GNSSEvents> {
    /**
     * Create an GNSSPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus: EventBus, pacer?: PublishPacer<GNSSEvents> | undefined);
    /**
     * A callback called when the publisher updates.
     */
    onUpdate(): void;
    /**
     * Publishes the gps-position event.
     */
    private publishPosition;
    /**
     * Publishes the zulu_time and time_of_day events.
     */
    private publishTime;
    /**
     * Publishes the track_deg_true and track_deg_magnetic events.
     */
    private publishTrack;
    /**
     * Publishes the ground_speed event.
     */
    private publishGroundSpeed;
    /**
     * Publishes the ground_speed event.
     */
    private publishMagVar;
}

/** SimVar definitions for a NavComSimVarPublisher */
interface NavComSimVars {
    /** NAV active freq */
    [nav_active_frequency: IndexedEventType<'nav_active_frequency'>]: number;
    /** NAV standby freq */
    [nav_standby_frequency: IndexedEventType<'nav_standby_frequency'>]: number;
    /** NAV ident */
    [nav_ident: IndexedEventType<'nav_ident'>]: string;
    /** NAV signal */
    [nav_signal: IndexedEventType<'nav_signal'>]: number;
    /** COM active freq */
    [com_active_frequency: IndexedEventType<'com_active_frequency'>]: number;
    /** COM standby freq */
    [com_standby_frequency: IndexedEventType<'com_standby_frequency'>]: number;
    /** ADF Standby Frequency */
    [adf_standby_frequency: IndexedEventType<'adf_standby_frequency'>]: number;
    /** ADF Active Frequency */
    [adf_active_frequency: IndexedEventType<'adf_active_frequency'>]: number;
    /** COM Status */
    [com_status: IndexedEventType<'com_status'>]: number;
}
/** A publisher to poll and publish nav/com simvars. */
declare class NavComSimVarPublisher extends SimVarPublisher<NavComSimVars> {
    private static simvars;
    /**
     * Create a NavComSimVarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus: EventBus, pacer?: PublishPacer<NavComSimVars> | undefined);
}
/**
 * A convenience class for creating a radio configuration set.
 *
 * Implementers should instantiate this and then populate the various maps
 * with the H events that their radio sends and which displays they affect.
 */
declare class NavComConfig {
    navSwitchEvents: Map<string, string>;
    navSelectorEvents: Map<string, string>;
    navWholeIncEvents: Map<string, string>;
    navWholeDecEvents: Map<string, string>;
    navFractionIncEvents: Map<string, string>;
    navFractionDecEvents: Map<string, string>;
    comSwitchEvents: Map<string, string>;
    comSelectorEvents: Map<string, string>;
    comWholeIncEvents: Map<string, string>;
    comWholeDecEvents: Map<string, string>;
    comFractionIncEvents: Map<string, string>;
    comFractionDecEvents: Map<string, string>;
    comVolumeIncEvents: Map<string, string>;
    comVolumeDecEvents: Map<string, string>;
    navVolumeIncEvents: Map<string, string>;
    navVolumeDecEvents: Map<string, string>;
}
/**
 * The core instrument that will drive all of a system's radios.
 */
declare class NavComInstrument {
    private bus;
    private hevents;
    private publisher;
    private simVarPublisher;
    private simVarSubscriber;
    private controlSubscriber;
    private navRadios;
    private comRadios;
    private config?;
    /**
     * Create a NavComController.
     * @param bus The event bus to publish to.
     * @param config A NavComConfig object defining the radio configuration.
     * @param numNavRadios The number of nav radios in the system.
     * @param numComRadios The number of com radios in the system.
     * @param sync Whether to sync events or not, default true.
     */
    constructor(bus: EventBus, config: NavComConfig | undefined, numNavRadios: number, numComRadios: number, sync?: boolean);
    /**
     * Initialize the instrument.
     */
    init(): void;
    /**
     * Perform events for the update loop.
     */
    onUpdate(): void;
    /**
     * Get the current frequency of a radio.
     * @param radioType The RadioType to query.
     * @param index The index number of the desired radio.
     * @param bank The FrequencyBank to query.
     * @returns The frequency in MHz.
     */
    private getFrequency;
    /**
     * React to a change on a radio frequency simvar.
     * @param type The RadioType to update.
     * @param index Index of the radio in the internal array.
     * @param bank The FrequencyBank in the selected radio to update.
     * @param freq The new frequency in MHz.
     */
    private updateRadioFreqCb;
    /**
     * Handle an hEvent.
     * @param hEvent The event that needs to be handled.
     */
    private eventHandler;
    /**
     * Get the current selected radio in a collection of radios.
     * @param radios An array of Radios.
     * @returns The selected Radio in the array.
     */
    private getSelectedRadio;
    /**
     * Swap frequencies in a radio.
     * @param radio The radio whose frequencies we want to swap.
     */
    private swapFreqs;
    /**
     * Update the frequencies in a radio from simvars.
     *
     * This is useful for snapshot updates as long as we're not worried
     * about one of the frequencies being updated while the snapshot is in
     * flight.
     * @param radio the radio to update
     */
    private updateAndPublish;
    /**
     * Explicitly set a new selected nav radio.
     * @param navSourceId An array of Radios to toggle.
     */
    private setActiveRadio;
    /**
     * Set the standby frequency of the currently selected nav or com radio.
     * @param radioType The radio type we want to set standby for.
     * @param frequency The frequency in MHz as a string.
     */
    private setStandbyFreq;
    /**
     * Toggle which of the radios is selected.
     * @param radios An array of Radios to toggle.
     */
    private swapSelection;
    /**
     * Increase the volume of the selected nav or com radio.
     * @param radio The radio whose volume we want to increase.
     */
    private volumeInc;
    /**
     * Increase the volume of the selected nav or com radio.
     * @param radio The radio whose volume we want to increase.
     */
    private volumeDec;
    /**
     * Increase the integer portion of a frequency.
     * @param radio The Radio to update.
     */
    private wholeInc;
    /**
     * Decrease the integer portion of a frequency.
     * @param radio The Radio to update.
     */
    private wholeDec;
    /**
     * Increase the decimal portion of a frequency.
     * @param radio The Radio to update.
     */
    private fractInc;
    /**
     * Decrease the decimal portion of a frequency.
     * @param radio The Radio to update.
     */
    private fractDec;
    /**
     * Set the full frequency of a radio.
     * @param radio The Radio to update.
     * @param bank The FrequencyBank to update.
     * @param freq The new frequency in MHz as a string.
     */
    private freqSet;
    /**
     * Set the K var for a frequency event
     * @param action A string defining whole/fract and inc/dec.
     * @param radio The radio this frequency is for.
     */
    private setKVar;
    /**
     * Send an update of all our radio states.
     * @param data True if we really want to do this.  (We need to support non-paramaterized commands.())
     */
    private publishRadioStates;
    /**
     * Sets the COM frequency spacing.
     * @param evt The event that is setting the spacing.
     */
    private setComSpacing;
}

/** Data related to autopilot */
interface APSimVarEvents {
    /** Whether the autopilot master is active. */
    ap_master_status: boolean;
    /** Whether the yaw damper is active. */
    ap_yd_status: boolean;
    /** Whether the autopilot is in heading hold mode. */
    ap_heading_hold: boolean;
    /** Whether the autopilot is in NAV mode. */
    ap_nav_hold: boolean;
    /** Whether the autopilot is in approach mode. */
    ap_approach_hold: boolean;
    /** Whether the autopilot is in backcourse mode. */
    ap_backcourse_hold: boolean;
    /** Whether the autopilot is in bank hold mode. */
    ap_bank_hold: boolean;
    /** The autopilot max bank value ID (usually 0 for standard, 1 for half bank). */
    ap_max_bank_id: number;
    /** The current set autopilot max bank value in absolute degrees. */
    ap_max_bank_value: number;
    /** Whether the autopilot is in wings level mode. */
    ap_wing_lvl_hold: boolean;
    /** Whether the autopilot is in vertical speed hold mode. */
    ap_vs_hold: boolean;
    /** Whether the autopilot is in flight level change mode. */
    ap_flc_hold: boolean;
    /** Whether the autopilot is in altitude hold mode. */
    ap_alt_hold: boolean;
    /** Whether the autopilot is in glideslope hold mode. */
    ap_glideslope_hold: boolean;
    /** Whether the autopilot is in pitch hold mode. */
    ap_pitch_hold: boolean;
    /** The autopilot's selected pitch target, in degrees. */
    ap_pitch_selected: number;
    /** The autopilot's selected heading, in degrees. */
    ap_heading_selected: number;
    /** The autopilot's selected altitude, in feet. */
    ap_altitude_selected: number;
    /** The autopilot's selected vertical speed target, in feet per minute. */
    ap_vs_selected: number;
    /** The autopilot's selected airspeed target, in knots. */
    ap_ias_selected: number;
    /** The autopilot's selected mach target. */
    ap_mach_selected: number;
    /** Whether the autopilot's selected airspeed target is in mach. */
    ap_selected_speed_is_mach: boolean;
    /** The bank commanded by the flight director, in degrees. */
    flight_director_bank: number;
    /** The pitch commanded by the flight director, in degrees. */
    flight_director_pitch: number;
    /** Whether the flight director is active. */
    [flight_director_is_active: IndexedEventType<'flight_director_is_active'>]: boolean;
    /** Whether VNAV is active. */
    vnav_active: boolean;
}
declare enum APLockType {
    Heading = 0,
    Nav = 1,
    Alt = 2,
    Bank = 3,
    WingLevel = 4,
    Vs = 5,
    Flc = 6,
    Pitch = 7,
    Approach = 8,
    Backcourse = 9,
    Glideslope = 10,
    VNav = 11
}
/** The events related to an autopilot */
interface APEvents extends APSimVarEvents {
    /** Autopilot has been engaged. */
    ap_master_engage: true;
    /** Autopilot has been disengaged. */
    ap_master_disengage: true;
    /** Yaw damper has been engaged. */
    ap_yd_engage: true;
    /** Yaw damper has been disengaged. */
    ap_yd_disengage: true;
    /** An autopilot lock has been set. */
    ap_lock_set: APLockType;
    /** An autopilot lock has been released. */
    ap_lock_release: APLockType;
}
/** base publisher for simvars */
declare class APSimVarPublisher extends SimVarPublisher<APSimVarEvents> {
    private static simvars;
    /**
     * Create an APSimVarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus: EventBus, pacer?: PublishPacer<APSimVarEvents> | undefined);
}
/**
 * Publishes autopilot data
 */
declare class AutopilotPublisher extends BasePublisher<APEvents> {
    /**
     * Creates an AutopilotPublisher
     * @param bus The event bus to publish to.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus: EventBus, pacer?: PublishPacer<APEvents>);
    /**
     * Publish an AP master engage event
     */
    publishMasterEngage(): void;
    /**
     * Publish an AP master disengage event
     */
    publishMasterDisengage(): void;
    /**
     * Publish a YD engage event
     */
    publishYdEngage(): void;
    /**
     * Publish a YD disengage event
     */
    publishYdDisengage(): void;
    /**
     * Publish a lock set event
     * @param lock The lock/hold set
     */
    publishLockSet(lock: APLockType): void;
    /**
     * Publish a lock release event
     * @param lock The lock/hold released
     */
    publishLockRelease(lock: APLockType): void;
}
/**
 * Manages an autopilot system
 */
declare class AutopilotInstrument {
    private bus;
    publisher: AutopilotPublisher;
    simVarPublisher: APSimVarPublisher;
    private simVarSubscriber;
    /**
     * Create an AutopilotInstrument
     * @param bus The event bus to publish to
     */
    constructor(bus: EventBus);
    /**
     * Initialize the instrument
     */
    init(): void;
    /** update our publishers */
    onUpdate(): void;
}

/** Simvars used by a NavProcessor */
interface NavProcSimVars {
    /** the selected OBS heading for Nav */
    [nav_obs: IndexedEventType<'nav_obs'>]: number;
    /** the course deviation for Nav */
    [nav_cdi: IndexedEventType<'nav_cdi'>]: number;
    /** the distance to Nav */
    [nav_dme: IndexedEventType<'nav_dme'>]: number;
    /** does the nav have DME */
    [nav_has_dme: IndexedEventType<'nav_has_dme'>]: boolean;
    /** does the nav have nav */
    [nav_has_nav: IndexedEventType<'nav_has_nav'>]: boolean;
    /** the radial for Nav */
    [nav_radial: IndexedEventType<'nav_radial'>]: number;
    /** signal strength for Nav */
    [nav_signal: IndexedEventType<'nav_signal'>]: number;
    /** the ident for Nav */
    [nav_ident: IndexedEventType<'nav_ident'>]: string;
    /** Nav tofrom flag */
    [nav_to_from: IndexedEventType<'nav_to_from'>]: VorToFrom;
    /** Nav localizer flag */
    [nav_localizer: IndexedEventType<'nav_localizer'>]: boolean;
    /** Nav localizer course */
    [nav_localizer_crs: IndexedEventType<'nav_localizer_crs'>]: number;
    /** Nav glideslope flag */
    [nav_glideslope: IndexedEventType<'nav_glideslope'>]: boolean;
    /** Nav glideslope error */
    [nav_gs_error: IndexedEventType<'nav_gs_error'>]: number;
    /** Nav raw glideslope angle */
    [nav_raw_gs: IndexedEventType<'nav_raw_gs'>]: number;
    /** Nav glideslope end position. */
    [nav_gs_lla: IndexedEventType<'nav_gs_lla'>]: LatLongAlt;
    /** Nav magvar correction */
    [nav_magvar: IndexedEventType<'nav_magvar'>]: number;
    /** DTK to the next GPS waypoint */
    gps_dtk: number;
    /** XTK error for the next GPS waypoint */
    gps_xtk: number;
    /** next GPS waypoint */
    gps_wp: string;
    /** next GPS waypoint bearing */
    gps_wp_bearing: number;
    /** next GPS waypoint distance */
    gps_wp_distance: number;
    /** ADF signal strength */
    [adf_signal: IndexedEventType<'adf_signal'>]: number;
    /** ADF bearing */
    [adf_bearing: IndexedEventType<'adf_bearing'>]: number;
    /** Marker Beacon State */
    mkr_bcn_state_simvar: MarkerBeaconState;
    /** Nav Tuned LLA */
    [nav_lla: IndexedEventType<'nav_lla'>]: LatLongAlt;
    /** GPS Obs Active */
    gps_obs_active_simvar: boolean;
    /** GPS Obs Value Setting */
    gps_obs_value_simvar: number;
}
/** Publish simvars for ourselves */
declare class NavProcSimVarPublisher extends SimVarPublisher<NavProcSimVars> {
    private static simvars;
    /**
     * Create a NavProcSimVarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus: EventBus, pacer?: PublishPacer<NavProcSimVars> | undefined);
}
declare enum NavSourceType {
    Nav = 0,
    Gps = 1,
    Adf = 2
}
declare enum VorToFrom {
    OFF = 0,
    TO = 1,
    FROM = 2
}
/** Specified for a particular navigation source */
declare type NavSourceId = {
    /** The type of source it is. */
    type: NavSourceType | null;
    /** The index of this in the given source type. */
    index: number;
};
/** The OBS setting for a nav source. */
declare type ObsSetting = {
    /** the nav source */
    source: NavSourceId;
    /** the setting in degrees */
    heading: number | null;
};
/** the deviation setting for a nav source */
declare type CdiDeviation = {
    /** the nav source */
    source: NavSourceId;
    /** the setting in degrees */
    deviation: number | null;
};
/** The to/from value for a vor radio. */
declare type VorToFromSetting = {
    /** the to/from setting for the VOR */
    toFrom: VorToFrom;
    /** the nav source id */
    source: NavSourceId;
};
/** The dme state for a nav radio. */
declare type DmeState = {
    /** whether the radio has DME */
    hasDme: boolean;
    /** this distance to the DME station */
    dmeDistance: number | null;
    /** the nav source id */
    source: NavSourceId;
};
/** whether a nav source has a localizer signal. */
declare type Localizer = {
    /** whether there is a localizer signal */
    isValid: boolean;
    /** the localizer course */
    course: number;
    /** the nav source id */
    source: NavSourceId;
};
/** whether a nav source is tuned to a localizer frequency. */
declare type LocalizerFrequency = {
    /** if the freq is a loc */
    isLocalizer: boolean;
    /** the nav source id */
    source: NavSourceId;
};
/** whether a nav source has a glideslope signal. */
declare type Glideslope = {
    /** whether there is a gs signal */
    isValid: boolean;
    /** the gs deviation value */
    deviation: number;
    /** the angle of the gs */
    gsAngle: number;
    /** the nav source id */
    source: NavSourceId;
};
/** The magnetic variation for a tuned nav station. */
declare type NavMagneticVariation = {
    /** the magnetic variation value */
    variation: number;
    /** the nav source id */
    source: NavSourceId;
};
/** The validity for a bearing source. */
declare type BearingValidity = {
    /** the index number of the reference being changed */
    index: number;
    /** the new validity */
    valid: boolean;
};
/** The ident for a bearing source. */
declare type BearingIdent = {
    /** the index number of the reference being changed */
    index: number;
    /** the new ident */
    ident: string | null;
    /** is this station a loc */
    isLoc: boolean | null;
};
/** An indexed source setting */
declare type BearingSource = {
    /** the index number of the reference being changed */
    index: number;
    /** the new source instrument */
    source: NavSourceId | null;
};
/** An indexed source setting */
declare type BearingDirection = {
    /** the index number of the reference being changed */
    index: number;
    /** the new source instrument */
    direction: number | null;
};
/** An indexed source setting */
declare type BearingDistance = {
    /** the index number of the reference being changed */
    index: number;
    /** the new source instrument */
    distance: number | null;
};
/** If the bearing source is a localizer. */
declare type BearingIsLoc = {
    /** the index number of the reference being changed */
    index: number;
    /** if the source is a loc */
    isLoc: boolean | null;
};
/** Marker beacon signal state. */
declare enum MarkerBeaconState {
    Inactive = 0,
    Outer = 1,
    Middle = 2,
    Inner = 3
}
/** navprocessor events */
interface NavEvents {
    /** an OBS heading in degrees*/
    obs_set: ObsSetting;
    /** a CDI selection event */
    cdi_select: NavSourceId;
    /** actual deviation in points */
    cdi_deviation: CdiDeviation;
    /** dme distance in nm */
    dme_distance: number;
    /** dme speed in kt */
    dme_speed: number;
    /** vor distance in m */
    vor_distance: number;
    /** nav to/from value */
    vor_to_from: VorToFromSetting;
    /** nav radio selected */
    nav_select: number;
    /** the validity of a bearing source */
    brg_validity: BearingValidity;
    /** the ident for a bearing needle */
    brg_ident: BearingIdent;
    /** changed source of a bearing needle */
    brg_source: BearingSource;
    /** changed distance of a bearing needle */
    brg_distance: BearingDistance;
    /** changed heading to a bearing source */
    brg_direction: BearingDirection;
    /** changed magnetic variation for a tune nav station */
    mag_variation: NavMagneticVariation;
    /** whether a localizer exists and its course */
    localizer: Localizer;
    /** whether a glideslope exists and its deviation */
    glideslope: Glideslope;
    /** whether a nav source frequency is a localizer frequency */
    is_localizer_frequency: LocalizerFrequency;
    /** Marker Beacon State */
    mkr_bcn_state: MarkerBeaconState;
    /** DME State */
    dme_state: DmeState;
    /** GPS Obs Active */
    gps_obs_active: boolean;
    /** GPS Obs Value Setting */
    gps_obs_value: number;
}
/** The interface to a nav source. */
interface NavSource {
    /** The ID of the source. */
    srcId: NavSourceId;
    /** The nav signal strength. */
    signal: number | null;
    /** Whether the source info is valed. */
    valid: boolean;
    /** Whether this is an active bearing source. */
    activeBrg: boolean;
    /** Whether this is an active CDI source. */
    activeCdi: boolean;
    /** Whether this source provides course deviation information. */
    hasCdi: boolean;
    /** Whether the source provides DME info. */
    hasDme: boolean;
    /** Whether the source has glideslope info. */
    hasGlideslope: boolean;
    /** Whether the source has localizer info. */
    hasLocalizer: boolean;
    /** Whether the source is a localizer frequency. */
    isLocalizerFrequency: boolean | null;
    /** A handler to call when source validity changes. */
    validHandler?: ((valid: boolean, source: NavSourceId) => void);
    /** A handler to call when the source ident changes. */
    identHandler?: ((ident: string | null, source: NavSourceId) => void);
    /** A handler to call when the bearing to the source changes. */
    brgHandler?: ((bearing: number | null, source: NavSourceId) => void);
    /** A handler to call when the distance to the source changes. */
    distHandler?: ((distance: number | null, source: NavSourceId) => void);
    /** A handler to call when the OBS setting for the source changes. */
    obsHandler?: ((heading: number | null, source: NavSourceId) => void);
    /** A handler to call when the lateral deviation from the source changes. */
    deviationHandler?: ((deviation: number | null, source: NavSourceId) => void);
    /** A handler to call when the to/from state of the source changes. */
    toFromHandler?: ((toFrom: VorToFrom, source: NavSourceId) => void);
    /** A handler to call when the vertical deviation from the source changes. */
    glideslopeDeviationHandler?: ((deviation: number | null, source: NavSourceId) => void);
    /** A handler to call when the angle on the glide slope changes. */
    glideslopeAngleHandler?: ((angle: number | null, source: NavSourceId) => void);
    /** A handler to call when the magvar of the source changes. */
    magvarHandler?: ((magvar: number | null, source: NavSourceId) => void);
    /** A handler to call when wtf.  */
    isLocalizerFrequencyHandler?: ((isLocalizer: boolean | null, source: NavSourceId) => void);
    /** The ident for this source. */
    ident: string | null;
    /** The bearing to this source. */
    bearing: number | null;
    /** Distance to the source. */
    distance: number | null;
    /** OBS bearing in degrees. */
    obs?: number;
    /** Deviation in points. */
    deviation?: number | null;
    /** The to/from state of the source. */
    toFrom?: VorToFrom;
    /** The localizer course. */
    localizerCourse?: number | null;
    /** The glideslope deviation. */
    glideslopeDeviation?: number | null;
    /** The glideslope angle. */
    glideslopeAngle?: number | null;
    /** The magnetic variation at the source. */
    magneticVariation?: number | null;
}
/**
 * A convenience class for creating a navproc configuration set.
 *
 * Implementers should instantiate this and then populate the sets with the
 * HEvents that their radio sends for various actions.
 */
declare class NavProcessorConfig {
    numNav: number;
    numGps: number;
    numAdf: number;
    courseIncEvents: Set<string>;
    courseDecEvents: Set<string>;
    courseSyncEvents: Set<string>;
    simVarPublisher?: NavProcSimVarPublisher;
    additionalSources: NavSource[];
}
/**
 * The core of tne nav processor
 */
declare class NavProcessor {
    private bus;
    private config;
    private cdiSourceIdx;
    private bearingSourceIdxs;
    private hEvents;
    private navComSubscriber;
    private publisher;
    private simVarPublisher;
    private controlSubscriber;
    private simVarSubscriber;
    private navSources;
    private readonly brgSrcAsoboMap;
    /**
     * Create a NavProcessor.
     * @param bus The event bus to publish to.
     * @param config A config object defining our radio options.
     */
    constructor(bus: EventBus, config: NavProcessorConfig);
    /**
     * Initialize a nav processor
     */
    init(): void;
    /**
     * Add a custom nav source to the processor.
     * @param source The implementation of NavSourceBase to add.
     */
    addNavSource(source: NavSource): void;
    /**
     * Process a CDI source change event.
     * @param index is specified if a specific cdiSourceIdx is requested
     */
    private switchCdiSrc;
    /**srcent.
     */
    private initCdi;
    /**
     * Process a bearing source change event.
     * @param index The index of the source to change (1-based).
     */
    private cycleBrgSrc;
    /**
     * Set the bearing source to the specified nav source index.
     * @param bearingSrcIndex The index of the bearing source to change (0-based).
     * @param navSrcIndex The index of the nav source to change to (0-based).
     */
    private setBrgSrc;
    /**
     * Handle HEvents
     * @param event The hEvent name
     */
    private eventHandler;
    /**
     * Handle a course inc event if we have a nav radio as our active CDI source.
     */
    private handleCrsInc;
    /**
     * Handle a course dec event if we have a nav radio as our active CDI source.
     */
    private handleCrsDec;
    /**
     * Handle a course sync event if we have a nav radio as our active CDI source.
     */
    private handleCrsSync;
    /**
     * Handle a bearing validity change.
     * @param valid The new bearing validity
     * @param source The source of
     */
    private onBrgValidity;
    /**
     * Handle a bearing distance change.
     * @param distance The distance to the source.
     * @param source The nav source ID.
     */
    private onBrgDistance;
    /**
     * Handle a bearing direction change.
     * @param direction The distance to the source.
     * @param source The nav source ID.
     */
    private onBrgDirection;
    /**
     * Handle a bearing ident change.
     * @param ident The ident of the source.
     * @param source The nav source ID.
     */
    private onBrgIdent;
    /**
     * Handle a localizer course change.
     * @param course The localizer course of the source.
     * @param source The nav source ID.
     */
    private onLocalizerCourse;
    /**
     * Handle a glideslope deviation change.
     * @param deviation The glideslope deviation of the source.
     * @param source The nav source ID.
     */
    private onGlideslopeDeviation;
    /**
     * Handle a glideslope angle change.
     * @param angle The glideslope angle of the source.
     * @param source The nav source ID.
     */
    private onGlideslopeAngle;
    /**
     * Determine whether a set frequency is a localizer frequency.
     * @param frequency The frequency to evaluate.
     * @returns a bool true if the frequency is a loc freq.
     */
    private frequencyIsLocalizer;
    /**
     * Publishers whether a set frequency is a localizer frequency.
     * @param isLoc whether the freq is a loc.
     * @param source the selected nav source.
     */
    private onIsLocalizerFrequency;
    /**
     * Publishers dme distance info.  This should be replaced by a generalization of
     * BearingDistance that provides the distance to any nav source if it has DME.
     * @param hasDme whether the radio has dme.
     * @param distance is the dme distance.
     * @param source the selected nav source.
     */
    private onDme;
    /**
     * Toggles CDI between GPS and NAV1.
     */
    private onCdiGpsToggle;
    /**
     * Gets the index of the first nav source of the given type.
     * @param type The type of nav source to find.
     * @returns The nav source index.
     */
    private getFirstNavSourceIndexByType;
    /**
     * Perform events for the update loop.
     */
    onUpdate(): void;
}

/**
 * An interface that describes the possible Engine Parameter events
 * on the event bus.
 */
declare type EngineEvents = {
    /** An RPM for engine 1. */
    rpm_1: number;
    /** An RPM for engine 2. */
    rpm_2: number;
    /** N1% for engine 1 */
    n1_1: number;
    /** N1% for engine 2 */
    n1_2: number;
    /** N2% for engine 1 */
    n2_1: number;
    /** N2% for engine 2 */
    n2_2: number;
    /** Fuel flow rate, in gallons per hour, for an indexed engine. */
    [fuel_flow: IndexedEventType<'fuel_flow'>]: number;
    /** Total fuel flow rate, in gallons per hour. */
    fuel_flow_total: number;
    /** A fuel flow rate for recip engine 1 */
    recip_ff_1: number;
    /** A fuel flow rate for recip engine 2 */
    recip_ff_2: number;
    /** A oil press for engine 1 */
    oil_press_1: number;
    /** A oil press for engine 2 */
    oil_press_2: number;
    /** A oil temp for engine 1 */
    oil_temp_1: number;
    /** A oil temp for engine 2 */
    oil_temp_2: number;
    /** ITT in celsius for engine 1 */
    itt_1: number;
    /** ITT in celsius for engine 2 */
    itt_2: number;
    /** A egt for engine 1 */
    egt_1: number;
    /** A egt for engine 2 */
    egt_2: number;
    /** A pressure value for vacuum system */
    vac: number;
    /** The total amount of fuel remaining, in gallons. */
    fuel_total: number;
    /** The amount of fuel remaining in the left tank, in gallons. */
    fuel_left: number;
    /** The amount of fuel remaining in the right tank, in gallons. */
    fuel_right: number;
    /**
     * The fuel weight per gallon, in pounds per gallon
     */
    fuel_weight_per_gallon: number;
    /** A hours value for engine 1 total elapsed time */
    eng_hours_1: number;
    /** A hydraulic pressure value for engine 1 */
    eng_hyd_press_1: number;
    /** A hydraulic pressure value for engine 2 */
    eng_hyd_press_2: number;
    /** A value indicating if engine 1 starter is on */
    eng_starter_1: number;
    /** A value indicating if engine 2 starter is on */
    eng_starter_2: number;
    /** A value indicating if engine 1 combustion is on */
    eng_combustion_1: number;
    /** A value indicating if engine 2 combustion is on */
    eng_combustion_2: number;
    /** A value indicating if engine 1 manual ignition is on */
    eng_manual_ignition_1: number;
    /** A value indicating if engine 2 manual ignition is on */
    eng_manual_ignition_2: number;
};
/**
 * A publisher for Engine information.
 */
declare class EISPublisher extends SimVarPublisher<EngineEvents> {
    private static simvars;
    private readonly engineCount;
    /**
     * Create an EISPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus: EventBus, pacer?: PublishPacer<EngineEvents> | undefined);
    /** @inheritdoc */
    onUpdate(): void;
}

/**
 * Events related to the clock.
 */
interface ClockEvents {
    /** A UNIX timestamp corresponding to the real-world (operating system) time. */
    realTime: number;
    /** A UNIX timestamp corresponding to the simulation time. */
    simTime: number;
}
/**
 * A publisher of clock events.
 */
declare class ClockPublisher extends BasePublisher<ClockEvents> {
    onUpdate(): void;
    /**
     * Converts the sim's absolute time to a UNIX timestamp. The sim's absolute time value is equivalent to a .NET
     * DateTime.Ticks value (epoch = 00:00:00 01 Jan 0001).
     * @param absoluteTime an absolute time value, in units of seconds.
     * @returns the UNIX timestamp corresponding to the absolute time value.
     */
    private static absoluteTimeToUNIXTime;
}
/**
 * A clock which keeps track of real-world and sim time.
 */
declare class Clock {
    private publisher;
    /**
     * Constructor.
     * @param bus The event bus to use to publish events from this clock.
     */
    constructor(bus: EventBus);
    /**
     * Initializes this clock.
     */
    init(): void;
    /**
     * Updates this clock.
     */
    onUpdate(): void;
}

/** The basic radio types. */
declare enum RadioType {
    Com = "COM",
    Nav = "NAV",
    Adf = "ADF"
}
/** Encapsulates a single radio's state. */
declare type Radio = {
    /** Index number of the radio. */
    index: number;
    /** The current active frequency. */
    activeFrequency: number;
    /** The ident of the active station */
    ident: string | null;
    /** Signal strength of the active station. */
    signal: number;
    /** The current standby frequency. */
    standbyFrequency: number;
    /** The appropriate RadioType for this radio. */
    radioType: RadioType;
    /** Whether this radio is selected for changes. */
    selected: boolean;
};
/** The two frequency "banks", active and standby. */
declare enum FrequencyBank {
    Active = 0,
    Standby = 1
}
/** Events relating to changes in a radio's state. */
interface RadioEvents {
    /** Set the state of a radio. */
    set_radio_state: Radio;
    /** Change the stanby frequency in a radio. */
    set_frequency: FrequencyChangeEvent;
    /** Publish the ident of a tuned station. */
    set_ident: IdentChangeEvent;
    /** Publish the signal strength of the active station. */
    set_signal_strength: number;
    /** ADF1 Standby Frequency */
    adf_standby_frequency_1: number;
    /** ADF1 Active Frequency */
    adf_active_frequency_1: number;
}
/** Encapsuation of a frequency change event. */
declare type FrequencyChangeEvent = {
    /** The type of radio to change. */
    radio: Radio;
    /** The frequency bank to update. */
    bank: FrequencyBank;
    /** The new frequency in MHz. */
    frequency: number;
};
/** Encapsulation of a new ident event */
declare type IdentChangeEvent = {
    /** The radio currently tuned. */
    index: number;
    /** The new ident. */
    ident: string;
};
/** COM frequency spacing on COM radios. */
declare enum ComSpacing {
    /** 25Khz spacing */
    Spacing25Khz = 0,
    /** 8.33Khz spacing */
    Spacing833Khz = 1
}
/** Encapsulation of a COM spacing change event. */
declare type ComSpacingChangeEvent = {
    /** The index of the COM radio to update. */
    index: number;
    /** The spacing of the COM radio. */
    spacing: ComSpacing;
};

/** Simvar definitions related to a transponder. */
interface XPDRSimVarEvents {
    /** Transponder code. */
    [xpdr_code: IndexedEventType<'xpdr_code'>]: number;
    /** Transponder mode. */
    [xpdr_mode: IndexedEventType<'xpdr_mode'>]: XPDRMode;
    /** Whether the transponder is sending ident. */
    [xpdr_ident: IndexedEventType<'xpdr_ident'>]: boolean;
}
/** Transponder modes. */
declare enum XPDRMode {
    OFF = 0,
    STBY = 1,
    TEST = 2,
    ON = 3,
    ALT = 4,
    GROUND = 5
}
/** A publiher to poll transponder simvars. */
declare class XPDRSimVarPublisher extends SimVarPublisher<XPDRSimVarEvents> {
    /**
     * Create an XPDRSimVarPublisher.
     * @param bus The EventBus to publish to.
     * @param pacer An optional pacer to use to control the pace of publishing.
     * @param transponderCount The number of transponders supported by this publisher.
     */
    constructor(bus: EventBus, pacer?: PublishPacer<XPDRSimVarEvents> | undefined, transponderCount?: number);
}
/** A transponder. */
declare class XPDRInstrument {
    private readonly bus;
    private readonly transponderCount;
    private simVarPublisher;
    private controlSubscriber;
    private readonly identDebounceTimers;
    /**
     * Create an XPDRInstrument.
     * @param bus The event bus to publish to.
     * @param transponderCount The number of transponders supported by this instrument. Defaults to `1`.
     */
    constructor(bus: EventBus, transponderCount?: number);
    /** Initialize the instrument. */
    init(): void;
    /**
     * Perform events for the update loop.
     */
    onUpdate(): void;
    /**
     * Set the transponder code in the sim.
     * @param index The index of the transponder.
     * @param code The xpdr code.
     */
    private setXpdrCode;
    /**
     * Set the transponder mode in the sim.
     * @param index The index of the transponder.
     * @param mode The transponder mode.
     */
    private setXpdrMode;
    /**
     * Gets xpdr mode from the sim.
     * @param index The index of the transponder.
     * @returns The xpdr mode.
     */
    private getXpdrMode;
    /**
     * Sends ident to ATC for 18 seconds.
     * @param index The index of the transponder.
     */
    private sendIdent;
}

/**
 * Traffic events.
 */
interface TrafficEvents {
    /** A traffic contact was added. The value is the uid of the new contact. */
    traffic_contact_added: number;
    /** A traffic contact was updated. The value is the uid of the updated contact. */
    traffic_contact_updated: number;
    /** A traffic contact was removed. The value is the uid of the removed contact. */
    traffic_contact_removed: number;
}
/**
 * A traffic contact.
 */
interface TrafficContact {
    /** A unique ID number assigned to this contact. */
    readonly uid: number;
    /** The last time of contact, in sim time, as a UNIX millisecond timestamp. */
    readonly lastContactTime: number;
    /** The position of this contact at time of last contact. */
    readonly lastPosition: GeoPointReadOnly;
    /** The altitude of this contact at time of last contact. */
    readonly lastAltitude: NumberUnitReadOnly<UnitFamily.Distance>;
    /** The heading of this contact at time of last contact. */
    readonly lastHeading: number;
    /** The most recent calculated ground speed of this contact. Equal to NaN if not yet been calculated. */
    readonly groundSpeed: NumberUnitReadOnly<UnitFamily.Speed>;
    /** The most recent calculated ground track of this contact. Equal to NaN if not yet been calculated. */
    readonly groundTrack: number;
    /** The most recent calculaed vertical speed of this contact. Equal to NaN if not yet been calculated. */
    readonly verticalSpeed: NumberUnitReadOnly<UnitFamily.Speed>;
    /**
     * Calculates the predicted position and altitude of this contact at a specified time based on the most recent
     * available data and stores the results in the supplied objects. If insufficient data are available to calculate
     * the prediction, the results will be equal to NaN.
     * @param simTime The sim time for which to calculate the prediction, as a UNIX millisecond timestamp.
     * @param positionOut A GeoPoint object to which to write the predicted position.
     * @param altitudeOut A NumberUnit object to which to write the predicted altitude.
     */
    predict(simTime: number, positionOut: GeoPoint, altitudeOut: NumberUnit<UnitFamily.Distance>): void;
}
/**
 * Initialization options for TrafficInstrument.
 */
declare type TrafficInstrumentOptions = {
    /** The maximum update frequency (Hz) in real time. */
    realTimeUpdateFreq: number;
    /** The maximum update frequency (Hz) in sim time. */
    simTimeUpdateFreq: number;
    /**
     * The maximum amount of sim time elapsed, in milliseconds, since last contact allowed before a contact is
     * deprecated.
     */
    contactDeprecateTime: number;
};
/**
 * Tracks aircraft traffic. Maintains a list of contacts, periodically updates their position, altitude, and reported
 * heading, and uses these data to compute ground speed, ground track, and vertical speed.
 */
declare class TrafficInstrument implements Instrument {
    private readonly bus;
    private readonly options;
    private readonly tracked;
    private lastUpdateRealTime;
    private lastUpdateSimTime;
    private isBusy;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param options Options with which to initialize this instrument.
     */
    constructor(bus: EventBus, options: TrafficInstrumentOptions);
    /**
     * Retrieves a traffic contact by its assigned ID number.
     * @param uid an ID number.
     * @returns the traffic contact with the assigned ID number, or undefined if no such contact exists.
     */
    getContact(uid: number): TrafficContact | undefined;
    /**
     * Iterates through all tracked traffic contacts with a visitor function.
     * @param visitor A visitor function.
     */
    forEachContact(visitor: (contact: TrafficContact) => void): void;
    /**
     * Initializes this instrument. Once initialized, this instrument will automatically track and update traffic
     * contacts.
     */
    init(): void;
    /**
     * Updates this instrument's list of contacts.
     * @param data An array of the most recent traffic data entries.
     * @param simTime The sim time at which the traffic data was generated.
     */
    private updateContacts;
    /**
     * Creates a contact.
     * @param entry The traffic data entry from which to create the new contact.
     * @param simTime The sim time at which the traffic data entry was generated.
     */
    private createContact;
    /**
     * Updates a contact.
     * @param contact The contact to update.
     * @param entry The current traffic data entry for the contact.
     * @param simTime The sim time at which the traffic data entry was generated.
     */
    private updateContact;
    /**
     * Removes all contacts whose time since last contact exceeds the deprecation threshold.
     * @param simTime The current sim time.
     */
    private deprecateContacts;
    /**
     * A callback which is called when the sim time changes.
     * @param simTime The current sim time.
     */
    private onSimTimeChanged;
    /**
     * This method does nothing.
     */
    onUpdate(): void;
}

/**
 * An interface that describes the possible Control Surface events
 * on the event bus.
 */
declare type ControlSurfacesEvents = {
    /** The handle index for flaps. */
    flaps_handle_index: number;
    /** The flaps trailing edge angle. */
    flaps_angle: number;
    /** The percent of applied elevator trim. */
    elevator_trim_pct: number;
    /** The neutral position in percent of the elevator trim. */
    elevator_trim_neutral_pct: number;
    /** The percent of applied aileron trim. */
    aileron_trim_pct: number;
    /** The percent of applied rudder trim. */
    rudder_trim_pct: number;
    /** The position index of the gear. */
    gear_position_index: number;
};
/**
 * A publisher for control surfaces information.
 */
declare class ControlSurfacesPublisher extends SimVarPublisher<ControlSurfacesEvents> {
    private static simvars;
    /**
     * Create an ControlSurfacesPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus: EventBus, pacer?: PublishPacer<ControlSurfacesEvents> | undefined);
}

/**
 * An event fired when the screen state changes.
 */
interface ScreenStateEvent {
    /** The current screen state. */
    current: ScreenState;
    /** The previous screen state. */
    previous: ScreenState | undefined;
}
/**
 * Events from the VCockpit BaseInstrument framework.
 */
interface InstrumentEvents {
    /** An event fired when the instrument is powered on or off. */
    'vc_powered': boolean;
    /** An event fired when the screen state changes. */
    'vc_screen_state': ScreenStateEvent;
    /** An event fired when the game state changes. */
    'vc_game_state': GameState;
    /** An event fired when the flight is started */
    'vc_flight_start': boolean;
}
/**
 * A publisher for VCockpit BaseInstrument events.
 */
declare class BaseInstrumentPublisher extends BasePublisher<InstrumentEvents> {
    private readonly instrument;
    private lastGameState;
    private lastIsPowered;
    private lastScreenState;
    private hasFlightStarted;
    /**
     * Creates an instance of BasePublisher.
     * @param instrument The BaseInstrument instance.
     * @param bus The common event bus.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(instrument: BaseInstrument, bus: EventBus, pacer?: PublishPacer<InstrumentEvents> | undefined);
    /** @inheritdoc */
    startPublish(): void;
    /** @inheritdoc */
    stopPublish(): void;
    /** @inheritdoc */
    onUpdate(): void;
    /**
     * Updates this publisher from the current game state.
     * @param gameState The current game state.
     */
    private updateFromGameState;
    /**
     * Updates this publisher from the current powered state.
     * @param isPowered The current powered state.
     */
    private updateFromPowered;
    /**
     * Updates this publisher from the current screen state.
     * @param screenState The current screen state.
     */
    private updateFromScreenState;
}

/**
 * Events relating to the electrical systems.
 */
interface ElectricalEvents {
    /** Master battery power is switched on or not. */
    'elec_master_battery': boolean;
    /** The avionics circuit is on or off. */
    [elec_circuit_avionics_on: IndexedEventType<'elec_circuit_avionics_on'>]: boolean;
    /** The navcom 1 circuit is on or off. */
    'elec_circuit_navcom1_on': boolean;
    /** The navcom 2 circuit is on of off. */
    'elec_circuit_navcom2_on': boolean;
    /** The navcom 3 circuit is on of off. */
    'elec_circuit_navcom3_on': boolean;
    /** The first avionics power bus. */
    'elec_av1_bus': boolean;
    /** The second avionics power bus. */
    'elec_av2_bus': boolean;
    /** A voltage value for the main elec bus */
    'elec_bus_main_v': number;
    /** A current value for the main elec bus */
    'elec_bus_main_a': number;
    /** A voltage value for the avionics bus */
    'elec_bus_avionics_v': number;
    /** A current value for the avinoics bus */
    'elec_bus_avionics_a': number;
    /** A voltage value for the generator/alternator 1 bus */
    'elec_bus_genalt_1_v': number;
    /** A voltage value for the generator/alternator 2 bus */
    'elec_bus_genalt_2_v': number;
    /** A current value for the generator/alternator 1 bus */
    'elec_bus_genalt_1_a': number;
    /** A current value for the generator/alternator 2 bus */
    'elec_bus_genalt_2_a': number;
    /** A voltage value for the battery */
    'elec_bat_v': number;
    /** A current value for the battery */
    'elec_bat_a': number;
}
/**
 * A publisher for electrical information.
 */
declare class ElectricalPublisher extends SimVarPublisher<ElectricalEvents> {
    private static simvars;
    private flightStarted;
    private av1BusLogic;
    private av2BusLogic;
    private avBusList;
    /**
     * Create an ElectricalPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus: EventBus, pacer?: PublishPacer<ElectricalEvents> | undefined);
    /** @inheritdoc */
    onUpdate(): void;
    /**
     * Called when the flight has started and electrical data is valid.
     * @param started True if the flight has started
     */
    setFlightStarted(started: boolean): void;
    /**
     * Sets the logic element to use for the avionics 1 bus.
     * @param logicElement The logic element to use.
     */
    setAv1Bus(logicElement: CompositeLogicXMLElement): void;
    /**
     * Sets the logic element to use for the avionics 2 bus.
     * @param logicElement The logic element to use.
     */
    setAv2Bus(logicElement: CompositeLogicXMLElement): void;
}

/**
 * Events related to the active navigation radio.
 */
interface NavRadioEvents {
    /** The location of the tuned glideslope on the active nav radio. */
    nav_radio_active_gs_location: LatLongAlt;
    /** The location of the tuned station on the active nav radio. */
    nav_radio_active_nav_location: LatLongAlt;
    /** Localizer data for the active nav radio. */
    nav_radio_active_localizer: Localizer;
    /** Glideslope data for the active nav radio. */
    nav_radio_active_glideslope: Glideslope;
    /** The obs setting of the current nav radio. */
    nav_radio_active_obs_setting: ObsSetting;
    /** The CDI deviation of the current nav radio. */
    nav_radio_active_cdi_deviation: CdiDeviation;
    /** The magnetic variation, in degrees, of the tuned station on the active nav radio. */
    nav_radio_active_magvar: number;
    /** The Nav1 Localizer. */
    nav_radio_localizer_1: Localizer;
    /** The Nav2 Localizer. */
    nav_radio_localizer_2: Localizer;
    /** The Nav1 CdiDeviation. */
    nav_radio_cdi_1: CdiDeviation;
    /** The Nav2 CdiDeviation. */
    nav_radio_cdi_2: CdiDeviation;
}
/**
 * An instrument that gathers localizer and glideslope information for use by
 * the AP systems.
 */
declare class APRadioNavInstrument implements Instrument {
    private readonly bus;
    private readonly navRadioData;
    private readonly navProc;
    private readonly publisher;
    private currentCdiIndex;
    /**
     * Creates an instance of the APRadioNavInstrument.
     * @param bus The event bus to use with this instance.
     */
    constructor(bus: EventBus);
    /** @inheritdoc */
    init(): void;
    /** @inheritdoc */
    onUpdate(): void;
    /**
     * Sets a value in a nav radio glideslope.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    private setGlideslopeValue;
    /**
     * Sends the current glideslope's LLA position.
     * @param index The index of the nav radio.
     * @param lla The LLA to send.
     */
    private setGlideslopePosition;
    /**
     * Sends the current nav's LLA position.
     * @param index The index of the nav radio.
     * @param lla The LLA to send.
     */
    private setNavPosition;
    /**
     * Sets a value in a nav radio localizer.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    private setLocalizerValue;
    /**
     * Sets a value in a nav radio localizer.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    private setCDIValue;
    /**
     * Sets a value in a nav radio localizer.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    private setOBSValue;
    /**
     * Sets the magnetic variation of a nav radio signal source.
     * @param index The index of the nav radio.
     * @param magVar The magvar to set.
     */
    private setMagVar;
    /**
     * Creates an empty localizer data.
     * @param id The nav source ID.
     * @returns New empty localizer data.
     */
    private createEmptyLocalizer;
    /**
     * Creates an empty glideslope data.
     * @param id The nav source ID.
     * @returns New empty glideslope data.
     */
    private createEmptyGlideslope;
    /**
     * Creates an empty CDI data.
     * @param id The nav source ID.
     * @returns New empty CDI data.
     */
    private createEmptyCdi;
    /**
     * Creates an empty OBS data.
     * @param id The nav source ID.
     * @returns New empty OBS data.
     */
    private createEmptyObs;
}

/**
 * An interface that describes the possible Pressurization events
 * on the event bus.
 */
interface PressurizationEvents {
    /** A cabin altitude value. */
    cabin_altitude: number;
    /** A cabin altitude rate value. */
    cabin_altitude_rate: number;
    /** A pressure differential value. */
    pressure_diff: number;
}
/**
 * A publisher for Pressurization information.
 */
declare class PressurizationPublisher extends SimVarPublisher<PressurizationEvents> {
    private static simvars;
    /**
     * Updates the ADC publisher.
     */
    onUpdate(): void;
    /**
     * Create an PressurizationPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus: EventBus, pacer?: PublishPacer<PressurizationEvents> | undefined);
}

/** Minimums Modes */
declare enum MinimumsMode {
    OFF = 0,
    BARO = 1,
    RA = 2,
    TEMP_COMP_BARO = 3
}
/** Events sourced from minimums-related simvars. */
interface MinimumsSimVarEvents {
    /** The current decision height in feet. */
    decision_height_feet: number;
    /** The current decision altitude in feet. */
    decision_altitude_feet: number;
    /** The current selected minimums mode. */
    minimums_mode: MinimumsMode;
}
/** Events for setting Minimums values */
interface MinimumsControlEvents {
    /** Set a new decision height in feet. */
    set_decision_height_feet: number;
    /** Set a new decision altitude in feet. */
    set_decision_altitude_feet: number;
    /** Set the decision height unit to manage increments. */
    set_dh_distance_unit: 'feet' | 'meters';
    /** Set the decision altitude unit to manage increments. */
    set_da_distance_unit: 'feet' | 'meters';
    /** Set the current selected minimums mode. */
    set_minimums_mode: MinimumsMode;
}
/** A common type for all minimums events. */
declare type MinimumsEvents = MinimumsSimVarEvents & MinimumsControlEvents;
/** A publisher for minimums simvar events. */
declare class MinimumsSimVarPublisher extends SimVarPublisher<MinimumsSimVarEvents> {
    private static simvars;
    /**
     * @inheritdoc
     */
    constructor(bus: EventBus);
}
/**
 * A class that manages decision height and altitude data and events.
 */
declare class MinimumsManager {
    private bus;
    private controlSubscriber;
    private currentDH;
    private currentDA;
    private daDistanceUnit;
    private dhDistanceUnit;
    /**
     * Create a MinimumsManager
     * @param bus The event bus
     */
    constructor(bus: EventBus);
}

/** Type for setting an indexed instrument source */
declare type IndexedNavSourceSetting = {
    /** The index of the specific device to increment  */
    index: number;
    /** The source to set this device to */
    source: NavSourceId;
};
/** Control events, for where HEvents don't exist */
interface ControlEvents {
    /** increment the CDI source */
    cdi_src_switch: boolean;
    /** explicitly set a CDI source */
    cdi_src_set: NavSourceId;
    /** toggle CDI source between GPS and NAV */
    cdi_src_gps_toggle: boolean;
    /** Set the source of a given bearing needle */
    brg_src_set: IndexedNavSourceSetting;
    /**Increment the source of a given bearing needle number */
    brg_src_switch: number;
    /**Publish radio state */
    publish_radio_states: boolean;
    /** Set new xpdr code */
    [publish_xpdr_code: IndexedEventType<'publish_xpdr_code'>]: number;
    /** Set new xpdr mode */
    [publish_xpdr_mode: IndexedEventType<'publish_xpdr_mode'>]: XPDRMode;
    /** Tell XPDR to send ident to ATC */
    [xpdr_send_ident: IndexedEventType<'xpdr_send_ident'>]: boolean;
    /** Init the CDI Source */
    init_cdi: boolean;
    /** toggle DME window */
    dme_toggle: boolean;
    /** Set the current standby com frequency as a string. */
    standby_com_freq: string;
    /** Set the COM spacing for a radio. */
    com_spacing_set: ComSpacingChangeEvent;
    /** Set the current standby nav frequency as a string. */
    standby_nav_freq: string;
    /** Event when user presses 'B' to auto set pressure. */
    baro_set: boolean;
    /** Event when a user suspends LNAV leg sequencing. */
    suspend_sequencing: boolean;
    /** Whether LNAV should automatically inhibit the next attempt to sequence to the next flight plan leg. */
    lnav_inhibit_next_sequence: boolean;
    /** Event for setting missed approach state. */
    activate_missed_approach: boolean;
    /** Approach Frequency Set by FMS. */
    approach_freq_set: FacilityFrequency | undefined;
    /** Whether or not an approach is available for guidance. */
    approach_available: boolean;
}
/**
 * A publisher for control interactions.
 * This is meant to handle the events for which there aren't existing HEvents
 * in the sim to allow us to maintain a decoupled, event-driven architecture.
 */
declare class ControlPublisher extends BasePublisher<ControlEvents> {
    /**
     * Create a ControlPublisher.
     * @param bus The EventBus to publish to.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus: EventBus, pacer?: PublishPacer<ControlEvents> | undefined);
    /**
     * Publish a control event.
     * @param event The event from ControlEvents.
     * @param value The value of the event.
     */
    publishEvent<K extends keyof ControlEvents>(event: K, value: ControlEvents[K]): void;
    /** debug logger */
    startPublish(): void;
}

/**
 * An interface that describes a virtual DOM node.
 */
interface VNode {
    /** The created instance of the node. */
    instance: NodeInstance;
    /**
     * The root DOM node of this VNode
     * @type {Node}
     * @memberof VNode
     */
    root?: Node;
    /** Any properties to apply to the node. */
    props: any;
    /** The children of this node. */
    children: VNode[] | null;
}
/** A union of possible types of a VNode instance. */
declare type NodeInstance = HTMLElement | SVGElement | DisplayComponent<any> | string | number | null | Subscribable<any>;
/** A union of possible child element types. */
declare type DisplayChildren = VNode | string | number | Subscribable<any> | (VNode | string | number | Subscribable<any>)[] | null;
/** A releative render position. */
declare enum RenderPosition {
    Before = 0,
    After = 1,
    In = 2
}
/** Mapped length undefined tuple to a tuple of Contexts. */
declare type ContextTypes<T extends unknown[]> = {
    [Index in keyof T]: Context<T[Index]>;
};
/** Mapped length undefined tuple to a tuple of context subscriptions. */
declare type ContextSubcriptions<T extends unknown[]> = {
    [Index in keyof T]: Subscribable<T[Index]>;
};
/**
 * A display component in the component framework.
 * @typedef P The type of properties for this component.
 * @typedef C The type of context that this component might have.
 */
declare abstract class DisplayComponent<P, Contexts extends unknown[] = []> {
    /** The properties of the component. */
    props: P & ComponentProps;
    /** The context on this component, if any. */
    context?: [...ContextSubcriptions<Contexts>];
    /** The type of context for this component, if any. */
    readonly contextType?: readonly [...ContextTypes<Contexts>];
    /**
     * Creates an instance of a DisplayComponent.
     * @param props The propertis of the component.
     */
    constructor(props: P);
    /**
     * A callback that is called before the component is rendered.
     */
    onBeforeRender(): void;
    /**
     * A callback that is called after the component is rendered.
     * @param node The component's VNode.
     */
    onAfterRender(node: VNode): void;
    /**
     * Renders the component.
     * @returns A JSX element to be rendered.
     */
    abstract render(): VNode | null;
    /**
     * Destroys this component.
     */
    destroy(): void;
    /**
     * Gets a context data subscription from the context collection.
     * @param context The context to get the subscription for.
     * @returns The requested context.
     * @throws An error if no data for the specified context type could be found.
     */
    protected getContext(context: ContextTypes<Contexts>[number]): ContextSubcriptions<Contexts>[number];
}
/**
 * Base properties for display components.
 */
declare class ComponentProps {
    /** The children of the display component. */
    children?: DisplayChildren[];
    /** A reference to the display component. */
    ref?: NodeReference<any>;
}
/**
 * A constructor signature for a DisplayComponent.
 */
declare type DisplayComponentFactory<P extends ComponentProps, Contexts extends Context<unknown>[] = []> = new (props: P) => DisplayComponent<P, Contexts>;
/**
 * A type for the Fragment function.
 */
declare type FragmentFactory = (props: ComponentProps) => DisplayChildren[] | undefined;
/**
 * A reference to a component or element node.
 */
declare class NodeReference<T extends (DisplayComponent<any> | HTMLElement | SVGElement)> {
    /** The internal reference instance. */
    private _instance;
    /**
     * The instance of the element or component.
     * @returns The instance of the element or component.
     */
    get instance(): T;
    /**
     * Sets the value of the instance.
     */
    set instance(val: T);
    /**
     * Gets the instance, or null if the instance is not populated.
     * @returns The component or element instance.
     */
    getOrDefault(): T | null;
}
/**
 * Provides a context of data that can be passed down to child components via a provider.
 */
declare class Context<T> {
    readonly defaultValue: T;
    /**
     * The provider component that can be set to a specific context value.
     * @param props The props of the provider component.
     * @returns A new context provider.
     */
    readonly Provider: (props: ContextProviderProps<T>) => ContextProvider<T>;
    /**
     * Creates an instance of a Context.
     * @param defaultValue The default value of this context.
     */
    constructor(defaultValue: T);
}
/**
 * Props on the ContextProvider component.
 */
interface ContextProviderProps<T> extends ComponentProps {
    /** The value of the context underneath this provider. */
    value: T;
}
/**
 * A provider component that can be set to a specific context value.
 */
declare class ContextProvider<T> extends DisplayComponent<ContextProviderProps<T>> {
    readonly parent: Context<T>;
    /**
     * Creates an instance of a ContextProvider.
     * @param props The props on the component.
     * @param parent The parent context instance for this provider.
     */
    constructor(props: ContextProviderProps<T>, parent: Context<T>);
    /** @inheritdoc */
    render(): VNode | null;
}
/**
 * The FS component namespace.
 */
declare namespace FSComponent {
    /**
     * Definitions for JSX transpilation.
     */
    namespace JSX {
        /**
         * The intrinsic DOM elements that can be defined.
         */
        interface IntrinsicElements {
            [elemName: string]: any;
            /** A reference to the HTML element node. */
            ref?: NodeReference<any>;
        }
    }
    /**
     * A fragment of existing elements with no specific root.
     * @param props The fragment properties.
     * @returns The fragment children.
     */
    function Fragment(props: ComponentProps): DisplayChildren[] | undefined;
    /**
     * Builds a JSX based FSComponent.
     * @param type The DOM element tag that will be built.
     * @param props The properties to apply to the DOM element.
     * @param children Any children of this DOM element.
     * @returns The JSX VNode for the component or element.
     */
    function buildComponent<T extends DisplayComponentFactory<P> | keyof HTMLElementTagNameMap | keyof SVGElementTagNameMap | FragmentFactory, P extends ComponentProps>(type: T, props: P | null, ...children: DisplayChildren[]): VNode | null;
    /**
     * Creates the collection of child VNodes.
     * @param parent The parent VNode.
     * @param children The JSX children to convert to nodes.
     * @returns A collection of child VNodes.
     */
    function createChildNodes(parent: VNode, children: DisplayChildren[]): VNode[] | null;
    /**
     * Creates a static content VNode.
     * @param content The content to create a node for.
     * @returns A static content VNode.
     */
    function createStaticContentNode(content: string | number): VNode;
    /**
     * Renders a VNode to a DOM element.
     * @param node The node to render.
     * @param element The DOM element to render to.
     * @param position The RenderPosition to put the item in.
     */
    function render(node: VNode, element: HTMLElement | SVGElement | null, position?: RenderPosition): void;
    /**
     * Render a node before a DOM element.
     * @param node The node to render.
     * @param element The element to render boeore.
     */
    function renderBefore(node: VNode, element: HTMLElement | SVGElement | null): void;
    /**
     * Render a node after a DOM element.
     * @param node The node to render.
     * @param element The element to render after.
     */
    function renderAfter(node: VNode, element: HTMLElement | SVGElement | null): void;
    /**
     * Remove a previously rendered element.  Currently, this is just a simple
     * wrapper so that all of our high-level "component maniuplation" state is kept
     * in the FSComponent API, but it's not doing anything other than a simple
     * remove() on the element.   This can probably be enhanced.
     * @param element The element to remove.
     */
    function remove(element: HTMLElement | SVGElement | null): void;
    /**
     * Creates a component or element node reference.
     * @returns A new component or element node reference.
     */
    function createRef<T extends (DisplayComponent<any, any> | HTMLElement | SVGElement)>(): NodeReference<T>;
    /**
     * Creates a new context to hold data for passing to child components.
     * @param defaultValue The default value of this context.
     * @returns A new context.
     */
    function createContext<T>(defaultValue: T): Context<T>;
    /**
     * Visits VNodes with a supplied visitor function within the given children tree.
     * @param node The node to visit.
     * @param visitor The visitor function to inspect VNodes with. Return true if the search should stop at the visited
     * node and not proceed any further down the node's children.
     * @returns True if the visitation should break, or false otherwise.
     */
    function visitNodes(node: VNode, visitor: (node: VNode) => boolean): boolean;
    /**
     * Parses a space-delimited CSS class string into an array of CSS classes.
     * @param classString A space-delimited CSS class string.
     * @returns An array of CSS classes derived from the specified CSS class string.
     */
    function parseCssClassesFromString(classString: string): string[];
    /**
     * Binds a {@link MutableSubscribableSet} to a subscribable set of CSS classes. CSS classes added to and removed from
     * the subscribed set will also be added to and removed from the bound set, with the exception of a set of reserved
     * classes. The presence or absence of any of the reserved classes in the bound set is not affected by the subscribed
     * set; these reserved classes may be freely added to and removed from the bound set.
     * @param setToBind The set to bind.
     * @param classesToSubscribe A set of CSS classes to which to subscribe.
     * @param reservedClasses An iterable of reserved classes.
     * @returns The newly created subscription to the subscribed CSS class set.
     */
    function bindCssClassSet(setToBind: MutableSubscribableSet<string>, classesToSubscribe: SubscribableSet<string>, reservedClasses: Iterable<string>): Subscription;
    /**
     * An empty callback handler.
     */
    const EmptyHandler: () => void;
}
/**
 * A system that handles the registration and boostrapping of plugin scripts.
 */
declare class PluginSystem<T extends AvionicsPlugin<B>, B> {
    private readonly scripts;
    private readonly plugins;
    /** The avionics specific plugin binder to inject into each plugin. */
    binder?: B;
    /** An event subscribable that publishes when a new component is about to be created. */
    readonly creatingHandlers: ((constructor: DisplayComponentFactory<any>, props: any) => DisplayComponent<any> | undefined)[];
    /** An event subscribable that publishes when a new component is created. */
    readonly createdHandlers: ((component: DisplayComponent<any>) => void)[];
    /** An event subscribable that publishes when a component has finished rendering. */
    readonly renderedHandlers: ((node: VNode) => void)[];
    /**
     * Adds plugin scripts to load to the system.
     * @param document The panel.xml document to load scripts from.
     * @param instrumentId The ID of the instrument.
     */
    addScripts(document: XMLDocument, instrumentId: string): void;
    /**
     * Starts the plugin system with the included avionics specific plugin binder.
     * @param binder The plugin binder to pass to the individual plugins.
     */
    startSystem(binder: B): Promise<void>;
    /**
     * Adds a plugin to the plugin system.
     * @param plugin The plugin to add.
     */
    addPlugin(plugin: T): void;
    /**
     * Runs the provided function on all of the registered plugins.
     * @param fun The function to run.
     */
    callPlugins(fun: (plugin: T) => void): void;
    /**
     * Subscribes a handler to the component creating hook.
     * @param handler The handler to subscribe.
     */
    subscribeOnComponentCreating(handler: (constructor: DisplayComponentFactory<any>, props: any) => DisplayComponent<any> | undefined): void;
    /**
     * A hook that allows plugins to replace components that are about to be created with their own implementations.
     * @param constructor The display component constructor that is going to be used.
     * @param props The component props that will be passed into the component.
     * @returns Returns either the display component that will replace, or undefined if the component should not be replaced.
     */
    onComponentCreating(constructor: DisplayComponentFactory<any>, props: any): DisplayComponent<any> | undefined;
    /**
     * Subscribes a handler to the component created hook.
     * @param handler The handler to subscribe.
     */
    subscribeOnComponentCreated(handler: (component: DisplayComponent<any>) => void): void;
    /**
     * A hook that allows plugins to observe components as they are created.
     * @param component The component that was created.
     */
    onComponentCreated(component: DisplayComponent<any>): void;
    /**
     * Subscribes a handler to the component rendered hook.
     * @param handler The handler to subscribe.
     */
    subscribeOnComponentRendered(handler: (node: VNode) => void): void;
    /**
     * A hook that allows plugins to observe built VNodes after they are rendered.
     * @param node The node that was rendered.
     */
    onComponentRendered(node: VNode): void;
}
/**
 * A plugin that is created and managed by the plugin system.
 */
declare abstract class AvionicsPlugin<T> {
    protected readonly binder: T;
    /**
     * Creates an instance of a Plugin.
     * @param binder The avionics specific plugin binder to accept from the system.
     */
    constructor(binder: T);
    /**
     * A callback run when the plugin has been installed.
     */
    abstract onInstalled(): void;
    /**
     * An optional hook called when a component is about to be created. Returning a component causes
     * that component to be used instead of the one that was to be created, and returning undefined
     * will cause the original component to be created. If this hook is present, it will be called
     * for EVERY component instantiation, so be sure to ensure that this code is well optimized.
     */
    onComponentCreating?: (constructor: DisplayComponentFactory<any>, props: any) => DisplayComponent<any> | undefined;
    /**
     * An optional hook called when a component is created. If this hook is present,
     * it will be called for EVERY component instantiation, so be sure to ensure
     * that this code is well optimized.
     */
    onComponentCreated?: (component: DisplayComponent<any>) => void;
    /**
     * An optional hook called when a component has completed rendering. If this hook
     * is present, it will be called for EVERY component render completion, so be sure
     * to ensure that this code is well optimized.
     */
    onComponentRendered?: (node: VNode) => void;
    /**
     * Loads a CSS file into the instrument.
     * @param uri The URI to the CSS file.
     */
    protected loadCss(uri: string): Promise<void>;
}
/**
 * Registers a plugin with the plugin system.
 * @param plugin The plugin to register.
 */
declare function registerPlugin<T>(plugin: new (binder: T) => AvionicsPlugin<T>): void;
declare const Fragment: typeof FSComponent.Fragment;

/** Base props for an XML gauge. */
interface XMLGaugeProps extends ComponentProps {
    /** The style definiton. */
    style: Partial<XMLGaugeStyle>;
    /** The minimum value. */
    minimum: CompositeLogicXMLElement;
    /** The maximum value. */
    maximum: CompositeLogicXMLElement;
    /** A list of color zones. */
    colorZones: Array<XMLGaugeColorZone>;
    /** A list of colir lines. */
    colorLines: Array<XMLGaugeColorLine>;
    /** The first possible value. */
    value1: CompositeLogicXMLElement;
    /** The second possible value for dual elements. */
    value2: CompositeLogicXMLElement;
    /** The title of the gauge. */
    title: string;
    /** The units measured by the gauge. */
    unit: string;
    /** The length of individual graduations. */
    graduationLength: number;
    /** Do the graduations have text? */
    graduationHasText: boolean;
    /** Text at the beginning of the gauge. */
    beginText: string;
    /** Text at the end of the gauge. */
    endText: string;
    /** The label of the first cursor. */
    cursorText1: string;
    /** The labe of the second cursor, for  */
    cursorText2: string;
    /** The class ID of the gauge. */
    id: string;
    /**Any triggers for blinking the element red. */
    redBlink: CompositeLogicXMLElement;
    /** A reference bug definition, if present. */
    referenceBugs: Array<XMLGaugeReferenceBug>;
}
/**
 * I don't want to make the logic host a defined part of the base gauge
 * interface, because I feel like that breaks abstraction boundaries and
 * ties this code too much to our specific implementation.   But I don't()
 * want people to have to subclass their own type of every gauge type in
 * order to pass the logic host in as a prop, so I'll make an additonal
 * interface for that which can be mixed in by people who want to use it.
 */
interface XMLHostedLogicGauge {
    /** The logic host. */
    logicHost: CompositeLogicXMLHost;
}
/** An XML gauge style definition. */
interface XMLGaugeStyle {
    /** TODO The scaling ratio on the gauge? */
    sizePercent: number;
    /** Left margin. */
    marginLeft: number;
    /** Right margin. */
    marginRight: number;
    /** Top margin. */
    marginTop: number;
    /** Bottom margin. */
    marginBottom: number;
}
/** A color zone definition. */
interface XMLGaugeColorZone {
    /** The name of the color to use. */
    color: string;
    /** The beginning value of the zone. */
    begin: CompositeLogicXMLElement;
    /** The ending value of the zone. */
    end: CompositeLogicXMLElement;
    /** An optional linear smoothing factor for value updates. */
    smoothFactor?: number;
}
/** A color line definition. */
interface XMLGaugeColorLine {
    /** The name of the color to use. */
    color: string;
    /** The value position of the color line. */
    position: CompositeLogicXMLElement;
    /** An optional linear smoothing factor for value updates. */
    smoothFactor?: number;
}
/** Style for a reference bug. */
interface XMLGaugeReferenceBugStyle extends XMLGaugeStyle {
    /** The color of the bug. */
    color: string;
}
/** A reference bug definition. */
interface XMLGaugeReferenceBug {
    /** The positioning logic. */
    position: CompositeLogicXMLElement;
    /** Logic to toggle display on and off. */
    displayLogic: CompositeLogicXMLElement;
    /** An optional style to use. */
    style?: Partial<XMLGaugeReferenceBugStyle>;
    /** An optional linear smoothing factor for value updates. */
    smoothFactor?: number;
}

/** Props for a circular gauge */
interface XMLCircularGaugeProps extends XMLGaugeProps {
    /** A style */
    style: Partial<XMLCircularGaugeStyle>;
}
/** A circular gauge style definition */
interface XMLCircularGaugeStyle extends XMLGaugeStyle {
    /** TODO What text color to force? */
    forceTextColor: string;
    /** TODO Gradation labels on the arc? */
    textIncrement: number;
    /** The arc position to begin on. */
    beginAngle: number;
    /** The arc position to end on. */
    endAngle: number;
    /** The style of cursor to use. */
    cursorType: XMLCircularGaugeCursor;
    /** Where to put the value. */
    valuePos: XMLCircularGaugeValuePos;
    /** The precision to use in text display. */
    valuePrecision: number;
}
/**
 * The style of cursor to use on a circular gauge.
 * This is treated as though it may have multiple options in the original
 * source.  For the sake of future expansion we'll make this an enum even
 * though it currently only has one option.  Maybe it can be used for future
 * expansion.
 */
declare enum XMLCircularGaugeCursor {
    /** Starting the enum at 1 to match its value in the stock XMLEngineDisplay.js */
    Triangle = 1
}
/**
 * The possible locations for value text.
 * This is treated as though it may have multiple options in the original
 * source.  For the sake of future expansion we'll make this an enum even
 * though it currently only has one option.  Maybe it can be used for future
 * expansion.
 */
declare enum XMLCircularGaugeValuePos {
    /** Starting the enum at 1 to match its value in the stock XMLEngineDisplay.js */
    End = 1
}

/** Props for a horizontal gauge */
interface XMLHorizontalGaugeProps extends XMLGaugeProps {
    /** A style */
    style: Partial<XMLHorizontalGaugeStyle>;
}
/** A circular gauge style definition */
interface XMLHorizontalGaugeStyle extends XMLGaugeStyle {
    /** TODO Gradation labels on the arc? */
    textIncrement: number;
    /** Where to put the value. */
    valuePos: XMLHorizontalGaugeValuePos;
    /** What kind of pointer to use. */
    pointerStyle: 'standard' | 'arrow';
    /** The color of the cursor. */
    cursorColor: string;
    /** TODO Width in pixels? as a float. */
    width: number;
    /** TODO dunno what this does yet */
    reverseY: boolean;
    /** The precision of the value as an int. */
    valuePrecision: number;
}
/**
 * This provides the valid values for the ValuePos tag on a horizontal gauge.
 */
declare enum XMLHorizontalGaugeValuePos {
    /** Starting the enum at 1 to match its value in the stock XMLEngineDisplay.js */
    End = 1,
    Right = 2
}

/** Props for a horizontal gauge */
interface XMLVerticalGaugeProps extends XMLGaugeProps {
    /** A style */
    style: Partial<XMLVerticalGaugeStyle>;
}
/** A circular gauge style definition */
interface XMLVerticalGaugeStyle extends XMLGaugeStyle {
    /** TODO Gradation labels on the arc? */
    textIncrement: number;
    /** Where to put the value. */
    valuePos: XMLVerticalGaugeValuePos;
    /** The color of the cursor. */
    cursorColor: string;
}
/**
 * This provides the valid values for the ValuePos tag on a vertical gauge.
 */
declare enum XMLVerticalGaugeValuePos {
    /** Starting the enum at 1 to match its value in the stock XMLEngineDisplay.js */
    None = 1
}

/** Props for a horizontal gauge */
interface XMLDoubleHorizontalGaugeProps extends XMLGaugeProps {
    /** A style */
    style: Partial<XMLDoubleHorizontalGaugeStyle>;
}
/** A circular gauge style definition */
interface XMLDoubleHorizontalGaugeStyle extends XMLGaugeStyle {
    /** TODO Gradation labels on the arc? */
    textIncrement: number;
    /** The value precision. */
    valuePrecision: number;
    /** Where to put the value. */
    valuePos: XMLDoubleHorizontalGaugeValuePos;
    /** What kind of pointer to use. */
    pointerStyle: 'standard' | 'arrow';
}
/**
 * The possible locations for value text.
 * This is treated as though it may have multiple options in the original
 * source.  For the sake of future expansion we'll make this an enum even
 * though it currently only has one option.  Maybe it can be used for future
 * expansion.
 */
declare enum XMLDoubleHorizontalGaugeValuePos {
    /** Starting the enum at 2 to match its value in the stock XMLEngineDisplay.js */
    Right = 2
}

/** Props for a horizontal gauge */
interface XMLDoubleVerticalGaugeProps extends XMLGaugeProps {
    /** A style */
    style: Partial<XMLDoubleVerticalGaugeStyle>;
}
/** A circular gauge style definition */
interface XMLDoubleVerticalGaugeStyle extends XMLGaugeStyle {
    /** TODO Gradation labels on the arc? */
    textIncrement: number;
    /** TODO Height of the gauge in what? */
    height: number;
}

/** Props for an XML text element. */
interface XMLTextElementProps extends ComponentProps {
    /** The HTML class of the element. */
    class?: string;
    /** The left side text. */
    left?: XMLTextColumnProps;
    /** The central text. */
    center?: XMLTextColumnProps;
    /** The right side text. */
    right?: XMLTextColumnProps;
    /** Style information. */
    style?: Partial<XMLGaugeStyle>;
}
/** The configuration of an individual column of text. */
interface XMLTextColumnProps {
    /** The HTML class of the element. */
    class?: string;
    /** The text content of the column. */
    content: CompositeLogicXMLElement;
    /** The color of the text. */
    color?: CompositeLogicXMLElement;
    /** The font size to use. */
    fontSize?: string;
}

/**
 * The type of gauges available, as defined in XMLEngineDisplay.js.
 */
declare enum XMLGaugeType {
    Circular = "Circular",
    Horizontal = "Horizontal",
    DoubleHorizontal = "DoubleHorizontal",
    Vertical = "Vertical",
    DoubleVertical = "DoubleVertical",
    Text = "Text",
    ColumnGroup = "ColumnGroup",
    Column = "Column",
    Cylinder = "Cylinder",
    TwinCylinder = "TwinCylinder"
}
/**
 * The specification for a single gauge configuration.
 */
declare type XMLGaugeSpec = {
    /** The type of gauge this is. */
    gaugeType: XMLGaugeType;
    /** The correct configuration interface for this gauge type. */
    configuration: XMLGaugeProps | GaugeColumnProps | GaugeColumnGroupProps | XMLTextElementProps;
};
/**
 * The data for a function.
 */
declare type XMLFunction = {
    /** The function's name. */
    name: string;
    /** The XML logic the function runs. */
    logic: CompositeLogicXMLElement;
};
/**
 * A full set of gauges.
 */
declare type XMLExtendedGaugeConfig = {
    /** Whether this should override the temporary enhanced default configs. */
    override: boolean;
    /** Any configured functions. */
    functions: Map<string, XMLFunction>;
    /** The engine page. */
    enginePage: Array<XMLGaugeSpec>;
    /** The lean page, if it exists. */
    leanPage?: Array<XMLGaugeSpec>;
    /** The system page, if it exists. */
    systemPage?: Array<XMLGaugeSpec>;
};
/**
 * Parse an XMLEngineDisplay configuration into an array of gauge specs.
 */
declare class XMLGaugeConfigFactory {
    private instrument;
    private bus;
    /**
     * Create an XMLGaugeConfigFactory.
     * @param instrument The instrument that holds this engine display.
     * @param bus An event bus for gauges that need it.
     */
    constructor(instrument: BaseInstrument, bus: EventBus);
    /**
     * Convenience method to take a full XML instrument config and parse out the display config
     * section. This will check first to see if we are using an enhanced, multi-page config by
     * looking for an EnginePage tag in the EngineDisplay element.   If it finds it, it will
     * assume we have an advanced config, and return the content along with that of LeanPage
     * and SystemPag, if present.  If no EnginePage exists, we assume we're dealing with a
     * legacy configuration and just return the content of EngineDisplay itself as our engine
     * page with everything else undefined.
     * @param document The XML configuation document.
     * @returns An XMLEnhancedGaugeConfig with the full gauge configuration.
     */
    parseConfig(document: Document): XMLExtendedGaugeConfig;
    /**
     * Parse an engine display setup.
     * @param config An instrument XML config document.
     * @returns An array of the gauges defined in the configuration.
     */
    private _parseConfig;
    /**
     * Construct a single column of text for a text element.  This can be any
     * one of Left, Right, or Center.
     * @param columnDef The XML definition for the given column.
     * @returns an XMLTextColumn configuration.
     */
    private makeTextColumn;
    /**
     * Make a function.
     * @param functionDef The XML definition for the function.
     * @returns an XMLFunction type or undefined if there's an error
     */
    private makeFunction;
    /**
     * Create a base XMLGaugeProps definition.  This will be combined with the
     * props for a speciific gauge type to fully define the config interface.
     * @param gauge The gauge definition
     * @returns A set of XMLGaugeProps
     */
    private parseGaugeDefinition;
    /**
     * Create a circular gauge.
     * @param gaugeDef An XML element defining the gauge.
     * @returns The props for this gauge.
     */
    private createCircularGauge;
    /**
     * Create a horizontal gauge.
     * @param gaugeDef An XML element defining the gauge.
     * @returns The props for this gauge.
     */
    private createHorizontalGauge;
    /**
     * Create a double horizontal gauge.
     * @param gaugeDef An XML element defining the gauge.
     * @returns The props for this gauge.
     */
    private createDoubleHorizontalGauge;
    /**
     * Create a single vertical gauge.
     * @param gaugeDef An XML element defining the gauge.
     * @returns The props for this gauge.
     */
    private createVerticalGauge;
    /**
     * Create a double vertical gauge.
     * @param gaugeDef An XML element defining the gauge.
     * @returns The props for this gauge.
     */
    private createDoubleVerticalGauge;
    /**
     * Create a cylinder gauge.
     * @param gaugeDef An XML element defining the gauge.
     * @returns The props for this gauge.
     */
    private createCylinderGauge;
    /**
     * Create a column group.
     * @param gaugeDef AN XML element defining the group.
     * @returns The props for the group with all contained columns.
     */
    private createColumnGroup;
    /**
     * Create a column of gauges.
     * @param gaugeDef An XML element defining the column.
     * @returns The props of the column with all contained gauges.
     */
    private createColumn;
    /**
     * Check the value of a setting and, if it's defined, assign it to the
     * property of an object with optional type conversion.
     * @param obj The object to manipulate.
     * @param elem The element to get the value from.
     * @param prop The name of the property to set.
     * @param tag The tag name to retrieve.
     * @param converter A type conversion used if the value is defined.
     */
    private static getAndAssign;
    /**
     * Create a basic XML style from a gauge definition.
     * @param styleDoc A style definition block
     * @returns An XMLGaugeStyle
     */
    private static parseStyleDefinition;
    /**
     * Get the SmoothFactor value from a gauge definition if present.
     * @param element The HTML element to search for the parameter.
     * @returns The smoothing factor as a number, or undefined if not found.
     */
    private parseSmoothFactor;
    /**
     * Create an array of color zones if a definition exists.
     * @param zones An array of color zone definitions.
     * @returns An array of XMLGaugeColorZones
     */
    private makeColorZones;
    /**
     * Create an array of color lines if a definition exists.
     * @param lines An array of color line definitions.
     * @returns An array of XMLGaugeColorLines
     */
    private makeColorLines;
    /**
     * Create an array of reference bugs if a definition exists.
     * @param bugs An array of reference bug definitions.
     * @returns An array of XMLGaugeReferenceBugs
     */
    private makeReferenceBugs;
}

/** Properties of a column group. */
interface GaugeColumnGroupProps {
    /** The HTML class name to use for the column group. */
    id?: string;
    /** An event bus for our contained gauges that need it. */
    bus: EventBus;
    /** The columns in the group. */
    columns: Array<GaugeColumnProps>;
}
/** Properties of a gauge column. */
interface GaugeColumnProps {
    /** The HTML class name to use for the column. */
    id?: string;
    /** The width of the column, in percent of the parent. */
    width?: number;
    /** The gauges in the group. */
    gauges: Array<XMLGaugeSpec>;
}

/** Props for a cylinder gauge */
interface XMLCylinderGaugeProps extends XMLGaugeProps {
    /** An event bus for leaning events. */
    bus: EventBus;
    /** The number of columns in the gauge. */
    numColumns: CompositeLogicXMLElement;
    /** The number of boxes each column should have. */
    numRows: CompositeLogicXMLElement;
    /** What's the order of the hottest cylinders? */
    tempOrder?: Array<number>;
    /** The gauge styling. */
    style: Partial<XMLCylinderGaugeStyle>;
}
/** A cylinder gauge style definition. */
interface XMLCylinderGaugeStyle extends XMLGaugeStyle {
    /** Increment used for text value display. */
    textIncrement: number;
    /** Should there be a redline present? */
    redline?: boolean;
    /** Should we show peak temperatures when leaning? */
    peakTemps?: boolean;
}

/** A type that pairs a logic element with its callback handler. */
declare type LogicHandler<T> = {
    /** A logic element instance to evaluate. */
    logic: CompositeLogicXMLElement;
    /** A handler to call back to when there's a value change. */
    handler: (data: T) => void;
    /** A precision to use for numeric values. */
    precision?: number;
    /** A linear smoothing factor for value changes. */
    smoothFactor?: number;
};
/** The kind of data to return. */
declare enum CompositeLogicXMLValueType {
    Any = 0,
    Number = 1,
    String = 2
}
/**
 *
 */
declare class CompositeLogicXMLHost {
    private anyHandlers;
    private stringHandlers;
    private numberHandlers;
    private anyResultCache;
    private stringResultCache;
    private numberResultCache;
    private context;
    private isPaused;
    /**
     * Set to pause the logic update loop.
     * @param isPaused True to pause, false to resume.
     */
    setIsPaused(isPaused: boolean): void;
    /**
     * Add a new logic element to calcluate a number or a string.
     * @param logic A CompositeLogicXMLElement.
     * @param handler A callback hander to take new values of either type.
     * @returns The current value of the logic.
     */
    addLogic(logic: CompositeLogicXMLElement, handler: (data: string | number) => void): number | string;
    /**
     * Add a new logic element to calcluate a number.
     * @param logic A CompositeLogicXMLElement.
     * @param handler A callback hander to take new values as numbers.
     * @param precision An optional precision to require for updates to be sent.
     * @param smoothFactor An optional linear smoothing factor to apply to the value when updating.
     * @returns The current value of the logic.
     */
    addLogicAsNumber(logic: CompositeLogicXMLElement, handler: (data: number) => void, precision: number, smoothFactor?: number): number;
    /**
     * Add a new logic element to calcluate a string.
     * @param logic A CompositeLogicXMLElement.
     * @param handler A callback hander to take new values as strings.
     * @returns The current value of the logic.
     */
    addLogicAsString(logic: CompositeLogicXMLElement, handler: (data: string) => void): string;
    /**
     * Add a function to the logic context.
     * @param funcSpec The XMLFunction configuration.
     * @returns The function's current value.
     */
    addFunction(funcSpec: XMLFunction): number | string;
    /**
     * Update every logic element and publish updates.
     * @param deltaTime The time since the last update, in ms.
     */
    update(deltaTime: number): void;
}

declare namespace DataStore {
    /**
     * Writes a keyed value to the data store.
     * @param key A key.
     * @param value The value to set.
     */
    function set<T extends boolean | number | string>(key: string, value: T): void;
    /**
     * Retrieves a keyed value from the data store.
     * @param key A key.
     * @returns the value stored under the key, or undefined if one could not be retrieved.
     */
    function get<T extends boolean | number | string>(key: string): T | undefined;
    /**
     * Removes a key from the data store.
     * @param key The key to remove.
     */
    function remove(key: string): void;
}

/**
 * A subscribable subject which derives its value from an event consumer.
 */
declare class ConsumerSubject<T> extends AbstractSubscribable<T> {
    private readonly equalityFunc;
    private readonly mutateFunc?;
    private readonly consumerHandler;
    private value;
    private consumerSub?;
    private _isPaused;
    /**
     * Whether event consumption is currently paused for this subject. While paused, this subject's value will not
     * update.
     */
    get isPaused(): boolean;
    private isDestroyed;
    /**
     * Constructor.
     * @param consumer The event consumer from which this subject obtains its value. If null, this subject's value will
     * not be updated until its consumer is set to a non-null value.
     * @param initialVal This subject's initial value.
     * @param equalityFunc The function this subject uses check for equality between values.
     * @param mutateFunc The function this subject uses to change its value. If not defined, variable assignment is used
     * instead.
     */
    private constructor();
    /**
     * Creates a new instance of ConsumerSubject.
     * @param consumer The consumer from which the new subject obtains its value. If null, the new subject's value will
     * not be updated until the subject's consumer is set to a non-null value.
     * @param initialVal The new subject's initial value.
     * @param equalityFunc The function to use to check for equality between values. Defaults to the strict equality
     * comparison (`===`).
     */
    static create<T>(consumer: Consumer<T> | null, initialVal: T, equalityFunc?: (a: T, b: T) => boolean): ConsumerSubject<T>;
    /**
     * Creates a new instance of ConsumerSubject.
     * @param consumer The consumer from which the new subject obtains its value. If null, the new subject's value will
     * not be updated until the subject's consumer is set to a non-null value.
     * @param initialVal The new subject's initial value.
     * @param equalityFunc The function to use to check for equality between values.
     * @param mutateFunc The function to use to change the new subject's value.
     */
    static create<T>(consumer: Consumer<T> | null, initialVal: T, equalityFunc: (a: T, b: T) => boolean, mutateFunc: (oldVal: T, newVal: T) => void): ConsumerSubject<T>;
    /**
     * Consumes an event.
     * @param value The value of the event.
     */
    private onEventConsumed;
    /**
     * Sets the consumer from which this subject derives its value. If the consumer is null, this subject's value will
     * not be updated until a non-null consumer is set.
     * @param consumer An event consumer.
     * @returns This subject, after its consumer has been set.
     */
    setConsumer(consumer: Consumer<T> | null): this;
    /**
     * Pauses consuming events for this subject. Once paused, this subject's value will not be updated.
     * @returns This subject, after it has been paused.
     */
    pause(): this;
    /**
     * Resumes consuming events for this subject. Once resumed, this subject's value will be updated from consumed
     * events.
     * @returns This subject, after it has been resumed.
     */
    resume(): this;
    /** @inheritdoc */
    get(): T;
    /**
     * Destroys this subject. Once destroyed, it will no longer consume events to update its value.
     */
    destroy(): void;
}

/**
 * Key intercept event data.
 */
declare type KeyEventData = {
    /** The key. */
    key: string;
    /** The index of the key event. */
    index?: number;
    /** The value of the key event. */
    value?: number;
};
/**
 * Key events.
 */
declare type KeyEvents = {
    /** A key intercept event. */
    key_intercept: KeyEventData;
};
/**
 * A manager for key intercepts. Allows key events to be intercepted and publishes intercepted key events on the event
 * bus.
 */
declare class KeyInterceptManager {
    private readonly keyListener;
    private readonly bus;
    private static INSTANCE?;
    private static isCreatingInstance;
    private static readonly pendingPromiseResolves;
    /**
     * Constructor.
     * @param keyListener The Coherent key intercept view listener.
     * @param bus The event bus.
     */
    private constructor();
    /**
     * Responds to key intercept events.
     * @param key The key that was intercepted.
     * @param index The index of the key event.
     * @param value The value of the key event.
     */
    private onKeyIntercepted;
    /**
     * Enables interception for a key.
     * @param key The key to intercept.
     * @param passThrough Whether to pass the event through to the sim after it has been intercepted.
     */
    interceptKey(key: string, passThrough: boolean): void;
    /**
     * Gets an instance of KeyInterceptManager. If an instance does not already exist, a new one will be created.
     * @param bus The event bus.
     * @returns A Promise which will be fulfilled with an instance of KeyInterceptManager.
     */
    static getManager(bus: EventBus): Promise<KeyInterceptManager>;
    /**
     * Creates an instance of KeyInterceptManager and fulfills all pending Promises to get the manager instance once
     * the instance is created.
     * @param bus The event bus.
     */
    private static createInstance;
    /**
     * Creates an instance of KeyInterceptManager.
     * @param bus The event bus.
     * @returns A Promise which is fulfilled with a new instance of KeyInterceptManager after it has been created.
     */
    private static create;
}

/**
 * A utility class which provides the current game state.
 */
declare class GameStateProvider {
    private static INSTANCE?;
    private readonly gameState;
    /**
     * Constructor.
     */
    private constructor();
    /**
     * Responds to changes in document attributes.
     */
    private onAttributesChanged;
    /**
     * Gets a subscribable which provides the current game state.
     * @returns A subscribable which provides the current game state.
     */
    static get(): Subscribable<GameState | undefined>;
}

declare enum IcaoSearchFilter {
    ALL = 0,
    AIRPORT = 1,
    VOR = 2,
    NDB = 3,
    INTERSECTION = 4,
    USR = 5
}
/**
 * An ICAO search session, which allows searching for ICAO strings that match a particular ident string.
 */
declare class IcaoSearch {
    private readonly facilityRepo;
    private readonly filter;
    private readonly searchGuid;
    private batch;
    private readonly MAX_RETRIES;
    private filterMap;
    private opId;
    /**
     * Constructor.
     * @param facilityRepo The local facility repository included in this search session.
     * @param filter The filter applied to this search session.
     */
    constructor(facilityRepo: FacilityRepository, filter: IcaoSearchFilter);
    /**
     * Executes a new search in this session with a specified ident string to match. Only one active search can run
     * simultaneously. Therefore, if doSearch() is called while a previous search is still running, the newer search will
     * pre-empt the older one, causing the older one to fail.
     * @param ident An ident string.
     * @returns a Promise which is fulfilled with an array of ICAO strings that matched the ident string.
     * @throws Error if the search was pre-empted by a newer one.
     */
    doSearch(ident: string): Promise<string[]>;
    /**
     * Maps the search results to an array of ICAO strings.
     * @param items The search results.
     * @returns an array of ICAO strings.
     */
    private mapResult;
    /**
     * Artificial delay for skipping cycles during search.
     * @param time The time to wait.
     * @returns a Promise which fulfills when the delay expires.
     */
    private delay;
    /**
     * Generates a unique id for search context.
     * @returns A unique ID string.
     */
    private genGuid;
}

/**
 * Events published by the FlightPlanner class.
 */
interface FlightPlannerEvents {
    /** A flight plan has been modified from a secondary source */
    fplLegChange: FlightPlanLegEvent;
    /** A flight plan has been modified from a secondary source */
    fplSegmentChange: FlightPlanSegmentEvent;
    /** A flight plan has changed an active leg. */
    fplActiveLegChange: FlightPlanActiveLegEvent;
    /** A flight plan has calculated flight path vectors. */
    fplCalculated: FlightPlanCalculatedEvent;
    /** A flight plan has update origin/dest information. */
    fplOriginDestChanged: FlightPlanOriginDestEvent;
    /** A flight plan has updated procedure details. */
    fplProcDetailsChanged: FlightPlanProcedureDetailsEvent;
    /** A full flight plan has been loaded. */
    fplLoaded: FlightPlanIndicationEvent;
    /** A new flight plan has been created. */
    fplCreated: FlightPlanIndicationEvent;
    /** A flight plan has been deleted. */
    fplDeleted: FlightPlanIndicationEvent;
    /** The active flight plan index has changed in the Flight Planner. */
    fplIndexChanged: FlightPlanIndicationEvent;
    /** The flight plan has been copied. */
    fplCopied: FlightPlanCopiedEvent;
    /** User data has been set in the flight plan. */
    fplUserDataSet: FlightPlanUserDataEvent;
    /** User data has been deleted in the flight plan. */
    fplUserDataDelete: FlightPlanUserDataEvent;
    /** Direct to data has been changed in the flight plan. */
    fplDirectToDataChanged: FlightPlanDirectToDataEvent;
}
/**
 * An event fired when the flight plan is recalculated.
 */
interface FlightPlanCalculatedEvent {
    /** The index of the flight plan. */
    readonly planIndex: number;
    /** The index from which the calculations were generated. */
    readonly index?: number;
}
/**
 * An event fired when there are leg related changes.
 */
interface FlightPlanLegEvent {
    /** The type of the leg change. */
    readonly type: PlanChangeType;
    /** The index of the flight plan. */
    readonly planIndex: number;
    /** The index of the */
    readonly segmentIndex: number;
    /** The index of the changed leg in the segment. */
    readonly legIndex: number;
    /** The leg that was added or removed. */
    readonly leg?: LegDefinition;
}
/**
 * An event fired when an active leg changes.
 */
interface FlightPlanActiveLegEvent {
    /** The index of the flight plan. */
    readonly planIndex: number;
    /** The index of the changed leg in the segment. */
    readonly index: number;
    /** The index of the segment in which the active leg is. */
    readonly segmentIndex: number;
    /** The index of the leg within the segment. */
    readonly legIndex: number;
    /** The index of the segment in which the previously active leg is. */
    readonly previousSegmentIndex: number;
    /** The index of the previously active leg within the previously active segment. */
    readonly previousLegIndex: number;
    /** The type of active leg that changed. */
    readonly type: ActiveLegType;
}
/**
 * An event fired when there are segment related changes.
 */
interface FlightPlanSegmentEvent {
    /** The type of the leg change. */
    readonly type: PlanChangeType;
    /** The index of the flight plan. */
    readonly planIndex: number;
    /** The current leg selected. */
    readonly segmentIndex: number;
    /** The segment that was added, removed, or changed. */
    readonly segment?: FlightPlanSegment;
}
/**
 * An event generated when the origin and/or destination information
 * is updated.
 */
interface FlightPlanOriginDestEvent {
    /** The type of change. */
    readonly type: OriginDestChangeType;
    /** The index of the flight plan. */
    readonly planIndex: number;
    /** The airport that was changed. */
    readonly airport?: string;
}
/**
 * An event generated when the flight plan procedure details changs.
 */
interface FlightPlanProcedureDetailsEvent {
    /** THe index of the flight plan. */
    readonly planIndex: number;
    /** The procedure details that changed. */
    readonly details: ProcedureDetails;
}
/**
 * An event generated when an instrument requests a full set
 * of plans from the bus.
 */
interface FlightPlanRequestEvent {
}
/**
 * An event generated when an instrument responds to a full
 * flight plan set request.
 */
interface FlightPlanResponseEvent {
    /** The plans contained by the flight planner. */
    readonly flightPlans: FlightPlan[];
    /** The index of the active plan. */
    readonly planIndex: number;
}
/**
 * An event generated when a full plan has been loaded, created, or became active.
 */
interface FlightPlanIndicationEvent {
    /** The index of the flight plan. */
    readonly planIndex: number;
}
/**
 * An event generated when the flight plan procedure details changs.
 */
interface FlightPlanCopiedEvent {
    /** The index of the flight plan. */
    readonly planIndex: number;
    /** The index that the flight plan was copied to. */
    readonly targetPlanIndex: number;
}
/**
 * An event generated when user data is set in the flight plan.
 */
interface FlightPlanUserDataEvent {
    /** The index of the flight plan. */
    readonly planIndex: number;
    /** The key of the user data. */
    readonly key: string;
    /** The user data. */
    readonly data: any;
}
/**
 * An event generated when direct to data is changed in the flight plan.
 */
interface FlightPlanDirectToDataEvent {
    /** The index of the flight plan. */
    readonly planIndex: number;
    /** The direct to data. */
    readonly directToData: DirectToData;
}
/**
 * Manages the active flightplans of the navigational systems.
 */
declare class FlightPlanner {
    private readonly bus;
    private readonly calculator;
    private onLegNameRequested;
    private static INSTANCE?;
    /** The flight plans managed by this flight planner. */
    private readonly flightPlans;
    /** A publisher for publishing flight planner update events. */
    private readonly publisher;
    private ignoreSync;
    /** The active flight plan index. */
    private _activePlanIndex;
    flightPlanSynced: SubEvent<this, boolean>;
    /**
     * Set a new active plan index.
     * @param planIndex The new active plan index.
     */
    set activePlanIndex(planIndex: number);
    /**
     * Get the active plan index.
     * @returns The active plan index number.
     */
    get activePlanIndex(): number;
    /**
     * Creates an instance of the FlightPlanner.
     * @param bus The event bus instance to notify changes on.
     * @param calculator The flight path calculator to use with this planner.
     * @param onLegNameRequested A callback fired when a flight plan leg is to be named.
     */
    private constructor();
    /**
     * Requests synchronization from other FlightPlanner instances.
     */
    requestSync(): void;
    /**
     * An event generated when a set of flight plans is requested.
     */
    private onFlightPlanRequest;
    /**
     * Sends a flight plan request event.
     */
    private sendFlightPlanRequest;
    /**
     * A callback which is called in response to flight plan request response sync events.
     * @param data The event data.
     */
    private onFlightPlanResponse;
    /**
     * Checks whether a flight plan exists at a specified index.
     * @param planIndex The index to check.
     * @returns Whether a a flight plan exists at `planIndex`.
     */
    hasFlightPlan(planIndex: number): boolean;
    /**
     * Gets a flight plan from the flight planner.
     * @param planIndex The index of the flight plan.
     * @returns The requested flight plan.
     * @throws Error if a flight plan does not exist at `planIndex`.
     */
    getFlightPlan(planIndex: number): FlightPlan;
    /**
     * Creates a new flight plan at a specified index if one does not already exist.
     * @param planIndex The index at which to create the new flight plan.
     * @param notify Whether to send an event notification. True by default.
     * @returns The new flight plan, or the existing flight plan at `planIndex`.
     */
    createFlightPlan(planIndex: number, notify?: boolean): FlightPlan;
    /**
     * A callback which is called in response to flight plan request response sync events.
     * @param data The event data.
     */
    private onPlanCreated;
    /**
     * Sends a flight plan created event.
     * @param planIndex The index of the flight plan that was created.
     */
    private sendPlanCreated;
    /**
     * Deletes a flight plan from the flight planner.
     * @param planIndex The index of the flight plan to delete.
     * @param notify Whether to send an event notification. True by default.
     */
    deleteFlightPlan(planIndex: number, notify?: boolean): void;
    /**
     * A callback which is called in response to flight plan deleted sync events.
     * @param data The event data.
     */
    private onPlanDeleted;
    /**
     * Sends a flight plan deleted event.
     * @param planIndex The index of the flight plan that was created.
     */
    private sendPlanDeleted;
    /**
     * Builds the plan event handlers for the flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The plan event handlers.
     */
    private buildPlanEventHandlers;
    /**
     * Checks whether an active flight plan exists.
     * @returns Whether an active flight plan exists.
     */
    hasActiveFlightPlan(): boolean;
    /**
     * Gets the currently active flight plan from the flight planner.
     * @returns The currently active flight plan.
     * @throws Error if no active flight plan exists.
     */
    getActiveFlightPlan(): FlightPlan;
    /**
     * Copies a flight plan to another flight plan slot.
     * @param sourcePlanIndex The source flight plan index.
     * @param targetPlanIndex The target flight plan index.
     * @param notify Whether or not to notify subscribers that the plan has been copied.
     */
    copyFlightPlan(sourcePlanIndex: number, targetPlanIndex: number, notify?: boolean): void;
    /**
     * A callback which is called in response to flight plan copied sync events.
     * @param data The event data.
     */
    private onPlanCopied;
    /**
     * Sends a leg change event.
     * @param planIndex The index of the flight plan that was the source of the copy.
     * @param targetPlanIndex The index of the copy.
     */
    private sendPlanCopied;
    /**
     * A callback which is called in response to leg changed sync events.
     * @param data The event data.
     */
    private onLegChanged;
    /**
     * Sends a leg change event.
     * @param planIndex The index of the flight plan.
     * @param segmentIndex The index of the segment.
     * @param index The index of the leg.
     * @param type The type of change.
     * @param leg The leg that was changed.
     */
    private sendLegChanged;
    /**
     * A callback which is called in response to segment changed sync events.
     * @param data The event data.
     */
    private onSegmentChanged;
    /**
     * Sends a segment change event.
     * @param planIndex The index of the flight plan.
     * @param index The index of the segment.
     * @param type The type of change.
     * @param segment The segment that was changed.
     */
    private sendSegmentChanged;
    /**
     * A callback which is called in response to active leg changed sync events.
     * @param data The event data.
     */
    private onActiveLegChanged;
    /**
     * Sends an active leg change event.
     * @param planIndex The index of the flight plan.
     * @param index The index of the leg.
     * @param segmentIndex The index of the plan segment.
     * @param legIndex The index of the leg within the segment.
     * @param previousSegmentIndex The index of the segment in which the previously active leg is.
     * @param previousLegIndex The index of the previously active leg within the previously active segment.
     * @param type The type of leg that was changed.
     */
    private sendActiveLegChange;
    /**
     * A callback which is called in response to calculation sync events.
     * @param data The event data.
     */
    private onCalculated;
    /**
     * Sends a calculated event.
     * @param planIndex The index of the flight plan.
     * @param index The index that the path was generated from.
     */
    private sendCalculated;
    /**
     * A callback which is called in response to origin/destination changed sync events.
     * @param data The event data.
     */
    private onOriginDestChanged;
    /**
     * Sends a origin/dest change event.
     * @param planIndex The index of the flight plan.
     * @param type The origin/destination change type.
     * @param airport The airport that was changed.
     */
    private sendOriginDestChanged;
    /**
     * A callback which is called in response to procedure changed sync events.
     * @param data The event data.
     */
    private onProcedureDetailsChanged;
    /**
     * Sends a procedure details change event.
     * @param planIndex The index of the flight plan.
     * @param details The details that were changed.
     */
    private sendProcedureDetailsChanged;
    /**
     * A callback which is called in response to flight plan index changed sync events.
     * @param data The event data.
     */
    private onPlanIndexChanged;
    /**
     * Sends an active plan index change event.
     * @param planIndex The index of the flight plan.
     */
    private sendPlanIndexChanged;
    /**
     * A callback which is called in response to user data set sync events.
     * @param data The event data.
     */
    private onUserDataSet;
    /**
     * A callback which is called in response to user data delete sync events.
     * @param data The event data.
     */
    private onUserDataDelete;
    /**
     * Sends a user data set event.
     * @param planIndex The index of the flight plan.
     * @param key The key of the user data.
     * @param userData The data that was set.
     */
    private sendUserDataSet;
    /**
     * Sends a user data delete event.
     * @param planIndex The index of the flight plan.
     * @param key The key of the user data.
     */
    private sendUserDataDelete;
    /**
     * A callback which is called in response to direct to data changed sync events.
     * @param data The event data.
     */
    private onDirectToDataChanged;
    /**
     * Sends a direct to data changed event.
     * @param planIndex The index of the flight plan.
     * @param directToData The direct to data.
     */
    private sendDirectToData;
    /**
     * Method to set an active flight plan index.
     * @param planIndex The index of the flight plan to make active.
     */
    setActivePlanIndex(planIndex: number): void;
    /**
     * Sends a local event and its sync counterpart.
     * @param topic The topic of the local event.
     * @param data The event data.
     * @param sync Whether to send the sync event.
     */
    private sendEvent;
    /**
     * Gets an instance of FlightPlanner.
     * @param bus The event bus.
     * @param calculator A flight path calculator.
     * @param onLegNameRequested A callback fired when a flight plan leg is to be named.
     * @returns An instance of FlightPlanner.
     */
    static getPlanner(bus: EventBus, calculator: FlightPathCalculator, onLegNameRequested?: ((leg: FlightPlanLeg) => string | undefined)): FlightPlanner;
    /**
     * Default Method for leg naming - builds leg names using default nomenclature.
     * @param leg The leg to build a name for.
     * @returns The name of the leg.
     */
    static buildDefaultLegName(leg: FlightPlanLeg): string;
}

/**
 * A cursor for storing data while iterating
 * over the current flight plan.
 */
interface IteratorCursor {
    /** The current plan segment. */
    segment: FlightPlanSegment;
    /** The current leg index within the segment. */
    legIndex: number;
    /** The current leg definition. */
    legDefinition: LegDefinition;
    /** The current iterator index. */
    index: number;
}
/**
 * A Utility Class that supports iterating through a flight plan either forward or reverse.
 */
declare class FlightPlanLegIterator {
    private readonly cursor;
    private cursorIsBusy;
    /**
     * Method that checks whether the FlightPlanLegIterator is busy.
     * @returns Whether the cursor is busy.
     */
    isBusy(): boolean;
    /**
     * Iterates through the active flight plan in reverse order.
     * @param lateralPlan The lateral flight plan to iterate through.
     * @param each The function to call for each flight plan leg.
     * @throws an Error if the cursor is busy.
     */
    iterateReverse(lateralPlan: FlightPlan, each: (data: IteratorCursor) => void): void;
    /**
     * Iterates through the active flight plan in forward order.
     * @param lateralPlan The lateral flight plan to iterate through.
     * @param each The function to call for each flight plan leg.
     * @throws an Error if the cursor is busy.
     */
    iterateForward(lateralPlan: FlightPlan, each: (data: IteratorCursor) => void): void;
}

/**
 * The state of a given plane director.
 */
declare enum DirectorState {
    /** The plane director is not currently armed or active. */
    Inactive = "Inactive",
    /** The plane director is currently armed. */
    Armed = "Armed",
    /** The plane director is currently active. */
    Active = "Active"
}
/**
 * An autopilot plane director guidance mode.
 */
interface PlaneDirector {
    /**
     * Activates the guidance mode.
     */
    activate(): void;
    /**
     * Arms the guidance mode.
     */
    arm(): void;
    /**
     * Deactivates the guidance mode.
     */
    deactivate(): void;
    /**
     * Updates the guidance mode control loops.
     */
    update(): void;
    /**
     * A callback called when a mode signals it should
     * be activated.
     */
    onActivate?: () => void;
    /**
     * A callback called when a mode signals it should
     * be armed.
     */
    onArm?: () => void;
    /**
     * A callback called when a mode signals it should
     * be deactivated.
     */
    onDeactivate?: () => void;
    /** The current director state. */
    state: DirectorState;
}
/**
 * A director that handles OBS Lateral Navigation.
 */
interface ObsDirector extends PlaneDirector {
    /** Whether or not OBS mode is active. */
    readonly obsActive: boolean;
    /**
     * Sets the flight plan leg whose terminator defines this director's OBS fix.
     * @param index The global leg index of the leg.
     * @param leg The leg to track.
     */
    setLeg(index: number, leg: LegDefinition | null): void;
    /** Whether or not OBS mode can be activated currently. */
    canActivate(): boolean;
    /** Starts tracking the OBS course. */
    startTracking(): void;
    /** Stops tracking the OBS course. */
    stopTracking(): void;
}
/**
 * A plane director that provides no behavior.
 */
declare class EmptyDirector implements PlaneDirector {
    /** No-op. */
    activate(): void;
    /** No-op. */
    deactivate(): void;
    /** No-op. */
    update(): void;
    /** No-op. */
    onActivate: () => void;
    /** No-op */
    onArm: () => void;
    /** No-op. */
    arm(): void;
    state: DirectorState;
    /** An instance of the empty plane director. */
    static instance: EmptyDirector;
}

/**
 * An interface that describes a manager for dictating nav to nav transfer behavior
 * and criteria.
 */
interface NavToNavManager {
    /**
     * A callback called when the nav transfer has been completed.
     */
    onTransferred: () => void;
    /**
     * A method that determines whether or not nav mode can be armed
     * when approach mode is attempted to be armed.
     * @returns True if it can be armed, false otherwise.
     */
    canLocArm(): boolean;
    /**
     * A method that determines whether or not an armed loc nav mode can
     * become active.
     * @returns True if it can become active, false otherwise.
     */
    canLocActivate(): boolean;
}

/**
 * The current vertical navigation state.
 */
declare enum VNavState {
    /** VNAV Disabled. */
    Disabled = 0,
    /** VNAV Enabled and Inactive. */
    Enabled_Inactive = 1,
    /** VNAV Enabled and Active. */
    Enabled_Active = 2
}
/**
 * The current VNAV path mode.
 */
declare enum VNavPathMode {
    /** VNAV path is not active. */
    None = 0,
    /** VNAV path is armed for capture. */
    PathArmed = 1,
    /** VNAV path is actively navigating. */
    PathActive = 2,
    /** The current VNAV path is not valid. */
    PathInvalid = 3
}
/**
 * The current Approach Guidance Mode.
 */
declare enum ApproachGuidanceMode {
    /** VNAV is not currently following approach guidance. */
    None = 0,
    /** VNAV has armed ILS glideslope guidance for capture. */
    GSArmed = 1,
    /** VNAV is actively following ILS glideslope guidance. */
    GSActive = 2,
    /** VNAV RNAV glidepath guidance is armed for capture. */
    GPArmed = 3,
    /** VNAV is actively follow RNAV glidepath guidance. */
    GPActive = 4
}
/**
 * The current VNAV altitude capture type.
 */
declare enum VNavAltCaptureType {
    /** Altitude capture is not armed. */
    None = 0,
    /** Altitude will capture the selected altitude. */
    Selected = 1,
    /** Altitude will capture the VANV target altitude. */
    VNAV = 2
}
/**
 * The current Vertical Flight Phase.
 */
declare enum VerticalFlightPhase {
    /** The current vertical phase is Climb. */
    Climb = 0,
    /** The current vertical phase is Descent. */
    Descent = 1
}
/**
 * A Vertical Flight Plan cooresponding to a lateral flight plan.
 */
interface VerticalFlightPlan {
    /** The Flight Plan Index */
    planIndex: number;
    /** The Flight Plan Segments in the VerticalFlightPlan (should always be the same as the lateral plan) */
    segments: VNavPlanSegment[];
    /** The VNav Constraints in this Vertical Flight Plan */
    constraints: VNavConstraint[];
    /** The global leg index of the destination leg, or undefined */
    destLegIndex: number | undefined;
    /** The global leg index of the FAF leg, or undefined */
    fafLegIndex: number | undefined;
    /** The global leg index of the first descent constraint, or undefined */
    firstDescentConstraintLegIndex: number | undefined;
    /** The global leg index of the last descent constraint, or undefined */
    lastDescentConstraintLegIndex: number | undefined;
    /** The global leg index of the first missed approach leg, or undefined */
    missedApproachStartIndex: number | undefined;
    /** The global leg index of the currently active vertical direct leg, or undefined */
    verticalDirectIndex: number | undefined;
    /** The current along leg distance for the active lateral leg in this flight plan */
    currentAlongLegDistance: number | undefined;
    /** Whether the cooresponding lateral flight plan has changed */
    planChanged: boolean;
}
/**
 * Details about the next TOD and BOD.
 */
interface TodBodDetails {
    /**
     * The global index of the leg that contains the next BOD, or -1 if there is no BOD. The next BOD is defined as the
     * next point in the flight path including or after the active leg where the VNAV profile transitions from a descent
     * to a level-off, discontinuity, or the end of the flight path.
     */
    bodLegIndex: number;
    /**
     * The global index of the leg that contains the TOD associated with the next BOD, or -1 if there is no such TOD. The
     * TOD is defined as the point along the flight path at which the aircraft will intercept the VNAV profile continuing
     * to the next BOD if it continues to fly level at its current altitude.
     */
    todLegIndex: number;
    /** The distance from the TOD to the end of its containing leg, in meters. */
    todLegDistance: number;
    /** The distance along the flight path from the airplane's present position to the TOD, in meters. */
    distanceFromTod: number;
    /** The distance along the flight path from the airplane's present position to the BOD, in meters. */
    distanceFromBod: number;
    /** The global index of the leg that contains the current VNAV constraint. */
    currentConstraintLegIndex: number;
}
/**
 * A leg in the calculated Vertical Flight Plan.
 */
interface VNavLeg {
    /** The index of the flight plan segment. */
    segmentIndex: number;
    /** The index of the leg within the plan segment. */
    legIndex: number;
    /** The name of the leg. */
    name: string;
    /** The fpa of the leg. */
    fpa: number;
    /** The distance of the leg. */
    distance: number;
    /** Whether the leg is eligible for VNAV. */
    isEligible: boolean;
    /** If the leg is a bottom of descent. */
    isBod: boolean;
    /** Whether or not the altitude provided is advisory. */
    isAdvisory: boolean;
    /** The altitude that the leg ends at. */
    altitude: number;
    /** Whether or not the constraint at this leg is user defined. */
    isUserDefined: boolean;
    /** Whether or not the leg is a direct to target. */
    isDirectToTarget: boolean;
    /** The constrant altitude assigned to this leg that is invalid, if one exists. */
    invalidConstraintAltitude?: number;
}
/**
 * A Vertical Flight Plan Constraint.
 */
interface VNavConstraint {
    /** The global leg index for the constraint. */
    index: number;
    /** The min altitude of the constraint. */
    minAltitude: number;
    /** The max altitude of the constraint. */
    maxAltitude: number;
    /** The target altitude of the constraint. */
    targetAltitude: number;
    /**
     * Whether or not this constraint is a target that will be held at
     * during a level-off or whether it will instead be passed through
     * with no level off.
     */
    isTarget: boolean;
    /** Whether or not this constraint is the last constraint prior to a MANSEQ or other VNAV ineligible leg type. */
    isPathEnd: boolean;
    /** If this constraint isPathEnd, what is the leg index of the next vnav eligible leg. */
    nextVnavEligibleLegIndex?: number;
    /** The name of the leg at this constraint. */
    name: string;
    /** The total distance of the legs that make up this constriant segment. */
    distance: number;
    /** The flight path angle to take through the legs in this constraint. */
    fpa: number;
    /** The legs contained in this constraint segment. */
    legs: VNavLeg[];
    /** The type of constraint segment. */
    type: 'normal' | 'dest' | 'cruise' | 'dep' | 'direct' | 'missed' | 'manual' | 'climb' | 'descent';
    /** Whether or not this constraint is beyond the FAF. */
    isBeyondFaf: boolean;
}
/**
 * A segment in the Vertical Flight Plan.
 */
interface VNavPlanSegment {
    /** The index offset that the segment begins at. */
    offset: number;
    /** The VNAV legs contained in the segment. */
    legs: VNavLeg[];
}
/**
 * The current state of VNAV availability from the director.
 */
declare enum VNavAvailability {
    Available = "Available",
    InvalidLegs = "InvalidLegs"
}

/**
 * A Vertical Navigation Manager.
 */
interface VNavManager {
    /**
     * Sets the state of the manager.
     */
    setState(vnavState: VNavState): void;
    /**
     * Tries to activate the manager.
     */
    tryActivate(): void;
    /**
     * Tries to deactivate the manager.
     * @param newMode Is the new mode to set active in the Autopilot if Path Mode is currently active.
     */
    tryDeactivate(newMode?: APVerticalModes): void;
    /**
     * Updates the manager.
     */
    update(): void;
    /**
     * A callback called by the autopilot to check if a vertical mode can be activated.
     */
    canVerticalModeActivate: (mode: APVerticalModes) => boolean;
    /** A callback called when the APVNavPathDirector Deactivates. */
    onPathDirectorDeactivated: () => void;
    /**
     * A callback called by the autopilot to arm the supplied vertical mode.
     */
    armMode?: (mode: APVerticalModes) => void;
    /**
     * A callback called by the autopilot to activate the supplied vertical mode.
     */
    activateMode?: (mode: APVerticalModes) => void;
    /** A callback called when the manager is activated. */
    onActivate?: () => void;
    /** A callback called when the manager is deactivated. */
    onDeactivate?: () => void;
    /** The current manager state. */
    state: VNavState;
}

declare enum APVerticalModes {
    NONE = 0,
    PITCH = 1,
    VS = 2,
    FLC = 3,
    ALT = 4,
    PATH = 5,
    GP = 6,
    GS = 7,
    CAP = 8
}
declare enum APLateralModes {
    NONE = 0,
    ROLL = 1,
    LEVEL = 2,
    GPSS = 3,
    HEADING = 4,
    VOR = 5,
    LOC = 6,
    BC = 7,
    NAV = 8
}
declare enum APAltitudeModes {
    NONE = 0,
    ALTS = 1,
    ALTV = 2
}
/** AP Values Object */
declare type APValues = {
    /** The selected altitude, in feet. */
    readonly selectedAltitude: Subject<number>;
    /** The selected vertical speed target, in feet per minute. */
    readonly selectedVerticalSpeed: Subject<number>;
    /** The selected indicated airspeed target, in knots. */
    readonly selectedIas: Subject<number>;
    /** The selected mach target. */
    readonly selectedMach: Subject<number>;
    /** Whether the selected airspeed target is in mach. */
    readonly isSelectedSpeedInMach: Subject<boolean>;
    /** The selected pitch target, in degrees. */
    readonly selectedPitch: Subject<number>;
    /** The maximum Bank Angle the autopilot may command in absolute degrees. */
    readonly maxBankAngle: Subject<number>;
    /** The selected heading, in degrees. */
    readonly selectedHeading: Subject<number>;
    /** The captured altitude, in feet. */
    readonly capturedAltitude: Subject<number>;
    /** Approach is Activated in Flight Plan */
    readonly approachIsActive: Subject<boolean>;
    /** The activated approach has an LPV GP */
    readonly approachHasGP: Subject<boolean>;
    /** The Nav 1 Radio is tuned to an ILS with a GS signal */
    readonly nav1HasGs: Subject<boolean>;
    /** The Nav 2 Radio is tuned to an ILS with a GS signal */
    readonly nav2HasGs: Subject<boolean>;
    /** The Active Lateral Mode */
    readonly lateralActive: Subject<APLateralModes>;
    /** The Active Vertical Mode */
    readonly verticalActive: Subject<APVerticalModes>;
    /** The Armed Lateral Mode */
    readonly lateralArmed: Subject<APLateralModes>;
    /** The Armed Vertical Mode */
    readonly verticalArmed: Subject<APVerticalModes>;
    /** The AP Approach Mode is on */
    readonly apApproachModeOn: Subject<boolean>;
    /** Returns whether nav to nav says that LOC can be armed. */
    navToNavLocArm?: () => boolean;
};
/**
 * An autopilot configuration.
 */
interface APConfig {
    /**
     * Creates the autopilot's VNAV Manager.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's VNAV Manager.
     */
    createVNavManager(apValues: APValues): VNavManager | undefined;
    /**
     * Creates the autopilot's nav-to-nav manager.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's nav-to-nav manager.
     */
    createNavToNavManager(apValues: APValues): NavToNavManager | undefined;
    /**
     * Creates the autopilot's variable bank manager.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's variable bank manager.
     */
    createVariableBankManager(apValues: APValues): Record<any, any> | undefined;
    /**
     * Creates the autopilot's VNAV Path mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's VNAV Path mode director.
     */
    createVNavPathDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's heading mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's heading mode director.
     */
    createHeadingDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's roll mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's heading mode director.
     */
    createRollDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's wings level mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's wings level mode director.
     */
    createWingLevelerDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's GPS LNAV mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's GPS LNAV mode director.
     */
    createGpssDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's VOR mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's VOR mode director.
     */
    createVorDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's LOC mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's LOC mode director.
     */
    createLocDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's back-course mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's back-course mode director.
     */
    createBcDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's pitch mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's pitch mode director.
     */
    createPitchDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's vertical speed mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's vertical speed mode director.
     */
    createVsDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's flight level change mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's flight level change mode director.
     */
    createFlcDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's altitude hold mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's altitude hold mode director.
     */
    createAltHoldDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's altitude capture mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's altitude capture mode director.
     */
    createAltCapDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's GPS glidepath mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's GPS glidepath mode director.
     */
    createGpDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's ILS glideslope mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's ILS glideslope mode director.
     */
    createGsDirector(apValues: APValues): PlaneDirector | undefined;
    /** The autopilot's default lateral mode. */
    defaultLateralMode: APLateralModes;
    /** The autopilot's default vertical mode. */
    defaultVerticalMode: APVerticalModes;
    /** The default maximum bank angle the autopilot may command in degrees. */
    defaultMaxBankAngle: number;
}

declare enum APStates {
    None = 0,
    APActive = 1,
    YawDamper = 2,
    Heading = 4,
    Nav = 8,
    NavArmed = 16,
    Approach = 32,
    ApproachArmed = 64,
    Backcourse = 128,
    BackcourseArmed = 256,
    Alt = 512,
    AltS = 1024,
    AltV = 2048,
    VS = 4096,
    FLC = 8192,
    GP = 16384,
    GPArmed = 32768,
    GS = 65536,
    GSArmed = 131072,
    Path = 262144,
    PathArmed = 524288,
    PathInvalid = 1048576,
    Pitch = 2097152,
    Roll = 4194304,
    VNAV = 8388608,
    ATSpeed = 16777216,
    ATMach = 33554432,
    ATArmed = 67108864,
    FD = 134217728
}

/** AP Mode Types */
declare enum APModeType {
    LATERAL = 0,
    VERTICAL = 1,
    APPROACH = 2
}
/** Interface for APModePressEvents */
interface APModePressEvent {
    /** The Mode */
    mode: APLateralModes | APVerticalModes;
    /** The Set Value, if any */
    set?: boolean;
}
/**
 * A class that manages the autopilot modes and autopilot mode states.
 */
declare abstract class APStateManager {
    protected readonly bus: EventBus;
    private keyInterceptManager?;
    private readonly apListener;
    private apListenerRegistered;
    private managedModeSet;
    stateManagerInitialized: Subject<boolean>;
    lateralPressed: SubEvent<this, APModePressEvent>;
    verticalPressed: SubEvent<this, APModePressEvent>;
    approachPressed: SubEvent<this, boolean | undefined>;
    vnavPressed: SubEvent<this, boolean>;
    apMasterOn: Subject<boolean>;
    isFlightDirectorOn: Subject<boolean>;
    isFlightDirectorCoPilotOn: Subject<boolean>;
    /**
     * Creates an instance of the APStateManager.
     * @param bus An instance of the event bus.
     */
    constructor(bus: EventBus);
    /**
     * A callback which is called when the autopilot listener has been registered.
     */
    protected onAPListenerRegistered(): void;
    /**
     * Sets up key intercepts for the simulation autopilot key events.
     * @param manager The key intercept manager.
     */
    protected abstract setupKeyIntercepts(manager: KeyInterceptManager): void;
    /**
     * Handles an intercepted key event.
     * @param data The event data.
     */
    protected abstract handleKeyIntercepted(data: KeyEventData): void;
    /**
     * Checks whether the AP State Manager has completed listerner steps,
     * and if so, finishes initializing and then notifies Autopilot of the same.
     * @param force forces the initialize
     */
    initialize(force?: boolean): void;
    /**
     * Sets the Flight Director State
     * @param on is wheter to set the FD On.
     */
    setFlightDirector(on: boolean): void;
    /**
     * Sets Managed Mode.
     * @param set is wheter to set or unset managed mode.
     */
    private setManagedMode;
    /**
     * Toggles VNAV L Var value.
     */
    protected toggleVnav(): void;
    /**
     * Sends AP Mode Events from the Intercept to the Autopilot.
     * @param type is the AP Mode Type for this event
     * @param mode is the mode to set/unset.
     * @param set is whether to actively set or unset this mode.
     */
    protected sendApModeEvent(type: APModeType, mode?: APLateralModes | APVerticalModes, set?: boolean): void;
    /**
     * Method to override with steps to run before initialze method is run.
     */
    protected onBeforeInitialize(): void;
}

/**
 * A collection of autopilot plane directors.
 */
declare type APDirectors = {
    /** The autopilot's heading mode director. */
    readonly headingDirector?: PlaneDirector;
    /** The autopilot's roll mode director. */
    readonly rollDirector?: PlaneDirector;
    /** The autopilot's wings level mode director. */
    readonly wingLevelerDirector?: PlaneDirector;
    /** The autopilot's GPS LNAV mode director. */
    readonly gpssDirector?: PlaneDirector;
    /** The autopilot's VOR mode director. */
    readonly vorDirector?: PlaneDirector;
    /** The autopilot's LOC  mode director. */
    readonly locDirector?: PlaneDirector;
    /** The autopilot's back-course mode director. */
    readonly bcDirector?: PlaneDirector;
    /** The autopilot's pitch mode director. */
    readonly pitchDirector?: PlaneDirector;
    /** The autopilot's vertical speed mode director. */
    readonly vsDirector?: PlaneDirector;
    /** The autopilot's flight level change mode director. */
    readonly flcDirector?: PlaneDirector;
    /** The autopilot's altitude hold mode director. */
    readonly altHoldDirector?: PlaneDirector;
    /** The autopilot's wings altitude capture director. */
    readonly altCapDirector?: PlaneDirector;
    /** The autopilot's VNAV path mode director. */
    readonly vnavPathDirector?: PlaneDirector;
    /** The autopilot's GPS glidepath mode director. */
    readonly gpDirector?: PlaneDirector;
    /** The autopilot's ILS glideslope mode director. */
    readonly gsDirector?: PlaneDirector;
};
/**
 * An Autopilot.
 */
declare class Autopilot {
    protected readonly bus: EventBus;
    protected readonly flightPlanner: FlightPlanner;
    protected readonly config: APConfig;
    readonly stateManager: APStateManager;
    /** This autopilot's plane directors. */
    readonly directors: APDirectors;
    /** This autopilot's nav-to-nav transfer manager. */
    readonly navToNavManager: NavToNavManager | undefined;
    /** This autopilot's VNav Manager. */
    readonly vnavManager: VNavManager | undefined;
    /** This autopilot's variable bank angle Manager. */
    readonly variableBankManager: Record<any, any> | undefined;
    protected cdiSource: NavSourceId;
    protected lateralModes: Map<APLateralModes, PlaneDirector>;
    protected verticalModes: Map<APVerticalModes, PlaneDirector>;
    protected verticalAltitudeArmed: APAltitudeModes;
    protected verticalApproachArmed: APVerticalModes;
    protected altCapArmed: boolean;
    protected lateralModeFailed: boolean;
    protected inClimb: boolean;
    protected currentAltitude: number;
    protected vnavCaptureType: VNavAltCaptureType;
    protected flightPlanSynced: boolean;
    /** Can be set to false in child classes to override behavior for certain aircraft. */
    protected requireApproachIsActiveForNavToNav: boolean;
    readonly apValues: APValues;
    protected autopilotInitialized: boolean;
    /**
     * Creates an instance of the Autopilot.
     * @param bus The event bus.
     * @param flightPlanner This autopilot's associated flight planner.
     * @param config This autopilot's configuration.
     * @param stateManager This autopilot's state manager.
     */
    constructor(bus: EventBus, flightPlanner: FlightPlanner, config: APConfig, stateManager: APStateManager);
    /**
     * Creates this autopilot's directors.
     * @param config This autopilot's configuration.
     * @returns This autopilot's directors.
     */
    private createDirectors;
    /**
     * Update method for the Autopilot.
     */
    update(): void;
    /**
     * This method runs each update cycle before the update occurs.
     */
    protected onBeforeUpdate(): void;
    /**
     * This method runs each update cycle after the update occurs.
     */
    protected onAfterUpdate(): void;
    /**
     * This method runs whenever the initialized state of the Autopilot changes.
     */
    protected onInitialized(): void;
    /**
     * Handles input from the State Manager when a lateral mode button is pressed.
     * @param data is the AP Lateral Mode Event Data
     */
    protected lateralPressed(data: APModePressEvent): void;
    /**
     * Handles input from the State Manager when a vertical mode button is pressed.
     * @param data is the AP Vertical Mode Event Data
     */
    protected verticalPressed(data: APModePressEvent): void;
    /**
     * Checks if a mode is active or armed and optionally deactivates it.
     * @param mode is the AP Mode to check.
     * @returns whether this mode was active or armed and subsequently disabled.
     */
    protected isLateralModeActivatedOrArmed(mode: APLateralModes): boolean;
    /**
     * Checks if a mode is active or armed and deactivates it.
     * @param mode is the AP Mode to check.
     * @returns whether this mode was active or armed and subsequently disabled.
     */
    protected deactivateArmedOrActiveVerticalMode(mode: APVerticalModes): boolean;
    /**
     * Handles input from the State Manager when the APPR button is pressed.
     * @param set is whether this event commands a specific set
     */
    protected approachPressed(set?: boolean): void;
    /**
     * Returns the AP Lateral Mode that can be armed.
     * @returns The AP Lateral Mode that can be armed.
     */
    protected getArmableApproachType(): APLateralModes;
    /**
     * Callback to set the lateral active mode.
     * @param mode is the mode being set.
     */
    protected setLateralActive(mode: APLateralModes): void;
    /**
     * Callback to set the lateral armed mode.
     * @param mode is the mode being set.
     */
    private setLateralArmed;
    /**
     * Callback to set the vertical active mode.
     * @param mode is the mode being set.
     */
    private setVerticalActive;
    /**
     * Callback to set the vertical armed mode.
     * @param mode is the mode being set.
     */
    private setVerticalArmed;
    /**
     * Callback to set the vertical approach armed mode.
     * @param mode is the mode being set.
     */
    private setVerticalApproachArmed;
    /**
     * Method called when the ALT button is pressed.
     */
    protected setAltHold(): void;
    /**
     * Initializes the Autopilot with the available lateral modes from the config.
     */
    private initLateralModes;
    /**
     * Initializes the Autopilot with the available Nav To Nav Manager.
     */
    private initNavToNavManager;
    /**
     * Initializes the Autopilot with the available VNav Manager.
     */
    protected initVNavManager(): void;
    /**
     * Initializes the Autopilot with the available vertical modes from the config.
     */
    private initVerticalModes;
    /**
     * Checks if all the active and armed modes are still in their proper state
     * and takes corrective action if not.
     */
    private checkModes;
    /**
     * Runs update on each of the active and armed modes.
     */
    private updateModes;
    /**
     * Checks and sets the proper armed altitude mode.
     */
    protected manageAltitudeCapture(): void;
    /**
     * Monitors subevents and bus events.
     */
    private monitorEvents;
    /**
     * Additional events to be monitored (to be overridden).
     */
    protected monitorAdditionalEvents(): void;
    /**
     * Manages the FD state and the modes when AP/FD are off.
     */
    protected handleApFdStateChange(): void;
    /**
     * Sets a sim AP mode.
     * @param mode The mode to set.
     * @param enabled Whether or not the mode is enabled or disabled.
     */
    private setSimAP;
    /**
     * Checks if the sim AP is in roll mode and sets it if not.
     */
    protected checkRollModeActive(): void;
    /**
     * Checks if the sim AP is in pitch mode and sets it if not.
     */
    private checkPitchModeActive;
}

/**
 * A class that synchronizes the local NXi state to the sim GPS system.
 */
declare class GpsSynchronizer {
    private bus;
    private flightPlanner;
    private readonly facLoader;
    private magvar;
    private distanceToCurrentLeg;
    private groundSpeed;
    private trueTrack;
    private zuluTime;
    private numPlanLegs;
    private hasReachedDestination;
    private isDestinationLegActive;
    private isDirectToActive;
    private readonly gpFpa;
    private readonly gpDeviation;
    private readonly isApproachActive;
    private readonly approachHasGp;
    private readonly gsiScaling;
    /**
     * Creates an instance of GpsSynchronizer.
     * @param bus The bus to source events from.
     * @param flightPlanner An instance of the flight planner.
     * @param facLoader An instance of the facility loader.
     */
    constructor(bus: EventBus, flightPlanner: FlightPlanner, facLoader: FacilityLoader);
    /**
     * Updates the GpsSynchronizer.
     */
    update(): void;
    /**
     * Handles when the active plan segments are changed.
     */
    private onPlanChanged;
    /**
     * Handles when the course steered by LNAV changes.
     * @param course The course steered by LNAV, in degrees true.
     */
    private onLNavCourseToSteerChanged;
    /**
     * Checks to see if we are in a direct to state.
     * @param plan The Active Flight Plan.
     */
    private checkDirectToState;
    private onDirectToActive;
    private onDestinationReached;
    private onGpDeviation;
    private onGpFpa;
    private onApproachActive;
    private onApproachHasGp;
    private onGsiScaling;
    /**
     * Checks to see if we have reached the plan destination.
     * @param plan The Active Flight Plan
     */
    private checkDestinationLegActive;
    /**
     * Checks the approach mode on leg change.
     * @param plan The Active Flight Plan.
     * @param isApproachActive Whether the approach is active.
     * @param fafIndex The destination leg index.
     */
    private checkApproachMode;
    /**
     * Handles when the active leg index changes.
     * @param plan The Active Flight Plan.
     */
    private onWaypointIndexChanged;
    /**
     * Handles when the number of active plan legs changes.
     * @param numLegs The number of active plan legs.
     */
    private onNumLegsChanged;
    /**
     * Handles when the previous leg changes.
     * @param plan The Active Flight Plan
     */
    private onIsPrevLegChanged;
    /**
     * Handles when the LNAV Distance to Destination Changes.
     * @param dis The new distance to destination.
     */
    private onLnavDistanceToDestinationChanged;
    /**
     * Handles when the LNAV DTK changes.
     * @param dtk The new DTK.
     */
    private onDtkChanged;
    /**
     * Handles when the LNAV XTK changes.
     * @param xtk The new XTK.
     */
    private onXtkChanged;
    /**
     * Handles when the LNAV DIS to WP changes.
     * @param dis The distance.
     */
    private onLnavDistanceChanged;
    /**
     * Handles when the LNAV Bearing to WP changes.
     * @param brg The bearing.
     */
    private onLnavBearingChanged;
    /**
     * Handles when the True Ground Track Changes.
     * @param trk The true track.
     */
    private onTrackTrueChanged;
    /**
     * Handles when the Ground Speed changes.
     * @param gs The current ground speed.
     */
    private onGroundSpeedChanged;
    /**
     * Handles when the true heading changes.
     * @param hdg The true heading.
     */
    private onTrueHeadingChanged;
    /**
     * Handles when the magvar changes.
     * @param magvar The new magvar.
     */
    private onMagvarChanged;
    /**
     * Handle when the VNAV Target Altitude changes.
     * @param targetAlt Target Altitude [feet] (can be -1 if none is defined or available)
     */
    private onTargetAltChanged;
    /**
     * Handle when the VNAV Active Leg Altitude Changes.
     * @param alt The active leg altitude in meters.
     */
    private onActiveLegAltChanged;
    /**
     * Handles when the VNAV required VS changes.
     * @param vs The required vertical speed.
     */
    private requiredVsChanged;
    /**
     * Handles when the distance to the GlidePath Target changes.
     * @param dis The distance to the glidepath target (runway).
     */
    private onGpDistanceChanged;
    /**
     * Handles when the plane position changes.
     * @param pos The new plane position.
     */
    private onPositionChanged;
    /**
     * Handles checking the approach type and timezone.
     * @param plan The active flight plan.
     * @param approachIndex The approach index in the active plan.
     */
    private checkApproachTypeAndTimezone;
    /**
     * Handles checking the approach waypoint type.
     * @param leg The active lateral leg.
     */
    private checkApproachWaypointType;
}

/**
 * A Utility Class for VNAV
 */
declare class VNavUtils {
    /**
     * Checks if a constraint is a user-created constraint.
     * @param lateralLeg The Lateral Flight Plan Leg.
     * @returns If this constraint is a user-created constraint.
     */
    static isUserConstraint(lateralLeg: LegDefinition): boolean;
    /**
     * Gets the current required vertical speed.
     * @param distance is the distance to the constraint (in nautical miles).
     * @param targetAltitude is the target altitude for the constraint (in meters).
     * @param currentAltitude is the current altitude (in feet)
     * @param groundSpeed is the current groundspeed
     * @returns the required vs in fpm.
     */
    static getRequiredVs(distance: number, targetAltitude: number, currentAltitude: number, groundSpeed: number): number;
    /**
     * Gets the requiured vertical speed for a given FPA and groundspeed.
     * @param fpa The FPA in degrees
     * @param groundspeed The current groundspeed.
     * @returns The rate of descent required to descend at the specified FPA in ft/minute.
     */
    static getVerticalSpeedFromFpa(fpa: number, groundspeed: number): number;
    /**
     * Gets the flight path angle for a given distance and altitude.
     * @param distance The distance to get the angle for.
     * @param altitude The altitude to get the angle for.
     * @returns The required flight path angle, in degrees.
     */
    static getFpa(distance: number, altitude: number): number;
    /**
     * Gets an increase in altitude for a given flight path angle and
     * lateral distance.
     * @param fpa The flight path angle to use, in degrees.
     * @param distance The lateral distance.
     * @returns The increase in altitude.
     */
    static altitudeForDistance(fpa: number, distance: number): number;
    /**
     * Gets a lateral distance for a given altitude increase and flight
     * path angle.
     * @param fpa The flight path angle to use, in degrees.
     * @param altitude The increase in altitude.
     * @returns The lateral distance.
     */
    static distanceForAltitude(fpa: number, altitude: number): number;
    /**
     * Gets the missed approach leg index.
     * @param plan The flight plan.
     * @returns The Destination leg global leg index.
     */
    static getMissedApproachLegIndex(plan: FlightPlan): number;
    /**
     * Gets the FAF index in the plan.
     * @param plan The flight plan.
     * @returns The FAF index in the plan.
     */
    static getFafIndex(plan: FlightPlan): number | undefined;
    /**
     * Finds and returns the FAF index in the plan.
     * @param lateralPlan The lateral flight plan.
     * @param iterator The FlightPlanLegIterator instance.
     * @returns The FAF index in the lateral flight plan.
     */
    static getFafIndexReverse(lateralPlan: FlightPlan, iterator: FlightPlanLegIterator): number;
    /**
     * Gets the index of the constraint containing an indexed leg.
     * @param verticalPlan The vertical flight plan
     * @param globalLegIndex The global leg index to find the constraint for.
     * @returns The index of the constraint containing the leg at the specified global index, or -1 if one could not be
     * found.
     */
    static getConstraintIndexFromLegIndex(verticalPlan: VerticalFlightPlan, globalLegIndex: number): number;
    /**
     * Gets the VNAV Constraint immediately prior to the constraint that contains a flight plan leg.
     * @param verticalPlan The vertical flight plan
     * @param globalLegIndex The global leg index of a flight plan leg.
     * @returns The VNAV Constraint immediately prior to the constraint that contains the flight plan leg with the
     * specified global leg index.
     */
    static getPriorConstraintFromLegIndex(verticalPlan: VerticalFlightPlan, globalLegIndex: number): VNavConstraint | undefined;
    /**
     * Gets and returns whether the input leg index is a path end.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex is the global leg index to check.
     * @returns whether the input leg index is a path end.
     */
    static getIsPathEnd(verticalPlan: VerticalFlightPlan, globalLegIndex: number): boolean;
    /**
     * Gets the VNAV Constraint that contains the supplied leg index.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The flight plan global leg index to find the constraint for.
     * @returns The VNAV Constraint that contains the input leg index.
     */
    static getConstraintFromLegIndex(verticalPlan: VerticalFlightPlan, globalLegIndex: number): VNavConstraint | undefined;
    /**
     * Gets the global leg index for the constraint containing an indexed leg.
     * @param verticalPlan The vertical plan.
     * @param globalLegIndex A global leg index.
     * @returns The global leg index for the constraint containing the leg at the specified global index, or -1 if one
     * could not be found.
     */
    static getConstraintLegIndexFromLegIndex(verticalPlan: VerticalFlightPlan, globalLegIndex: number): number;
    /**
     * Gets a constraint segment distance from the constraint legs.
     * @param constraint The constraint to calculate a distance for.
     * @returns The constraint distance.
     */
    static getConstraintDistanceFromConstraint(constraint: VNavConstraint): number;
    /**
     * Gets a constraint segment distance from the Vertical Plan legs.
     * @param constraint The constraint to calculate a distance for.
     * @param previousConstraint The constraint that preceds the constraint we are calculating the distance for.
     * @param verticalPlan The Vertical Flight Plan.
     * @returns The constraint distance.
     */
    static getConstraintDistanceFromLegs(constraint: VNavConstraint, previousConstraint: VNavConstraint | undefined, verticalPlan: VerticalFlightPlan): number;
    /**
     * Gets the distance from the current location in the plan to the constraint.
     * @param constraint The vnav constraint to calculate the distance to.
     * @param lateralPlan The lateral flight plan.
     * @param activeLegIndex The current active leg index.
     * @param distanceAlongLeg The current distance along leg.
     * @returns the distance to the constraint, or positive infinity if a discontinuity exists between the ppos and the constraint.
     */
    static getDistanceToConstraint(constraint: VNavConstraint, lateralPlan: FlightPlan, activeLegIndex: number, distanceAlongLeg: number): number;
    /**
     * Gets and returns the vertical direct constraint based on an input index.
     * @param verticalPlan The vertical flight plan.
     * @param selectedGlobalLegIndex The global leg index selected for vertical direct.
     * @param activeLegIndex The active leg index.
     * @returns The Vnav Constraint for the vertical direct or undefined.
     */
    static getVerticalDirectConstraintFromIndex(verticalPlan: VerticalFlightPlan, selectedGlobalLegIndex: number, activeLegIndex: number): VNavConstraint | undefined;
    /**
     * Gets the next climb constraint with a max altitude less than POSITIVE_INFINITY.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index to find the constraint for.
     * @returns the VNavConstraint or undefined
     */
    static getNextClimbConstraint(verticalPlan: VerticalFlightPlan, globalLegIndex: number): VNavConstraint | undefined;
    /**
     * Gets the VNAV desired altitude.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index to get the target for.
     * @param distanceAlongLeg The distance along the leg the aircraft is presently.
     * @returns The current VNAV desired altitude.
     */
    static getDesiredAltitude(verticalPlan: VerticalFlightPlan, globalLegIndex: number, distanceAlongLeg: number): number;
    /**
     * Gets and returns the FAF altitude.
     * @param verticalPlan The vertical flight plan.
     * @returns the FAF constraint altitude.
     */
    static getFafAltitude(verticalPlan: VerticalFlightPlan): number | undefined;
    /**
     * Gets the VNAV TOD/BOD details for a vertical flight plan.
     * @param verticalPlan The vertical flight plan.
     * @param activeLegIndex The current active leg index.
     * @param distanceAlongLeg The distance the plane is along the current leg in meters.
     * @param currentAltitude The current indicated altitude in meters.
     * @param currentVS The current vertical speed in meters per minute.
     * @param out The object to which to write the TOD/BOD details.
     * @returns The VNAV TOD/BOD details.
     */
    static getTodBodDetails(verticalPlan: VerticalFlightPlan, activeLegIndex: number, distanceAlongLeg: number, currentAltitude: number, currentVS: number, out: TodBodDetails): TodBodDetails;
    /**
     * Checks whether or not the vertical plan has a leg at a given globalLegIndex.
     * @param verticalPlan The Vertical Flight Plan.
     * @param globalLegIndex The global leg index to check.
     * @returns True if the leg exists.
     */
    static verticalPlanHasLeg(verticalPlan: VerticalFlightPlan, globalLegIndex: number): boolean;
    /**
     * Gets a VNAV leg from a vertical flight plan.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the leg to get.
     * @returns The requested VNAV leg.
     * @throws Not found if the index is not valid.
     */
    static getVerticalLegFromPlan(verticalPlan: VerticalFlightPlan, globalLegIndex: number): VNavLeg;
    /**
     * Gets a VNAV leg from the plan from a specified segment.
     * @param verticalPlan The vertical flight plan.
     * @param segmentIndex The segment index of the leg to get.
     * @param legIndex The index of the leg to get within the specified segment.
     * @returns The requested VNAV leg.
     * @throws Not found if the index is not valid.
     */
    static getVerticalLegFromSegmentInPlan(verticalPlan: VerticalFlightPlan, segmentIndex: number, legIndex: number): VNavLeg;
    /**
     * Gets the constraint for a vertical direct based on an input global leg index.
     * @param verticalPlan The vertical flight plan.
     * @param activeGlobalLegIndex The current active global leg index.
     * @param selectedGlobalLegIndex The input global leg index selected.
     * @returns The constraint, or undefined if none exists.
     */
    static getConstraintForVerticalDirect(verticalPlan: VerticalFlightPlan, activeGlobalLegIndex: number, selectedGlobalLegIndex: number): VNavConstraint | undefined;
    /**
     * Gets the VNAV segments from the calculated VNAV plan.
     * @param verticalPlan The vertical flight plan.
     * @returns The vnav segments.
     * @throws Not found if the index is not valid.
     */
    static getVerticalSegmentsFromPlan(verticalPlan: VerticalFlightPlan): VNavPlanSegment[];
    /**
     * Gets whether a lateral plan leg is a hold or procedure turn.
     * @param lateralLeg The Lateral Leg in the flight plan (LegDefinition).
     * @returns Whether the leg is a hold or procedure turn.
     */
    static isLegTypeHoldOrProcedureTurn(lateralLeg: LegDefinition): boolean;
    /**
     * Creates a new empty vertical flight plan constraint.
     * @param index The leg index of the constraint.
     * @param minAltitude The bottom altitude of the constraint.
     * @param maxAltitude THe top altitude of the constraint.
     * @param name The name of the leg for the constraint.
     * @param type The type of constraint.
     * @returns A new empty constraint.
     */
    static createConstraint(index: number, minAltitude: number, maxAltitude: number, name: string, type?: 'climb' | 'descent' | 'direct' | 'missed' | 'manual'): VNavConstraint;
    /**
     * Creates a new vertical flight plan leg.
     * @param segmentIndex The segment index for the leg.
     * @param legIndex The index of the leg within the segment.
     * @param name The name of the leg.
     * @param distance The leg distance.
     * @returns A new VNAV plan leg.
     */
    static createLeg(segmentIndex: number, legIndex: number, name: string, distance?: number): VNavLeg;
}

/**
 * An altitude capture autopilot director.
 */
declare class APAltCapDirector implements PlaneDirector {
    private readonly bus;
    private readonly apValues;
    private readonly captureAltitude;
    state: DirectorState;
    /** A callback called when the director activates. */
    onActivate?: () => void;
    /** A callback called when the director arms. */
    onArm?: () => void;
    private tas;
    private capturedAltitude;
    private indicatedAltitude;
    private verticalSpeed;
    private initialFpa;
    private selectedAltitude;
    private verticalWindAverage;
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues are the ap selected values for the autopilot.
     * @param captureAltitude The captureAltitude Method to use to capture the altitude
     */
    constructor(bus: EventBus, apValues: APValues, captureAltitude?: (targetAltitude: number, indicatedAltitude: number, initialFpa: number) => number);
    /**
     * Activates this director.
     */
    activate(): void;
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm(): void;
    /**
     * Deactivates this director.
     * @param captured is whether the altitude was captured.
     */
    deactivate(captured?: boolean): void;
    /**
     * Updates this director.
     */
    update(): void;
    /**
     * Attempts to activate altitude capture.
     */
    private tryActivate;
    /**
     * Sets the initial capture FPA from the current vs value when capture is initiated.
     * @param vs target vertical speed.
     */
    private setCaptureFpa;
    /**
     * Gets a desired fpa.
     * @param distance is the distance traveled per minute.
     * @param altitude is the vertical speed per minute.
     * @returns The desired pitch angle.
     */
    private getFpa;
    /**
     * Sets the desired AP pitch angle.
     * @param targetPitch The desired AP pitch angle.
     */
    private setPitch;
    /**
     * Default method to use for capturing a target altitude.
     * @param targetAltitude is the captured targed altitude
     * @param indicatedAltitude is the current indicated altitude
     * @param initialFpa is the FPA when capture was initiatiated
     * @returns The target pitch value to set.
     */
    private static captureAltitude;
}

/**
 * An altitude hold autopilot director.
 */
declare class APAltDirector implements PlaneDirector {
    private readonly bus;
    state: DirectorState;
    /** A callback called when the director activates. */
    onActivate?: () => void;
    /** A callback called when the director arms. */
    onArm?: () => void;
    private tas;
    private capturedAltitude;
    private indicatedAltitude;
    private verticalWindAverage;
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues are the ap selected values for the autopilot.
     */
    constructor(bus: EventBus, apValues: APValues);
    /**
     * Activates this director.
     */
    activate(): void;
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm(): void;
    /**
     * Deactivates this director.
     */
    deactivate(): void;
    /**
     * Updates this director.
     */
    update(): void;
    /**
     * Attempts to activate altitude capture.
     */
    private tryActivate;
    /**
     * Holds a captured altitude.
     * @param targetAltitude is the captured targed altitude
     */
    private holdAltitude;
    /**
     * Gets a desired pitch from the selected vs value.
     * @param vs target vertical speed.
     * @returns The desired pitch angle.
     */
    private getDesiredPitch;
    /**
     * Gets a desired fpa.
     * @param distance is the distance traveled per minute.
     * @param altitude is the vertical speed per minute.
     * @returns The desired pitch angle.
     */
    private getFpa;
    /**
     * Sets the desired AP pitch angle.
     * @param targetPitch The desired AP pitch angle.
     */
    private setPitch;
}

/**
 * A Flight Level Change autopilot director.
 */
declare class APFLCDirector implements PlaneDirector {
    private readonly bus;
    private pitchClamp;
    state: DirectorState;
    /** A callback called when the director activates. */
    onActivate?: () => void;
    /** A callback called when the director arms. */
    onArm?: () => void;
    private _lastTime;
    private currentIas;
    private selectedIas;
    private selectedMach;
    private isSelectedSpeedInMach;
    private selectedAltitude;
    private currentAltitude;
    private currentPitch;
    private accelerationController;
    private pitchController;
    private filter;
    /**
     * Creates an instance of the FLC Director.
     * @param bus The event bus to use with this instance.
     * @param apValues is the AP selected values subject.
     * @param pitchClamp is the maximum pitch angle, in degrees, to clamp FLC at.
     */
    constructor(bus: EventBus, apValues: APValues, pitchClamp?: number);
    /**
     * Activates this director.
     */
    activate(): void;
    /**
     * Arms this director.
     * This director can be armed, but it will never automatically activate and remain in the armed state.
     */
    arm(): void;
    /**
     * Deactivates this director.
     */
    deactivate(): void;
    /**
     * Updates this director.
     */
    update(): void;
    /**
     * Initializes this director on activation.
     */
    private initialize;
    /**
     * Gets a desired pitch from the selected vs value.
     * @returns The desired pitch angle.
     */
    private getDesiredPitch;
    /**
     * Sets the desired AP pitch angle.
     * @param targetPitch The desired AP pitch angle.
     */
    private setPitch;
}

/**
 * An RNAV LPV glidepath autopilot director.
 */
declare class APGPDirector implements PlaneDirector {
    private readonly bus;
    private readonly apValues;
    state: DirectorState;
    /** A callback called when the director activates. */
    onActivate?: () => void;
    /** A callback called when the director arms. */
    onArm?: () => void;
    private gpDeviation;
    private fpa;
    private verticalWindAverage;
    private tas;
    private groundSpeed;
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues are the ap selected values for the autopilot.
     */
    constructor(bus: EventBus, apValues: APValues);
    /**
     * Activates this director.
     */
    activate(): void;
    /**
     * Arms this director.
     */
    arm(): void;
    /**
     * Deactivates this director.
     */
    deactivate(): void;
    /**
     * Updates this director.
     */
    update(): void;
    /**
     * Gets a desired pitch from the selected vs value.
     * @returns The desired pitch angle.
     */
    private getDesiredPitch;
    /**
     * Sets the desired AP pitch angle.
     * @param targetPitch The desired AP pitch angle.
     */
    private setPitch;
}

/**
 * A glideslope autopilot director.
 */
declare class APGSDirector implements PlaneDirector {
    private readonly bus;
    private readonly apValues;
    state: DirectorState;
    /** A callback called when the director activates. */
    onActivate?: () => void;
    /** A callback called when the director arms. */
    onArm?: () => void;
    private geoPointCache;
    private ppos;
    private gsLocation;
    private glideslope?;
    private verticalWindAverage;
    private tas;
    private groundSpeed;
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues is the APValues object from the Autopilot.
     */
    constructor(bus: EventBus, apValues: APValues);
    /**
     * Activates this director.
     */
    activate(): void;
    /**
     * Arms this director.
     */
    arm(): void;
    /**
     * Deactivates this director.
     */
    deactivate(): void;
    /**
     * Updates this director.
     */
    update(): void;
    /**
     * Method to check whether the director can arm.
     * @returns Whether or not this director can arm.
     */
    private canArm;
    /**
     * Tracks the Glideslope.
     */
    private trackGlideslope;
}

/**
 * A heading autopilot director.
 */
declare class APHdgDirector implements PlaneDirector {
    private readonly bus;
    private readonly apValues;
    state: DirectorState;
    /** A callback called when the director activates. */
    onActivate?: () => void;
    /** A callback called when the director arms. */
    onArm?: () => void;
    private currentBankRef;
    private currentHeading;
    private readonly bankServo;
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues The AP Values from the Autopilot.
     */
    constructor(bus: EventBus, apValues: APValues);
    /**
     * Activates this director.
     */
    activate(): void;
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm(): void;
    /**
     * Deactivates this director.
     */
    deactivate(): Promise<void>;
    /**
     * Updates this director.
     */
    update(): void;
    /**
     * Gets a desired bank from a Target Selected Heading.
     * @param targetHeading The target heading.
     * @returns The desired bank angle.
     */
    private desiredBank;
    /**
     * Sets the desired AP bank angle.
     * @param bankAngle The desired AP bank angle.
     */
    private setBank;
}

/**
 * Calculates an intercept angle, in degrees, to capture the desired track from a navigation signal for
 * {@link APNavDirector}.
 * @param distanceToSource The distance from the plane to the source of the navigation signal, in nautical miles.
 * @param deflection The lateral deflection of the desired track relative to the plane, normalized from `-1` to `1`.
 * Negative values indicate that the desired track is to the left of the plane.
 * @param tas The true airspeed of the plane, in knots.
 * @param isLoc Whether the source of the navigation signal is a localizer. Defaults to `false`.
 * @returns The intercept angle, in degrees, to capture the desired track from the navigation signal.
 */
declare type APNavDirectorInterceptFunc = (distanceToSource: number, deflection: number, tas: number, isLoc?: boolean) => number;
/**
 * A Nav/Loc autopilot director.
 */
declare class APNavDirector implements PlaneDirector {
    private readonly bus;
    private readonly apValues;
    private readonly mode;
    private readonly lateralInterceptCurve?;
    state: DirectorState;
    /** A callback called when the director activates. */
    onActivate?: () => void;
    /** A callback called when the director arms. */
    onArm?: () => void;
    /** A callback called when the director deactivates. */
    onDeactivate?: () => void;
    private readonly bankServo;
    private currentBankRef;
    private currentHeading;
    private currentTrack;
    private navSource?;
    private cdi?;
    private obs?;
    private loc?;
    private magVar?;
    private ppos;
    private navLocation;
    private tas;
    private isApproachMode;
    private isNavLock;
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues Is the apValues object.
     * @param mode is the APLateralMode for this instance of the director.
     * @param lateralInterceptCurve The optional curve used to translate DTK and XTK into a track intercept angle.
     */
    constructor(bus: EventBus, apValues: APValues, mode: APLateralModes, lateralInterceptCurve?: APNavDirectorInterceptFunc | undefined);
    /**
     * Activates this director.
     */
    activate(): void;
    /**
     * Arms this director.
     */
    arm(): void;
    /**
     * Deactivates this director.
     */
    deactivate(): void;
    /**
     * Sets the NAV1 Lock state.
     * @param newState The new state of the NAV1 lock.
     */
    setNavLock(newState: boolean): void;
    /**
     * Updates this director.
     */
    update(): void;
    /**
     * Method to check whether the director can arm.
     * @returns Whether or not this director can arm.
     */
    private canArm;
    /**
     * Method to check whether the director can activate.
     * @returns Whether or not this director can activate.
     */
    private canActivate;
    /**
     * Gets a desired bank from the nav input data.
     * @returns The desired bank angle.
     */
    private desiredBank;
    /**
     * Gets a xtk value from the nav input data.
     * @param deviation is the input deviation value
     * @param isLoc is whether this is a LOC signal.
     * @returns The xtk value.
     */
    private getXtk;
    /**
     * Gets the lateral distance from PPOS to the nav signal.
     * @returns The distance value in nautical miles.
     */
    private getNavDistance;
    /**
     * Sets the desired AP bank angle.
     * @param bankAngle The desired AP bank angle.
     */
    private setBank;
    /**
     * Checks if we might be getting a wild deviation because of the zone of confusion and allows APNavDirector some time to resolve.
     * @returns Whether we might be in the zone of confusion.
     */
    private checkForZoneOfConfusion;
    /**
     * Method to monitor nav events to keep track of NAV related data needed for guidance.
     */
    private monitorEvents;
}

/**
 * An autopilot pitch director.
 */
declare class APPitchDirector implements PlaneDirector {
    private readonly bus;
    private readonly apValues;
    private readonly pitchIncrement;
    private readonly minPitch;
    private readonly maxPitch;
    state: DirectorState;
    private keyInterceptManager?;
    /** A callback called when the director activates. */
    onActivate?: () => void;
    /** A callback called when the director arms. */
    onArm?: () => void;
    private selectedPitch;
    private currentPitch;
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues are the AP Values subjects.
     * @param pitchIncrement is the pitch increment, in degrees, to use when the user presses the pitch inc/dec keys (default: 0.5)
     * @param minPitch is the negative minimum pitch angle, in degrees, to clamp the pitch to. (default: -15)
     * @param maxPitch is the positive maximum pitch angle, in degrees, to clamp the pitch to. (default: 20)
     */
    constructor(bus: EventBus, apValues: APValues, pitchIncrement?: number, minPitch?: number, maxPitch?: number);
    /**
     * Activates this director.
     */
    activate(): void;
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm(): void;
    /**
     * Deactivates this director.
     */
    deactivate(): void;
    /**
     * Responds to key intercepted events.
     * @param k the key event data
     */
    private onKeyIntercepted;
    /**
     * Updates this director.
     */
    update(): void;
    /**
     * Sets the desired AP pitch angle.
     * @param targetPitch The desired AP pitch angle.
     */
    private setPitch;
}

/**
 * Options for control of the roll director.
 */
interface RollDirectorOptions {
    /** The minimum bank angle under which the roll director will go to wings level. */
    minimumBankAngle: number;
    /** The maximum bank angle that the roll director will not exceed. */
    maximumBankAngle: number;
}
/**
 * An autopilot roll director.
 */
declare class APRollDirector implements PlaneDirector {
    private readonly bus;
    private readonly apValues;
    private readonly options?;
    state: DirectorState;
    /** A callback called when the LNAV director activates. */
    onActivate?: () => void;
    /** A callback called when the LNAV director arms. */
    onArm?: () => void;
    private currentBankRef;
    private desiredBank;
    private actualBank;
    private readonly bankServo;
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues The AP Values.
     * @param options Options to set on the roll director for bank angle limitations.
     */
    constructor(bus: EventBus, apValues: APValues, options?: RollDirectorOptions | undefined);
    /**
     * Activates this director.
     */
    activate(): void;
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm(): void;
    /**
     * Deactivates this director.
     */
    deactivate(): void;
    /**
     * Updates this director.
     */
    update(): void;
    /**
     * Sets the desired AP bank angle.
     * @param bankAngle The desired AP bank angle.
     */
    private setBank;
}

/**
 * A vertical speed autopilot director.
 */
declare class APVSDirector implements PlaneDirector {
    private readonly bus;
    state: DirectorState;
    /** A callback called when the director activates. */
    onActivate?: () => void;
    /** A callback called when the director arms. */
    onArm?: () => void;
    private tas;
    private selectedVS;
    private verticalWindAverage;
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues are the ap selected values for the autopilot.
     */
    constructor(bus: EventBus, apValues: APValues);
    /**
     * Activates this director.
     */
    activate(): void;
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm(): void;
    /**
     * Deactivates this director.
     */
    deactivate(): void;
    /**
     * Updates this director.
     */
    update(): void;
    /**
     * Gets a desired pitch from the selected vs value.
     * @returns The desired pitch angle.
     */
    private getDesiredPitch;
    /**
     * Gets a desired fpa.
     * @param distance is the distance traveled per minute.
     * @param altitude is the vertical speed per minute.
     * @returns The desired pitch angle.
     */
    private getFpa;
    /**
     * Sets the desired AP pitch angle.
     * @param targetPitch The desired AP pitch angle.
     */
    private setPitch;
}

/**
 * LNAV transition modes.
 */
declare enum LNavTransitionMode {
    /** LNAV is attempting to track a non-transition vector. */
    None = 0,
    /** LNAV is attempting to track an ingress vector. */
    Ingress = 1,
    /** LNAV is attempting to track an egress vector. */
    Egress = 2
}
/**
 * Sim var names for LNAV data.
 */
declare enum LNavVars {
    /** The current desired track, in degrees true. */
    DTK = "L:WTAP_LNav_DTK",
    /**
     * The current crosstrack error. Negative values indicate deviation to the left, as viewed when facing in the
     * direction of the track. Positive values indicate deviation to the right.
     */
    XTK = "L:WTAP_LNav_XTK",
    /** Whether LNAV is tracking a path. */
    IsTracking = "L:WTAP_LNav_Is_Tracking",
    /** The global leg index of the flight plan leg LNAV is currently tracking. */
    TrackedLegIndex = "L:WTAP_LNav_Tracked_Leg_Index",
    /** The currently active LNAV transition mode. */
    TransitionMode = "L:WTAP_LNav_Transition_Mode",
    /** The index of the vector LNAV is currently tracking. */
    TrackedVectorIndex = "L:WTAP_LNav_Tracked_Vector_Index",
    /** The current course LNAV is attempting to steer, in degrees true. */
    CourseToSteer = "L:WTAP_LNav_Course_To_Steer",
    /** Whether LNAV sequencing is suspended. */
    IsSuspended = "L:WTAP_LNav_Is_Suspended",
    /**
     * The along-track distance from the start of the currently tracked leg to the plane's present position. A negative
     * distance indicates the plane is before the start of the leg.
     */
    LegDistanceAlong = "L:WTAP_LNav_Leg_Distance_Along",
    /**
     * The along-track distance remaining in the currently tracked leg. A negative distance indicates the plane is past
     * the end of the leg.
     */
    LegDistanceRemaining = "L:WTAP_LNav_Leg_Distance_Remaining",
    /**
     * The along-track distance from the start of the currently tracked vector to the plane's present position. A
     * negative distance indicates the plane is before the start of the vector.
     */
    VectorDistanceAlong = "L:WTAP_LNav_Vector_Distance_Along",
    /**
     * The along-track distance remaining in the currently tracked vector. A negative distance indicates the plane is
     * past the end of the vector.
     */
    VectorDistanceRemaining = "L:WTAP_LNav_Vector_Distance_Remaining",
    /**
     * The along-track distance from the current vector end where LNAV will sequence to the next vector.
     * A positive value means the vector will be sequenced this distance prior to the vector end.
     */
    VectorAnticipationDistance = "L:WTAP_LNav_Vector_Anticipation_Distance"
}
/**
 * Events derived from LNAV sim vars.
 */
interface LNavSimVarEvents {
    /** The current desired track, in degrees true. */
    lnav_dtk: number;
    /**
     * The current crosstrack error, in nautical miles. Negative values indicate deviation to the left, as viewed when
     * facing in the direction of the track. Positive values indicate deviation to the right.
     */
    lnav_xtk: number;
    /** Whether LNAV is tracking a path. */
    lnav_is_tracking: boolean;
    /** The global leg index of the flight plan leg LNAV is currently tracking. */
    lnav_tracked_leg_index: number;
    /** The currently active LNAV transition mode. */
    lnav_transition_mode: LNavTransitionMode;
    /** The index of the vector LNAV is currently tracking. */
    lnav_tracked_vector_index: number;
    /** The current course LNAV is attempting to steer, in degrees true. */
    lnav_course_to_steer: number;
    /** Whether LNAV sequencing is suspended. */
    lnav_is_suspended: boolean;
    /**
     * The along-track distance from the start of the currently tracked leg to the plane's present position, in nautical
     * miles. A negative distance indicates the plane is before the start of the leg.
     */
    lnav_leg_distance_along: number;
    /**
     * The along-track distance remaining in the currently tracked leg, in nautical miles. A negative distance indicates
     * the plane is past the end of the leg.
     */
    lnav_leg_distance_remaining: number;
    /**
     * The along-track distance from the start of the currently tracked vector to the plane's present position, in
     * nautical miles. A negative distance indicates the plane is before the start of the vector.
     */
    lnav_vector_distance_along: number;
    /**
     * The along-track distance remaining in the currently tracked vector, in nautical miles. A negative distance
     * indicates the plane is past the end of the vector.
     */
    lnav_vector_distance_remaining: number;
    /**
     * The along-track distance from the current vector end where LNAV will sequence to the next vector in nautical miles.
     * A positive value means the vector will be sequenced this distance prior to the vector end.
     */
    lnav_vector_anticipation_distance: number;
}
/**
 * Events published by LNAV.
 */
declare type LNavEvents = LNavSimVarEvents;
/**
 * A publisher for LNAV sim var events.
 */
declare class LNavSimVarPublisher extends SimVarPublisher<LNavSimVarEvents> {
    private static simvars;
    /**
     * Constructor.
     * @param bus The event bus to which to publish.
     */
    constructor(bus: EventBus);
}

/**
 * Calculates an intercept angle, in degrees, to capture the desired GPS track for {@link LNavDirector}.
 * @param dtk The desired track, in degrees true.
 * @param xtk The cross-track error, in nautical miles. Negative values indicate that the plane is to the left of the
 * desired track.
 * @param tas The true airspeed of the plane, in knots.
 * @returns The intercept angle, in degrees, to capture the desired track from the navigation signal.
 */
declare type LNavDirectorInterceptFunc = (dtk: number, xtk: number, tas: number) => number;
/**
 * A class that handles lateral navigation.
 */
declare class LNavDirector implements PlaneDirector {
    private readonly bus;
    private readonly apValues;
    private readonly flightPlanner;
    private readonly obsDirector?;
    private readonly lateralInterceptCurve?;
    private readonly hasVectorAnticipation?;
    private readonly vec3Cache;
    private readonly geoPointCache;
    private readonly geoCircleCache;
    previousLegIndex: number;
    /** The current active leg index. */
    currentLegIndex: number;
    /** The current flight path vector index. */
    currentVectorIndex: number;
    state: DirectorState;
    /** A callback called when the LNAV director activates. */
    onActivate?: () => void;
    /** A callback called when the LNAV director arms. */
    onArm?: () => void;
    private readonly aircraftState;
    private currentLeg;
    private dtk;
    private xtk;
    private bearingToVectorEnd;
    private courseToSteer;
    private alongVectorDistance;
    private vectorDistanceRemaining;
    private vectorAnticipationDistance;
    private transitionMode;
    private isSuspended;
    private suspendedLegIndex;
    private resetVectorsOnSuspendEnd;
    private inhibitNextSequence;
    private missedApproachActive;
    private currentBankRef;
    private readonly arcController;
    private readonly bankServo;
    private readonly lnavData;
    private isObsDirectorTracking;
    private canArm;
    private trackAtActivation;
    private isInterceptingFromArmedState;
    private awaitCalculateId;
    private isAwaitingCalculate;
    private isNavLock;
    private readonly lnavDataHandler;
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues The AP Values.
     * @param flightPlanner The flight planner to use with this instance.
     * @param obsDirector The OBS Director.
     * @param lateralInterceptCurve The optional curve used to translate DTK and XTK into a track intercept angle.
     * @param hasVectorAnticipation Whether this lnav director supports anticipating the roll by sequencing to the next vector early.
     */
    constructor(bus: EventBus, apValues: APValues, flightPlanner: FlightPlanner, obsDirector?: ObsDirector | undefined, lateralInterceptCurve?: LNavDirectorInterceptFunc | undefined, hasVectorAnticipation?: boolean | undefined);
    /**
     * Resets the current vectors and transition mode.
     */
    private resetVectors;
    /**
     * Activates the LNAV director.
     */
    activate(): void;
    /**
     * Arms the LNAV director.
     */
    arm(): void;
    /**
     * Deactivates the LNAV director.
     */
    deactivate(): void;
    /**
     * Sets the NAV1 Lock state.
     * @param newState The new state of the NAV1 lock.
     */
    setNavLock(newState: boolean): void;
    /**
     * Updates the lateral director.
     */
    update(): void;
    /**
     * Navigates the provided leg flight path.
     * @param calcs The legs calculations that has the provided flight path.
     */
    private navigateFlightPath;
    /**
     * Adjusts the desired bank angle for arc vectors.
     * @param vector The arc vector to adjust for.
     * @param bankAngle The current starting input desired bank angle.
     * @returns The adjusted bank angle.
     */
    private adjustBankAngleForArc;
    /**
     * Sets the desired AP bank angle.
     * @param bankAngle The desired AP bank angle.
     */
    private setBank;
    /**
     * Gets a desired bank from a desired track.
     * @param desiredTrack The desired track.
     * @returns The desired bank angle.
     */
    private desiredBank;
    /**
     * Calculates the tracking from the current leg.
     */
    private calculateTracking;
    /**
     * Applies suspends that apply at the end of a leg.
     */
    private applyEndOfLegSuspends;
    /**
     * Applies suspends that apply at the beginning of a leg.
     */
    private applyStartOfLegSuspends;
    /**
     * Advances the current flight path vector along the flight path.
     * @param leg The definition of the leg being flown.
     */
    private advanceVector;
    /**
     * Advances the current flight plan leg to the next leg.
     * @param leg The current leg being flown.
     * @returns Whether the leg was advanced.
     */
    private advanceEgressToIngress;
    /**
     * Sets flight plan advance in or out of SUSP.
     * @param isSuspended Whether or not advance is suspended.
     * @param resetVectorsOnSuspendEnd Whether to reset the tracked vector to the beginning of the leg when the applied
     * suspend ends. Ignored if `isSuspended` is false. Defaults to false.
     * @param inhibitResuspend Whether to allow re-suspending a previously suspended leg.
     */
    private trySetSuspended;
    /**
     * Tries to activate when armed.
     */
    private tryActivate;
    /**
     * Awaits a flight plan calculation. Starts a calculation of the active flight plan and suspends all tracking and
     * sequencing until the calculation is finished. If this method is called while a previous execution is still
     * awaiting, the new await takes precedence.
     */
    private awaitCalculate;
    /**
     * Gets the along-track distance from the start of the currently tracked flight plan leg to the airplane's present
     * position, in nautical miles.
     * @param leg The currently tracked flight plan leg.
     * @param vectorIndex The index of the currently tracked vector.
     * @param alongVectorDistance The along-track distance from the start of the currently tracked vector to the
     * airplane's present position, in nautical miles.
     * @returns The along-track distance from the start of the currently tracked flight plan leg to the airplane's
     * present position, in nautical miles.
     */
    private getAlongLegDistance;
    /**
     * Gets the along-track distance from the airplane's present position to the end of the currently tracked flight plan
     * leg, in nautical miles.
     * @param leg The currently tracked flight plan leg.
     * @param vectorIndex The index of the currently tracked vector.
     * @param vectorDistanceRemaining The along-track distance from the airplane's present position to the end of the
     * currently tracked vector, in nautical miles.
     * @returns The along-track distance from the airplane's present position to the end of the currently tracked flight
     * plan leg, in nautical miles.
     */
    private getLegDistanceRemaining;
    /**
     * Gets the flight path vectors to navigate for a leg and a given transition mode.
     * @param calc The calculations for a flight plan leg.
     * @param mode A transition mode.
     * @param isSuspended Whether sequencing is suspended.
     * @returns The flight path vectors to navigate for the given leg and transition mode.
     */
    static getVectorsForTransitionMode(calc: LegCalculations, mode: LNavTransitionMode, isSuspended: boolean): FlightPathVector[];
}

/**
 * A BackCourse autopilot director.
 */
declare class APBackCourseDirector implements PlaneDirector {
    private readonly bus;
    private readonly apValues;
    private readonly mode;
    private readonly lateralInterceptCurve?;
    state: DirectorState;
    /** A callback called when the director activates. */
    onActivate?: () => void;
    /** A callback called when the director arms. */
    onArm?: () => void;
    /** A callback called when the director deactivates. */
    onDeactivate?: () => void;
    private readonly bankServo;
    private currentBankRef;
    private currentHeading;
    private currentTrack;
    private navSource?;
    private cdi?;
    private loc?;
    private magVar?;
    private ppos;
    private navLocation;
    private tas;
    private isApproachMode;
    /**
     * Creates an instance of the BC LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues Is the apValues object.
     * @param mode is the APLateralMode for this instance of the director.
     * @param lateralInterceptCurve The optional curve used to translate DTK and XTK into a track intercept angle.
     */
    constructor(bus: EventBus, apValues: APValues, mode: APLateralModes, lateralInterceptCurve?: APNavDirectorInterceptFunc | undefined);
    /**
     * Activates this director.
     */
    activate(): void;
    /**
     * Arms this director.
     */
    arm(): void;
    /**
     * Deactivates this director.
     */
    deactivate(): void;
    /**
     * Updates this director.
     */
    update(): void;
    /**
     * Method to check whether the director can arm.
     * @returns Whether or not this director can arm.
     */
    private canArm;
    /**
     * Method to check whether the director can activate.
     * @returns Whether or not this director can activate.
     */
    private canActivate;
    /**
     * Gets a desired bank from the nav input data.
     * @returns The desired bank angle.
     */
    private desiredBank;
    /**
     * Gets a xtk value from the nav input data.
     * @param deviation is the input deviation value
     * @param isLoc is whether this is a LOC signal.
     * @returns The xtk value.
     */
    private getXtk;
    /**
     * Gets the lateral distance from PPOS to the nav signal.
     * @returns The distance value in nautical miles.
     */
    private getNavDistance;
    /**
     * Sets the desired AP bank angle.
     * @param bankAngle The desired AP bank angle.
     */
    private setBank;
    /**
     * Checks if we might be getting a wild deviation because of the zone of confusion and allows APNavDirector some time to resolve.
     * @returns Whether we might be in the zone of confusion.
     */
    private checkForZoneOfConfusion;
    /**
     * Method to monitor nav events to keep track of NAV related data needed for guidance.
     */
    private monitorEvents;
}

/**
 * An autopilot wing leveler director.
 */
declare class APLvlDirector implements PlaneDirector {
    private readonly bus;
    state: DirectorState;
    /** A callback called when the wing leveler director activates. */
    onActivate?: () => void;
    /** A callback called when the wing leveler director arms. */
    onArm?: () => void;
    private currentBankRef;
    private desiredBank;
    private actualBank;
    private readonly bankServo;
    /**
     * Creates an instance of the wing leveler.
     * @param bus The event bus to use with this instance.
     */
    constructor(bus: EventBus);
    /**
     * Activates this director.
     */
    activate(): void;
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm(): void;
    /**
     * Deactivates this director.
     */
    deactivate(): void;
    /**
     * Updates this director.
     */
    update(): void;
    /**
     * Sets the desired AP bank angle.
     * @param bankAngle The desired AP bank angle.
     */
    private setBank;
}

/**
 * A VNAV Path autopilot director.
 */
declare class APVNavPathDirector implements PlaneDirector {
    private readonly bus;
    private readonly apValues;
    state: DirectorState;
    /** @inheritdoc */
    onActivate?: () => void;
    /** @inheritdoc */
    onArm?: () => void;
    /** @inheritdoc */
    onDeactivate?: () => void;
    private deviation;
    private fpa;
    private verticalWindAverage;
    private tas;
    private groundSpeed;
    /**
     * Creates an instance of the APVNavPathDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues are the ap selected values for the autopilot.
     */
    constructor(bus: EventBus, apValues: APValues);
    /**
     * Activates this director.
     */
    activate(): void;
    /**
     * Arms this director.
     */
    arm(): void;
    /**
     * Deactivates this director.
     */
    deactivate(): void;
    /**
     * Updates this director.
     */
    update(): void;
    /**
     * Gets a desired pitch from the FPA, AOA and Deviation.
     * @returns The desired pitch angle.
     */
    private getDesiredPitch;
    /**
     * Sets the desired AP pitch angle.
     * @param targetPitch The desired AP pitch angle.
     */
    private setPitch;
}

/**
 * A bank angle controller that maintains a constant radius turn.
 */
declare class ArcTurnController {
    private readonly bankController;
    private readonly precessionController;
    private previousTime;
    private previousRadiusError?;
    private filter;
    /**
     * Gets the bank angle output for a given radius error.
     * @param radiusError The radius error.
     * @returns The bank angle output.
     */
    getOutput(radiusError: number): number;
    /**
     * Resets the controller.
     */
    reset(): void;
}

/**
 * VNav Path Calculator Interface
 */
interface VNavPathCalculator {
    /** The default FPA for this path calculator */
    flightPathAngle: number;
    /** The maximum FPA allowed for path calculator */
    maxFlightPathAngle: number;
    /** Sub Event fired when a path has been calculated, with the planIndex */
    vnavCalculated: ReadonlySubEvent<this, number>;
    /**
     * Gets a vertical flight plan by index, or throws not found if the plan does not exist.
     * @param planIndex The vertical flight plan index.
     * @returns The requested vertical flight plan.
     * @throws Not found if the flight plan index is not valid.
     */
    getVerticalFlightPlan(planIndex: number): VerticalFlightPlan;
    /**
     * Creates an empty vertical plan at a specified index.
     * @param planIndex The Vertical Plan Index to create.
     * @returns The newly created Vertical Plan.
     */
    createVerticalPlan(planIndex: number): VerticalFlightPlan;
    /**
     * Gets the VNAV target altitude for the given leg index.
     * @param planIndex The vertical flight plan index.
     * @param globalLegIndex The global leg index of the leg.
     * @returns The next VNAV target altitude, or undefined if none exists.
     */
    getTargetAltitude(planIndex: number, globalLegIndex: number): number | undefined;
    /**
     * Gets and returns the Current Vertical Flight Phase.
     * @param planIndex The vertical flight plan index.
     * @returns the VerticalFlightPhase.
     */
    getFlightPhase(planIndex: number): VerticalFlightPhase;
    /**
     * Gets and returns the current constraint altitude.
     * @param planIndex The vertical flight plan index.
     * @param globalLegIndex is the global leg index to check.
     * @returns the altitude or undefined.
     */
    getCurrentConstraintAltitude(planIndex: number, globalLegIndex: number): number | undefined;
    /**
     * Gets and returns the next constraint altitude.
     * @param planIndex The vertical flight plan index.
     * @param globalLegIndex is the global leg index to check.
     * @returns the altitude or undefined.
     */
    getNextConstraintAltitude(planIndex: number, globalLegIndex: number): number | undefined;
    /**
     * Gets the next altitude limit for the current phase of flight. (used to calculate the required VS and is not always the next constraint)
     * In descent, this will return the next above altitude in the vertical plan.
     * In climb, this will return the next below altitude in the vertical plan.
     * @param planIndex The vertical flight plan index.
     * @param activeLateralLeg The current active lateral leg.
     * @returns The VNavConstraint not to exceed appropriate to the current phase of flight, or undefined if one does not exist.
     */
    getNextRestrictionForFlightPhase(planIndex: number, activeLateralLeg: number): VNavConstraint | undefined;
    /**
     * Gets the first VNAV Constraint Altitude.
     * @param planIndex The vertical flight plan index.
     * @returns The first VNAV constraint altitude in the plan.
     */
    getFirstDescentConstraintAltitude(planIndex: number): number | undefined;
    /**
     * Activates a vertical direct to a constraint index.
     * @param planIndex The vertical flight plan index.
     * @param constraintGlobalLegIndex The global leg index of the constraint to go direct to.
     */
    activateVerticalDirect(planIndex: number, constraintGlobalLegIndex: number): void;
    /**
     * Sets how far along the current leg the aircraft currently is.
     * @param planIndex The vertical flight plan index.
     * @param distance The distance along the leg, in meters.
     */
    setCurrentAlongLegDistance(planIndex: number, distance: number): void;
    /**
     * Request an out-of-cycle path computation for a specified vertical flight plan.
     * @param planIndex The vertical flight plan index.
     * @returns Whether or not the computation was completed successfully.
     */
    requestPathCompute(planIndex: number): boolean;
}

/**
 * Handles the calculation of the VNAV flight path for VNAV Implemetations that use only the bottom altitude of each constraint.
 */
declare class BottomTargetPathCalculator implements VNavPathCalculator {
    private readonly bus;
    private readonly flightPlanner;
    private readonly primaryPlanIndex;
    /** The Vertical Flight Plans managed by this Path Calculator */
    private verticalFlightPlans;
    /** The default or user set FPA for this path calculator */
    flightPathAngle: number;
    /** The maximum FPA allowed for path calculator */
    maxFlightPathAngle: number;
    /** The aircraft's current altitude in meters. */
    private currentAltitude;
    /** Sub Event fired when a path has been calculated, with the planIndex */
    readonly vnavCalculated: ReadonlySubEvent<this, number>;
    private flightPlanIterator;
    /**
     * Creates an instance of the VNavPathCalculator.
     * @param bus The EventBus to use with this instance.
     * @param flightPlanner The flight planner to use with this instance.
     * @param primaryPlanIndex The primary flight plan index to use to calculate a path from.
     * @param defaultFpa The default FPA for this path calculator.
     * @param defaultMaxFpa The default maximum FPA value for this path calculator.
     */
    constructor(bus: EventBus, flightPlanner: FlightPlanner, primaryPlanIndex: number, defaultFpa: number, defaultMaxFpa: number);
    /** @inheritdoc */
    getVerticalFlightPlan(planIndex: number): VerticalFlightPlan;
    /** @inheritdoc */
    createVerticalPlan(planIndex: number): VerticalFlightPlan;
    /** @inheritdoc */
    setCurrentAlongLegDistance(planIndex: number, distance: number): void;
    /** @inheritdoc */
    getTargetAltitude(planIndex: number, globalLegIndex: number): number | undefined;
    /** @inheritdoc */
    getFlightPhase(planIndex: number): VerticalFlightPhase;
    /** @inheritdoc */
    getCurrentConstraintAltitude(planIndex: number, globalLegIndex: number): number | undefined;
    /** @inheritdoc */
    getNextConstraintAltitude(planIndex: number, globalLegIndex: number): number | undefined;
    /**
     * Gets the next altitude limit for the current phase of flight. (used to calculate the required VS and is not always the next constraint)
     * In descent, this will return the next above altitude in the vertical plan.
     * In climb, this will return the next below altitude in the vertical plan.
     * @param activeLateralLeg The current active lateral leg.
     * @returns The VNavConstraint not to exceed appropriate to the current phase of flight, or undefined if one does not exist.
     */
    getNextRestrictionForFlightPhase(activeLateralLeg: number): VNavConstraint | undefined;
    /** @inheritdoc */
    activateVerticalDirect(planIndex: number, constraintGlobalLegIndex: number): void;
    /**
     * Sets an FPA on the current constraint when an event is received from the VNAV Profile Window via the bus.
     * @param fpa The FPA to set the constraint to manually.
     */
    private setFpaHandler;
    /**
     * Sets planChanged to true to flag that a plan change has been received over the bus.
     * @param planIndex The Plan Index that changed.
     * @param legChangeEvent The FlightPlanLegEvent, if any.
     * @param segmentChangeEvent The FlightPlanSegmentEvent, if any.
     */
    private onPlanChanged;
    /**
     * Method fired on a flight plan change event to rebuild the vertical path.
     * @param event The Flight Plan Calculated Event
     */
    private onPlanCalculated;
    /**
     * Resets the VNAV plan segments, legs, and constraints based on the new plan.
     * @param lateralPlan The Lateral Flight Plan.
     * @param verticalPlan The Vertical Flight Plan.
     * @param verticalDirectIndex The vertical direct index, if any
     */
    private buildVerticalPath;
    /**
     * Computes the VNAV descent path.
     * @param verticalPlan The Vertical Flight Plan
     * @param lateralPlan The Lateral Flight Plan
     */
    private computeVnavPath;
    /**
     * Fills the VNAV plan leg and constraint segment distances.
     * @param verticalPlan The Vertical Flight Plan
     * @param lateralPlan The Lateral Flight Plan
     */
    private fillLegAndConstraintDistances;
    /**
     * Computes the flight path angles for each constraint segment.
     * @param verticalPlan The Vertical Flight Plan.
     * @returns Whether the flight path angles were computed.
     */
    private computeFlightPathAngles;
    /** @inheritdoc */
    getFirstDescentConstraintAltitude(planIndex: number): number | undefined;
    /**
     * Gets the constraint for a leg altitude restriction.
     * @param leg The leg to get the constraint for.
     * @returns The altitude constraint.
     */
    private getConstraintAltitude;
    /**
     * Finds previously invalidated constraints and checks if they're now valid and, if so, reinserts them into the vertical plan.
     * @param verticalPlan The Vertical Flight Plan.
     * @param lateralPlan The Lateral Flight Plan.
     * @returns Whether the invalid constrant is now valid.
     */
    private checkInvalidConstrantsAndReinsertIfValid;
    /**
     * Checks whether a leg constriant is a descent constraint and is higher than the prior descent leg constraint.
     * @param previousConstrant The previous VNav Constraint.
     * @param currentConstraint The current VNav Constraint.
     * @returns Whether the current constraint is higher than the previous constraint.
     */
    private static isConstraintHigherThanPriorConstraint;
    /**
     * Checks whether a leg constraint requires an FPA greater than the max allowed value.
     * @param previousConstrant The previous VNavConstraint.
     * @param currentConstraint The VNavConstraint being evaluated.
     * @param verticalPlan The vertical flight plan.
     * @param maxFpa The maximum FPA allowed.
     * @returns Whether this constraint requires an invalid FPA.
     */
    private static doesConstraintRequireInvalidFpa;
    /**
     * Creates a new empty constraint.
     * @param index The leg index of the constraint.
     * @param targetAltitude The altitude of the constraint.
     * @param name The name of the leg for the constraint.
     * @param type The type of constraint.
     * @returns A new empty constraint.
     */
    private createConstraint;
    /**
     * Creates a new VNAV plan leg.
     * @param segmentIndex The segment index for the leg.
     * @param legIndex The index of the leg within the segment.
     * @param name The name of the leg.
     * @param distance The leg distance.
     * @returns A new VNAV plan leg.
     */
    private createLeg;
    /**
     * Sends an event when a vertical plan has been updated.
     * @param planIndex The plan index that was updated.
     */
    private notify;
    /** @inheritdoc */
    requestPathCompute(planIndex: number): boolean;
}

/**
 * Handles the calculation of a Glide Path.
 */
declare class GlidePathCalculator {
    private readonly bus;
    private readonly flightPlanner;
    private readonly primaryPlanIndex;
    private mapLegIndex;
    private fafLegIndex;
    private readonly planePos;
    glidepathFpa: number;
    private flightPlanIterator;
    /**
     * Creates an instance of the GlidePathCalculator.
     * @param bus The EventBus to use with this instance.
     * @param flightPlanner The flight planner to use with this instance.
     * @param primaryPlanIndex The primary plan index to use for calculating GlidePath.
     */
    constructor(bus: EventBus, flightPlanner: FlightPlanner, primaryPlanIndex: number);
    private onPlanChanged;
    private onPlanCalculated;
    /**
     * Gets the current Glidepath distance.
     * @param index The current leg index.
     * @param distanceAlongLeg The distance along the leg the aircraft is presently.
     * @returns The current Glidepath distance.
     */
    getGlidepathDistance(index: number, distanceAlongLeg: number): number;
    /**
     * Gets the Glidepath desired altitude.
     * @param distance The current Glidepath distance.
     * @returns The current Glidepath desired altitude.
     */
    getDesiredGlidepathAltitude(distance: number): number;
    /**
     * Gets the Glidepath runway altitude.
     * @returns The Glidepath runway altitude.
     */
    getRunwayAltitude(): number;
    /**
     * Calculates the Glidepath flight path angle using the destination elevation
     * and FAF altitude restriction.
     * @param plan The plan to calculate from.
     */
    private calcGlidepathFpa;
}

/**
 * Handles the calculation of the VNAV flight path for Path Smoothing VNAV Implementations.
 */
declare class SmoothingPathCalculator implements VNavPathCalculator {
    private readonly bus;
    private readonly flightPlanner;
    private readonly primaryPlanIndex;
    /** The Vertical Flight Plans managed by this Path Calculator */
    private verticalFlightPlans;
    /** The default FPA for this path calculator */
    flightPathAngle: number;
    /** The maximum FPA allowed for path calculator */
    maxFlightPathAngle: number;
    /** The aircraft's current altitude in meters. */
    private currentAltitude;
    /** Sub Event fired when a path has been calculated, with the planIndex */
    readonly vnavCalculated: ReadonlySubEvent<this, number>;
    /**
     * Creates an instance of the VNavPathCalculator.
     * @param bus The EventBus to use with this instance.
     * @param flightPlanner The flight planner to use with this instance.
     * @param primaryPlanIndex The primary flight plan index to use to calculate a path from.
     * @param defaultFpa The default FPA for this path calculator.
     * @param defaultMaxFpa The default maximum FPA value for this path calculator.
     */
    constructor(bus: EventBus, flightPlanner: FlightPlanner, primaryPlanIndex: number, defaultFpa?: number, defaultMaxFpa?: number);
    /** @inheritdoc */
    getVerticalFlightPlan(planIndex: number): VerticalFlightPlan;
    /** @inheritdoc */
    createVerticalPlan(planIndex: number): VerticalFlightPlan;
    /** @inheritdoc */
    requestPathCompute(planIndex: number): boolean;
    /** @inheritdoc */
    setCurrentAlongLegDistance(planIndex: number, distance: number): void;
    /** @inheritdoc */
    getTargetAltitude(planIndex: number, globalLegIndex: number): number | undefined;
    /** @inheritdoc */
    getFlightPhase(planIndex: number): VerticalFlightPhase;
    /** @inheritdoc */
    getCurrentConstraintAltitude(planIndex: number, globalLegIndex: number): number | undefined;
    /** @inheritdoc */
    getNextConstraintAltitude(planIndex: number, globalLegIndex: number): number | undefined;
    /** @inheritdoc */
    getNextRestrictionForFlightPhase(planIndex: number, activeLateralLeg: number): VNavConstraint | undefined;
    /** @inheritdoc */
    activateVerticalDirect(planIndex: number, constraintGlobalLegIndex: number): void;
    /**
     * Sets an FPA on the current constraint when an event is received from the VNAV Profile Window via the bus.
     * @param fpa The FPA to set the constraint to manually.
     */
    private setFpaHandler;
    /**
     * Sets planChanged to true to flag that a plan change has been received over the bus.
     * @param planIndex The Plan Index that changed.
     * @param legChangeEvent The FlightPlanLegEvent, if any.
     * @param segmentChangeEvent The FlightPlanSegmentEvent, if any.
     */
    private onPlanChanged;
    /**
     * Method fired on a flight plan change event to rebuild the vertical path.
     * @param event The Flight Plan Calculated Event
     */
    private onPlanCalculated;
    /**
     * Resets the Vertical Flight Plan, populates the vertical segments and legs, finds and builds the vertical constraints.
     * @param lateralPlan The Lateral Flight Plan.
     * @param verticalPlan The Vertical Flight Plan.
     * @param verticalDirectIndex The vertical direct index, if any.
     */
    private buildVerticalLegsAndConstraints;
    /**
     * Builds the Vertical Flight Plan from the Lateral Flight Plan, setting the segments, legs, and constraints.
     * @param lateralPlan The Lateral Flight Plan.
     * @param verticalPlan The Vertical Flight Plan.
     * @param verticalDirectIndex The vertical direct index, if any.
     */
    private buildVerticalFlightPlan;
    /**
     * Computes the VNAV descent path.
     * @param lateralPlan The lateral Flight Plan
     * @param verticalPlan The Vertical Flight Plan
     * @returns True if the method completed successfully
     */
    private computeVnavPath;
    /**
     * Finds and removes invalid constrants from the vertical plan.
     * @param verticalPlan The Vertical Flight Plan.
     */
    private findAndRemoveInvalidConstraints;
    /**
     * Finds previously invalidated constraints and checks if they're now valid and, if so, reinserts them into the vertical plan.
     * @param verticalPlan The Vertical Flight Plan.
     * @param lateralPlan The Lateral Flight Plan.
     */
    private checkInvalidConstrantsAndReinsertIfValid;
    /**
     * Computes the flight path angles for each constraint segment.
     * @param verticalPlan The Vertical Flight Plan.
     * @param lateralPlan The Lateral Flight Plan.
     * @returns Whether the flight path angles were computed.
     */
    private computeFlightPathAngles;
    /**
     * Manages direct constraint types for this calculator, including when in the Mod or Active flight plans.
     * @param targetConstraint The target constraint to process.
     * @param currentPathSegmentMinFpa The current path segment min fpa value.
     * @param currentPathSegmentMaxFpa The current path segment max fpa value.
     * @param verticalPlan The vertical flight plan.
     * @param lateralPlan The lateral flight plan.
     * @returns The index or undefined.
     */
    private handleDirectToTargetConstraint;
    /**
     * Calculates and sets the target constraint FPA.
     * @param targetConstraint The target constraint to process.
     * @param legMinFpa The minimum FPA value for the current constraint leg.
     * @param legMaxFpa The maximum FPA value for the current constraint leg.
     * @param currentPathSegmentMinFpa The current path segment min fpa value.
     * @param currentPathSegmentMaxFpa The current path segment max fpa value.
     * @param currentConstraintIsFirstDescentConstraint The vertical flight plan.
     * @param currentConstraintIsFaf The lateral flight plan.
     * @returns The index or undefined.
     */
    private calculateAndSetTargetConstraintFpa;
    /** @inheritdoc */
    getFirstDescentConstraintAltitude(planIndex: number): number | undefined;
    /**
     * Sends an event when a vertical plan has been updated.
     * @param planIndex The plan index that was updated.
     */
    private notify;
    /**
     * Gets the constraint altitudes for a leg.
     * @param leg The leg to get the constraint for.
     * @returns The altitudes object, minimum altitude at index [0], maximum altitude at index [1]
     */
    private static getConstraintAltitudes;
    /**
     * Sets the first approach constraint altitudes based on the vertical plan and the approach start leg index.
     * @param verticalPlan The Vertical Flight Plan.
     * @param approachStartGlobalLegIndex The global leg index of the first approach leg.
     */
    private static setFirstApproachConstraintAltitudes;
    /**
     * Checks whether a leg constraint precedes a direct to or vertical direct to.
     * @param lateralPlan The Lateral Flight Plan.
     * @returns Whether the constraint precedes a vertical direct or direct to.
     */
    private static getDirectToGlobalLegIndex;
    /**
     * Checks whether a lateral leg is a current lateral direct to target.
     * @param lateralPlan The Lateral Flight Plan.
     * @param verticalPlan The Vertical Flight Plan.
     */
    private static setDirectToLegInVerticalPlan;
    /**
     * Checks whether a leg constraint is in a departure segment or is part of the missed approach.
     * @param lateralSegment The lateral FlightPlanSegment.
     * @param lateralLeg The lateral LegDefinition.
     * @returns Whether the leg constraint is in a departure segment or is part of the missed approach.
     */
    private static isConstraintInDepartureOrMissed;
    /**
     * Checks whether a leg constriant is a descent constraint and is higher than the prior descent leg constraint.
     * @param previousConstrant The previous VNav Constraint.
     * @param currentConstraint The current VNav Constraint.
     * @returns Whether the current constraint is higher than the previous constraint.
     */
    private static isConstraintHigherThanPriorConstraint;
    /**
     * Checks whether a leg constraint requires an FPA greater than the max allowed value.
     * @param previousConstrant The previous VNavConstraint.
     * @param currentConstraint The VNavConstraint being evaluated.
     * @param verticalPlan The vertical flight plan.
     * @param maxFpa The maximum FPA allowed.
     * @returns Whether this constraint requires an invalid FPA.
     */
    private static doesConstraintRequireInvalidFpa;
    /**
     * Checks whether a leg is eligible for VNav in this calculator.
     * @param lateralLeg The lateral LegDefinition.
     * @returns Whether the leg is eligible for vertical navigation.
     */
    static isLegVnavEligible(lateralLeg: LegDefinition): boolean;
    /**
     * Fills the VNAV plan leg and constraint segment distances.
     * @param lateralPlan The Lateral Flight Plan.
     * @param verticalPlan The Vertical Flight Plan.
     */
    private static fillLegDistances;
    /**
     * Fills the VNAV plan constraint distances.
     * @param verticalPlan The Vertical Flight Plan.
     */
    private static populateConstraints;
    /**
     * Finds the first descent constraint index.
     * @param verticalPlan The vertical flight plan.
     * @returns The constraint index or undefined.
     */
    private static getFirstDescentConstraintIndex;
    /**
     * Finds the last descent constraint index.
     * @param verticalPlan The vertical flight plan.
     * @returns The constraint index or undefined.
     */
    private static getLastDescentConstraintIndex;
    /**
     * Finds the prior max altitude in the descent path.
     * @param verticalPlan The Vertical Flight Plan.
     * @param currentConstraintIndex The current constraint index.
     * @param firstDescentConstraintIndex The first descent constraint index.
     * @returns The prior max altitude, or positive infinity if none exists.
     */
    private static findPriorMaxAltitude;
    /**
     * Applies path values to constraints in the smoothed path segment.
     * @param verticalPlan The Vertical Flight Plan.
     * @param targetConstraintIndex The target constraint index.
     * @param currentConstraintIndex The current constraint index.
     * @param nextMaxAltitude The calculated max altitude of the prior constraint.
     * @returns The index of the constraint that violated the next max altitude, or undefined.
     */
    private static applyPathValuesToSmoothedConstraints;
}

/**
 * Sim var names for LNAV-related data.
 */
declare enum LNavDataVars {
    /** The current nominal desired track, in degrees true. */
    DTKTrue = "L:WT_LNavData_DTK_True",
    /** The current nominal desired track, in degrees magnetic. */
    DTKMagnetic = "L:WT_LNavData_DTK_Mag",
    /**
     * The current nominal crosstrack error. Negative values indicate deviation to the left, as viewed when facing in the
     * direction of the track. Positive values indicate deviation to the right.
     */
    XTK = "L:WT_LNavData_XTK",
    /** The current CDI scale. */
    CDIScale = "L:WT_LNavData_CDI_Scale",
    /** The nominal bearing to the next waypoint currently tracked by LNAV, in degrees true. */
    WaypointBearingTrue = "L:WT_LNavData_Waypoint_Bearing_True",
    /** The nominal bearing to the next waypoint currently tracked by LNAV, in degrees magnetic. */
    WaypointBearingMagnetic = "L:WT_LNavData_Waypoint_Bearing_Mag",
    /** The nominal distance remaining to the next waypoint currently tracked by LNAV. */
    WaypointDistance = "L:WT_LNavData_Waypoint_Distance",
    /** The nominal distance remaining to the destination. */
    DestinationDistance = "L:WT_LNavData_Destination_Distance"
}
/**
 * Events derived from LNAV-related data sim vars.
 */
interface LNavDataSimVarEvents {
    /** The current nominal desired track, in degrees true. */
    lnavdata_dtk_true: number;
    /** The current nominal desired track, in degrees magnetic. */
    lnavdata_dtk_mag: number;
    /**
     * The current nominal crosstrack error, in nautical miles. Negative values indicate deviation to the left, as viewed
     * when facing in the direction of the track. Positive values indicate deviation to the right.
     */
    lnavdata_xtk: number;
    /** The current CDI scale, in nautical miles. */
    lnavdata_cdi_scale: number;
    /** The nominal bearing to the next waypoint currently tracked by LNAV, in degrees true. */
    lnavdata_waypoint_bearing_true: number;
    /** The nominal earing to the next waypoint tracked by LNAV, in degrees magnetic. */
    lnavdata_waypoint_bearing_mag: number;
    /** The nominal distance remaining to the next waypoint currently tracked by LNAV, in nautical miles. */
    lnavdata_waypoint_distance: number;
    /** The nominal distance remaining to the destination, in nautical miles. */
    lnavdata_destination_distance: number;
}
/**
 * Events related to LNAV data.
 */
declare type LNavDataEvents = LNavDataSimVarEvents;
/**
 * A publisher for LNAV-related data sim var events.
 */
declare class LNavDataSimVarPublisher extends SimVarPublisher<LNavDataSimVarEvents> {
    private static simvars;
    /**
     * Constructor.
     * @param bus The event bus to which to publish.
     */
    constructor(bus: EventBus);
}

/**
 * Events related to VNAV data.
 */
interface VNavDataEvents {
    /** Whether or not an RNAV-based glidepath is available for vertical guidance. */
    gp_available: boolean;
    /** Whether VNAV path details should be displayed. */
    vnav_path_display: boolean;
    /** The active leg vnav calculated target altitude in meters. */
    vnav_active_leg_alt: number;
    /** The full scale deflection of the vertical GSI due to GPS glidepath deviation, in meters. */
    gp_gsi_scaling: number;
}
/** A publisher for VNAV-related data events */
declare class VNavDataEventPublisher extends BasePublisher<VNavDataEvents> {
    /**
     * Create a publisher for VNAV-related data.
     * @param bus The EventBus to publish to.
     */
    constructor(bus: EventBus);
    /**
     * Publish a control event.
     * @param event The event from ControlEvents.
     * @param value The value of the event.
     */
    publishEvent<K extends keyof VNavDataEvents>(event: K, value: VNavDataEvents[K]): void;
}

/**
 * Sim var names for VNAV data.
 */
declare enum VNavVars {
    /** The vertical deviation in feet. */
    VerticalDeviation = "L:WTAP_VNav_Vertical_Deviation",
    /** The VNAV target altitude in feet. */
    TargetAltitude = "L:WTAP_VNav_Target_Altitude",
    /** The VNAV path mode. */
    PathMode = "L:WTAP_VNav_Path_Mode",
    /** The VNAV State. */
    VNAVState = "L:WTAP_VNav_State",
    /** Whether a VNAV Path Exists for the current leg. */
    PathAvailable = "L:WTAP_VNav_Path_Available",
    /** The VNAV current altitude capture type. */
    CaptureType = "L:WTAP_VNav_Alt_Capture_Type",
    /** The distance to the next TOD in meters, or -1 if one does not exist. */
    TODDistance = "L:WTAP_VNav_Distance_To_TOD",
    /** The index of the leg for the next TOD. */
    TODLegIndex = "L:WTAP_VNav_TOD_Leg_Index",
    /** The distance from the end of the TOD leg that the TOD is, in meters. */
    TODDistanceInLeg = "L:WTAP_VNav_TOD_Distance_In_Leg",
    /** The index of the leg for the next BOD. */
    BODLegIndex = "L:WTAP_VNav_BOD_Leg_Index",
    /** The index of the leg for the next constraint. */
    CurrentConstraintLegIndex = "L:WTAP_VNav_Constraint_Leg_Index",
    /** The current constraint altitude, in feet. */
    CurrentConstraintAltitude = "L:WTAP_VNav_Constraint_Altitude",
    /** The next constraint altitude, in feet. */
    NextConstraintAltitude = "L:WTAP_VNav_Next_Constraint_Altitude",
    /** The distance to the next BOD, or -1 if one does not exist, in meters. */
    BODDistance = "L:WTAP_VNav_Distance_To_BOD",
    /** The current required flight path angle, in degrees. */
    FPA = "L:WTAP_VNav_FPA",
    /** The required VS to the current constraint, in FPM. */
    RequiredVS = "L:WTAP_VNAV_Required_VS",
    /** The VNAV approach guidance mode. */
    GPApproachMode = "L:WTAP_GP_Approach_Mode",
    /** The current LPV vertical deviation in feet. */
    GPVerticalDeviation = "L:WTAP_GP_Vertical_Deviation",
    /** The current remaining LPV distance in meters. */
    GPDistance = "L:WTAP_GP_Distance",
    /** The current LPV FPA, in degrees. */
    GPFpa = "L:WTAP_GP_FPA",
    /** The required VS to the current constraint, in FPM. */
    GPRequiredVS = "L:WTAP_GP_Required_VS"
}
/**
 * Events derived from VNAV sim vars.
 */
interface VNavSimVarEvents {
    /** The vertical deviation, in feet, of the airplane from the calculated VNAV path. */
    vnav_vertical_deviation: number;
    /** The target altitude, in feet, of the currently active VNAV constraint. */
    vnav_target_altitude: number;
    /** The VNAV path mode. */
    vnav_path_mode: VNavPathMode;
    /** Whether a VNAV Path Exists for the current leg. */
    vnav_path_available: boolean;
    /** The VNAV state. */
    vnav_state: VNavState;
    /** The VNAV current alt capture type. */
    vnav_altitude_capture_type: VNavAltCaptureType;
    /** The distance along the flight path from the airplane's present position to the current VNAV TOD, in meters. */
    vnav_tod_distance: number;
    /** The distance from the current VNAV TOD to the end of its containing leg, in meters. */
    vnav_tod_leg_distance: number;
    /** The distance along the flight path from the airplane's present position to the next VNAV BOD, in meters. */
    vnav_bod_distance: number;
    /**
     * The global index of the flight plan leg that contains the TOD associated with the next VNAV BOD, or -1 if there is
     * no such TOD. The TOD is defined as the point along the flight path at which the aircraft will intercept the VNAV
     * profile continuing to the next BOD if it continues to fly level at its current altitude.
     */
    vnav_tod_global_leg_index: number;
    /**
     * The global index of the flight plan leg that contains the next VNAV BOD, or -1 if there is no BOD. The next BOD
     * is defined as the next point in the flight path including or after the active leg where the VNAV profile
     * transitions from a descent to a level-off, discontinuity, or the end of the flight path.
     */
    vnav_bod_global_leg_index: number;
    /** The global index of the leg that contains the current VNAV constraint. */
    vnav_constraint_global_leg_index: number;
    /** The VNAV current constraint altitude in feet. */
    vnav_constraint_altitude: number;
    /** The VNAV next constraint altitude in feet. */
    vnav_next_constraint_altitude: number;
    /**
     * The flight path angle, in degrees, for the currently active VNAV path segment. Positive angles represent
     * descending paths.
     */
    vnav_fpa: number;
    /**
     * The vertical speed, in feet per minute, required for the airplane to meet the next VNAV altitude constraint if it
     * starts climbing/descending from its current altitude immediately.
     */
    vnav_required_vs: number;
    /** The VNAV approach guidance mode. */
    gp_approach_mode: ApproachGuidanceMode;
    /** The current glidepath vertical deviation. */
    gp_vertical_deviation: number;
    /** The current distance to the glidepath endpoint. */
    gp_distance: number;
    /** The current glidepath FPA. */
    gp_fpa: number;
    /** The vertical speed, in feet per minute, required for the airplane to reach the glidepath target. */
    gp_required_vs: number;
}
/**
 * Events published by VNAV.
 */
interface VNavEvents extends VNavSimVarEvents {
    /** VNAV path calculations were updated for the specified vertical flight plan. */
    vnav_path_calculated: number;
    /** The current availability of VNAV from the director. */
    vnav_availability: VNavAvailability;
}
/** A publisher for VNAV sim var events. */
declare class VNavSimVarPublisher extends SimVarPublisher<VNavEvents> {
    private static simvars;
    /**
     * Create a VNavSimVarPublisher
     * @param bus The EventBus to publish to
     */
    constructor(bus: EventBus);
    /**
     * Publish a control event.
     * @param event The event from ControlEvents.
     * @param value The value of the event.
     */
    publishEvent<K extends keyof VNavEvents>(event: K, value: VNavEvents[K]): void;
}

/**
 * VNav Control Events.
 */
interface VNavControlEvents {
    /** Event to set the FPA of the current VNAV path segment. */
    vnav_set_current_fpa: number;
    /** Event to set vnav master state. */
    vnav_set_state: boolean;
}
/** A publisher for VNav Control Events */
declare class VNavControlEventPublisher extends BasePublisher<VNavControlEvents> {
    /**
     * Create a publisher for VNAV-related data.
     * @param bus The EventBus to publish to.
     */
    constructor(bus: EventBus);
    /**
     * Publish a VNav Control event.
     * @param event The event from ControlEvents.
     * @param value The value of the event.
     */
    publishEvent<K extends keyof VNavControlEvents>(event: K, value: VNavControlEvents[K]): void;
}

/** The supported data types for a user setting. */
declare type UserSettingValue = boolean | number | string;
/**
 * A definition for a user setting.
 */
interface UserSettingDefinition<T extends UserSettingValue> {
    /** The name of this setting. */
    readonly name: string;
    /** The default value of this setting. */
    readonly defaultValue: T;
}
/**
 * A user setting.
 */
interface UserSetting<T extends UserSettingValue> extends MutableSubscribable<T> {
    /** This setting's definition. */
    readonly definition: UserSettingDefinition<T>;
    /** This setting's current value. */
    value: T;
    /** Resets this setting to its default value. */
    resetToDefault(): void;
}
/**
 * An entry for a user setting in UserSettingManager.
 */
declare type UserSettingManagerEntry<T extends UserSettingValue> = {
    /** A user setting. */
    setting: SyncableUserSetting<T>;
    /** The event topic used to sync the setting. */
    syncTopic: string;
    /** The timestamp of the most recent sync event. */
    syncTime: number;
};
/**
 * Data provided for a setting sync event.
 */
declare type UserSettingManagerSyncData<T extends UserSettingValue> = {
    /** The synced value of the setting. */
    value: T;
    /** The timestamp of this sync event. */
    syncTime: number;
};
/**
 * A record which maps user setting names to user setting value types.
 */
declare type UserSettingRecord = Record<any, UserSettingValue>;
/**
 * Filters a record of user settings to just those settings whose values extend a certain type.
 */
declare type UserSettingValueFilter<T extends UserSettingRecord, V> = {
    [Property in keyof T as (T[Property] extends V ? Property : never)]: T[Property];
};
/**
 * A user setting type derived from a user setting record. If the provided key does not exist in the record, a type of
 * `undefined` is returned. If the provided key is optional in the record, a union type of `UserSetting<T> | undefined`
 * is returned, where `T` is the value type mapped to the key in the record.
 */
declare type UserSettingFromRecord<R extends UserSettingRecord, K extends string> = K extends keyof R ? R[K] extends NonNullable<R[K]> ? UserSetting<R[K]> : UserSetting<NonNullable<R[K]>> | undefined : undefined;
/**
 * An entry that maps one set of setting definitions to another.
 */
declare type UserSettingMap<Aliased, Original> = {
    [Property in keyof Aliased]?: keyof Original;
};
/**
 * A manager for user settings. Provides settings using their names as keys, publishes value change events on the
 * event bus, and keeps setting values up to date when receiving change events across the bus.
 */
interface UserSettingManager<T extends UserSettingRecord> {
    /**
     * Attempts to get a setting from this manager.
     * @param name The name of the setting to get.
     * @returns The requested setting, or `undefined` if no such setting exists.
     */
    tryGetSetting<K extends string>(name: K): UserSetting<NonNullable<T[K]>> | undefined;
    /**
     * Gets a setting from this manager.
     * @param name The name of the setting to get.
     * @returns The requested setting.
     * @throws Error if no setting with the specified name exists.
     */
    getSetting<K extends keyof T & string>(name: K): UserSetting<NonNullable<T[K]>>;
    /**
     * Gets a consumer which notifies handlers when the value of a setting changes.
     * @param name The name of a setting.
     * @returns a consumer which notifies handlers when the value of the setting changes.
     * @throws Error if no setting with the specified name exists.
     */
    whenSettingChanged<K extends keyof T & string>(name: K): Consumer<NonNullable<T[K]>>;
    /**
     * Gets an array of all settings of this manager.
     * @returns an array of all settings of this manager.
     */
    getAllSettings(): UserSetting<UserSettingValue>[];
    /**
     * Maps a subset of this manager's settings to ones with aliased names, and creates a new setting manager which
     * supports accessing the settings using their aliases.
     * @param map A map defining the aliases of a subset of this manager's settings, with aliased setting names as keys
     * and original setting names as values.
     * @returns A new setting manager which supports accessing a subset of this manager's settings using aliased names.
     */
    mapTo<M extends UserSettingRecord>(map: UserSettingMap<M, T>): UserSettingManager<M & T>;
}
/**
 * A manager for user settings. Provides settings using their names as keys, publishes value change events on the
 * event bus, and keeps setting values up to date when receiving change events across the bus.
 */
declare class DefaultUserSettingManager<T extends UserSettingRecord> implements UserSettingManager<T> {
    protected readonly bus: EventBus;
    private static readonly SYNC_TOPIC_PREFIX;
    protected readonly settings: Map<string, UserSettingManagerEntry<UserSettingValue>>;
    protected readonly publisher: Publisher<any>;
    protected readonly subscriber: EventSubscriber<any>;
    /**
     * Constructor.
     * @param bus The bus used by this manager to publish setting change events.
     * @param settingDefs The setting definitions used to initialize this manager's settings.
     */
    constructor(bus: EventBus, settingDefs: readonly UserSettingDefinition<T[keyof T]>[]);
    /** @inheritdoc */
    tryGetSetting<K extends string>(name: K): UserSetting<NonNullable<T[K]>> | undefined;
    /** @inheritdoc */
    getSetting<K extends keyof T & string>(name: K): UserSetting<NonNullable<T[K]>>;
    /** @inheritdoc */
    getAllSettings(): UserSetting<UserSettingValue>[];
    /** @inheritdoc */
    whenSettingChanged<K extends keyof T & string>(name: K): Consumer<NonNullable<T[K]>>;
    /** @inheritdoc */
    mapTo<M extends UserSettingRecord>(map: UserSettingMap<M, T>): MappedUserSettingManager<M, T>;
    /**
     * A callback which is called when one of this manager's settings has its value changed locally.
     * @param entry The entry for the setting that was changed.
     * @param value The new value of the setting.
     */
    protected onSettingValueChanged<K extends keyof T>(entry: UserSettingManagerEntry<T[K]>, value: T[K]): void;
    /**
     * A callback which is called when a setting changed event is received over the event bus.
     * @param entry The entry for the setting that was changed.
     * @param data The sync data.
     */
    protected onSettingValueSynced<K extends keyof T>(entry: UserSettingManagerEntry<T[K]>, data: UserSettingManagerSyncData<T[K]>): void;
}
/**
 * A manager for user settings. Provides settings using their names as keys, publishes value change events on the
 * event bus, and keeps setting values up to date when receiving change events across the bus, using a mapping from
 * abstracted settings keys to true underlying settings keys.
 */
declare class MappedUserSettingManager<T extends UserSettingRecord, O extends UserSettingRecord> implements UserSettingManager<T & O> {
    private readonly parent;
    private readonly map;
    /**
     * Creates an instance of a MappedUserSettingManager.
     * @param parent The parent setting manager.
     * @param map The map of abstracted keys to true underlying keys.
     */
    constructor(parent: UserSettingManager<O>, map: UserSettingMap<T, O>);
    /** @inheritdoc */
    tryGetSetting<K extends string>(name: K): UserSetting<NonNullable<(T & O)[K]>> | undefined;
    /** @inheritdoc */
    getSetting<K extends keyof T & string>(name: K): UserSetting<NonNullable<(T & O)[K]>>;
    /** @inheritdoc */
    whenSettingChanged<K extends keyof T & string>(name: K): Consumer<NonNullable<(T & O)[K]>>;
    /** @inheritdoc */
    getAllSettings(): UserSetting<UserSettingValue>[];
    /** @inheritdoc */
    mapTo<M extends UserSettingRecord>(map: UserSettingMap<M, T & O>): MappedUserSettingManager<M, T & O>;
}
/**
 * An implementation of a user setting which can be synced across multiple instances.
 */
declare class SyncableUserSetting<T extends UserSettingValue> extends AbstractSubscribable<T> implements UserSetting<T> {
    readonly definition: UserSettingDefinition<T>;
    private readonly valueChangedCallback;
    readonly isMutableSubscribable = true;
    private _value;
    /** This setting's current value. */
    get value(): T;
    set value(v: T);
    /**
     * Constructor.
     * @param definition This setting's definition.
     * @param valueChangedCallback A function to be called whenever the value of this setting changes.
     */
    constructor(definition: UserSettingDefinition<T>, valueChangedCallback: (value: T) => void);
    /**
     * Syncs this setting to a value. This will not trigger a call to valueChangedCallback.
     * @param value The value to which to sync.
     */
    syncValue(value: T): void;
    /** @inheritdoc */
    get(): T;
    /**
     * Sets the value of this setting.
     * @param value The new value.
     */
    set(value: T): void;
    /** @inheritdoc */
    resetToDefault(): void;
}

/**
 * An aliased user setting manager which can dynamically (re)define the settings from which its aliased settings are
 * sourced.
 */
declare class AliasedUserSettingManager<T extends UserSettingRecord> implements UserSettingManager<T> {
    private readonly bus;
    private readonly aliasedSettings;
    private manager?;
    /**
     * Constructor.
     * @param bus The bus used by this manager to publish setting change events.
     * @param settingDefs The setting definitions used to initialize this manager's settings. The definitions should
     * define the settings' aliased names.
     */
    constructor(bus: EventBus, settingDefs: readonly UserSettingDefinition<T[keyof T & string]>[]);
    /**
     * Defines the mappings from this manager's aliased settings to their source settings. Once the mappings are defined,
     * each aliased setting will take the value of its source setting, and setting the value of the aliased setting will
     * also set the value of the source setting. If a source setting cannot be defined for an aliased setting, the
     * aliased setting's value will be fixed to its default value and cannot be changed.
     * @param masterManager The manager hosting the settings from which this manager's aliased settings will be sourced.
     * @param map The mappings for this manager's aliased settings, as a set of key-value pairs where the keys are the
     * aliased setting names and the values are the source setting names. For any aliased setting whose name does not
     * appear as a key in the mapping, its source setting is assumed to have the same name.
     */
    useAliases<O extends UserSettingRecord>(masterManager: UserSettingManager<O>, map: UserSettingMap<T, O>): void;
    /** @inheritdoc */
    tryGetSetting<K extends string>(name: K): UserSetting<NonNullable<T[K]>> | undefined;
    /** @inheritdoc */
    getSetting<K extends keyof T & string>(name: K): UserSetting<NonNullable<T[K]>>;
    /** @inheritdoc */
    whenSettingChanged<K extends keyof T & string>(name: K): Consumer<NonNullable<T[K]>>;
    /** @inheritdoc */
    getAllSettings(): UserSetting<UserSettingValue>[];
    /** @inheritdoc */
    mapTo<M extends Record<any, UserSettingValue>>(map: UserSettingMap<M, T>): UserSettingManager<M & T>;
}

/**
 * A manager for user settings that are saved and persistent across flight sessions. The manager facilitates saving
 * and loading setting values to and from multiple keyed save slots and also supports auto-saving. Uses Data Store to
 * store saved setting values.
 */
declare class UserSettingSaveManager {
    private static readonly DATASTORE_PREFIX;
    private readonly entries;
    private readonly autoSaveKeys;
    private isAlive;
    /**
     * Constructor.
     * @param settings This manager's managed settings.
     * @param bus The event bus.
     */
    constructor(settings: UserSetting<UserSettingValue>[], bus: EventBus);
    /**
     * A callback which is called when a setting's value changes.
     * @param autoSaveDataStoreKeys The data store keys to which the setting's value should be automatically saved.
     * @param value The new value of the setting.
     */
    private onSettingChanged;
    /**
     * Loads the saved values of this manager's settings.
     * @param key The key from which to load the values.
     * @throws Error if this manager has been destroyed.
     */
    load(key: string): void;
    /**
     * Saves the current values of this manager's settings.
     * @param key The key to which to save the values.
     * @throws Error if this manager has been destroyed.
     */
    save(key: string): void;
    /**
     * Starts automatically saving this manager's settings when their values change.
     * @param key The key to which to save the values.
     * @throws Error if this manager has been destroyed.
     */
    startAutoSave(key: string): void;
    /**
     * Stops automatically saving this manager's settings when their values change.
     * @param key The key to which to stop saving the values.
     * @throws Error if this manager has been destroyed.
     */
    stopAutoSave(key: string): void;
    /**
     * Destroys this manager. Once this manager is destroyed, all active autosaves will be stopped, and attempting to
     * save, load, or start another autosave from this manager will cause an error to be thrown.
     */
    destroy(): void;
    /**
     * Gets a data store key for a specific setting and save key.
     * @param setting A user setting.
     * @param saveKey The save key.
     * @returns the data store key for the setting and save key.
     */
    private static getDataStoreKey;
}

/**
 * Events related to autopilot altitude selection.
 */
interface AltitudeSelectEvents {
    /** Whether the autopilot selected altitude has been initialized to a value. */
    alt_select_is_initialized: boolean;
}
/**
 * Metric Altitude Select Setting.
 */
declare type MetricAltitudeSelectSetting = {
    /** Whether the altimeter is set to Metric */
    'altMetric': boolean;
};
/**
 * A type describing a settings manager that at least has the metric altimeter setting.
 */
declare type MetricAltitudeSettingsManager = UserSettingManager<MetricAltitudeSelectSetting>;
/**
 * Configuration options for AltitudeSelectManager.
 */
declare type AltitudeSelectManagerOptions = {
    /** Whether to support metric mode. */
    supportMetric: boolean;
    /** The minimum value of the selected altitude setting. */
    minValue: NumberUnitInterface<UnitFamily.Distance>;
    /** The maximum value of the selected altitude setting. */
    maxValue: NumberUnitInterface<UnitFamily.Distance>;
    /**
     * The minimum value of the selected altitude setting in metric mode. If undefined, it will be set equal to the
     * minimum value in non-metric mode.
     */
    minValueMetric?: NumberUnitInterface<UnitFamily.Distance>;
    /**
     * The maximum value of the selected altitude setting in metric mode. If undefined, it will be set equal to the
     * maximum value in non-metric mode.
     */
    maxValueMetric?: NumberUnitInterface<UnitFamily.Distance>;
    /**
     * The threshold for an altitude select change key input value above which the input is interpreted as a large
     * increment.
     */
    inputIncrLargeThreshold: number;
    /** The value to increase/decrease the selected altitude setting on a small increment. */
    incrSmall: NumberUnitInterface<UnitFamily.Distance>;
    /** The value to increase/decrease the selected altitude setting on a large increment.  */
    incrLarge: NumberUnitInterface<UnitFamily.Distance>;
    /**
     * The value to increase/decrease the selected altitude setting on a small increment in metric mode. If undefined,
     * it will be set equal to the small increment value in non-metric mode.
     */
    incrSmallMetric?: NumberUnitInterface<UnitFamily.Distance>;
    /**
     * The value to increase/decrease the selected altitude setting on a large increment in metric mode. If undefined,
     * it will be set equal to the large increment value in non-metric mode.
     */
    incrLargeMetric?: NumberUnitInterface<UnitFamily.Distance>;
    /**
     * Whether to lock the selected altitude setting to multiples of the appropriate increment value on a small or large
     * increment. Defaults to `true`.
     */
    lockAltToStepOnIncr?: boolean;
    /**
     * Whether to lock the selected altitude setting to multiples of the appropriate increment value on a small or large
     * increment in metric mode. If undefined, it will be set equal to the lock flag in non-metric mode.
     */
    lockAltToStepOnIncrMetric?: boolean;
    /**
     * The required number of consecutive small-increment inputs received to trigger input acceleration. While
     * acceleration is active, small-increment inputs will be converted to large increments. A threshold less than or
     * equal to zero effectively disables input acceleration. Defaults to 0.
     */
    accelInputCountThreshold?: number;
    /** Whether to reset input acceleration if the direction of increment changes. Defaults to `false`. */
    accelResetOnDirectionChange?: boolean;
    /**
     * Whether to initialize the selected altitude setting only on the first detected input. If `false`, the selected
     * altitude will be initialized as soon as the manager is fully initialized. Defaults to `false`.
     */
    initOnInput?: boolean;
    /**
     * Whether to initialize the selected altitude setting to the indicated altitude. If `false`, the selected altitude
     * will be initialized to `0`. Defaults to `false`.
     */
    initToIndicatedAlt?: boolean;
};
/**
 * Controls the value of the autopilot selected altitude setting in response to key events.
 */
declare class AltitudeSelectManager {
    private readonly bus;
    private static readonly CONSECUTIVE_INPUT_PERIOD;
    private keyInterceptManager?;
    private readonly publisher;
    private readonly minValue;
    private readonly maxValue;
    private readonly minValueMetric;
    private readonly maxValueMetric;
    private readonly inputIncrLargeThreshold;
    private readonly incrSmall;
    private readonly incrLarge;
    private readonly incrSmallMetric;
    private readonly incrLargeMetric;
    private readonly lockAltToStepOnIncr;
    private readonly lockAltToStepOnIncrMetric;
    private readonly accelInputCountThreshold;
    private readonly accelResetOnDirectionChange;
    private readonly initToIndicatedAlt;
    private readonly altimeterMetricSetting;
    private isEnabled;
    private isInitialized;
    private isLocked;
    private lockDebounceTimer;
    private consecIncrSmallCount;
    private lastIncrSmallDirection;
    private lastIncrSmallInputTime;
    private readonly selectedAltitudeChangedHandler;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param settingsManager The user settings manager controlling metric altitude preselector setting.
     * @param options Configuration options for this manager.
     */
    constructor(bus: EventBus, settingsManager: MetricAltitudeSettingsManager, options: AltitudeSelectManagerOptions);
    /**
     * Sets whether this manager is enabled. When this manager is disabled, all key events to change the selected
     * altitude setting are processed "as-is".
     * @param isEnabled Whether this manager is enabled.
     */
    setEnabled(isEnabled: boolean): void;
    /**
     * Responds to key intercepted events.
     * @param data The event data.
     * @param data.key The key that was intercepted.
     * @param data.index The index of the intercepted key event.
     * @param data.value The value of the intercepted key event.
     */
    private onKeyIntercepted;
    /**
     * Handles a key event.
     * @param key The key.
     * @param value The value of the key event.
     */
    private handleKeyEvent;
    /**
     * Increments or decrements the selected altitude setting. The amount the setting is changed depends on whether the
     * PFD altimeter metric mode is enabled. The value of the setting after the change is guaranteed to be a round number
     * in the appropriate units (nearest 100 feet or 50 meters).
     * @param startValue The value from which to change, in feet.
     * @param direction The direction of the change: `1` for increment, `-1` for decrement.
     * @param useLargeIncrement Whether to change the altitude by the large increment (1000 feet/500 meters) instead of
     * the small increment (100 feet/50 meters). False by default.
     */
    private changeSelectedAltitude;
    /**
     * Processes a key event "as-is".
     * @param key The key that was pressed.
     * @param index The index of the key event.
     * @param value The value of the key event.
     */
    private passThroughKeyEvent;
}

/** The acceptable priority types for a given annunciation. */
declare enum AnnunciationType {
    Warning = 0,
    Caution = 1,
    Advisory = 2,
    SafeOp = 3
}
/** The main logic for a cabin annunciation. */
declare class Annunciation {
    /** The priority type of the annunciation. */
    readonly type: AnnunciationType;
    /** The text to show when we are displayed. */
    readonly text: string;
    /** An XML logic element that will show when we are active. */
    readonly condition: CompositeLogicXMLElement;
    /** An optional text suffix to put on the alert text. */
    readonly suffix: string | undefined;
    /**
     * Creates an instance of Annunciation.
     * @param type The type of annuniciaton this is.
     * @param text The text label to show.
     * @param condition The logic condition for setting it.
     * @param suffix Any suffix text to past to the end.
     */
    constructor(type: AnnunciationType, text: string, condition: CompositeLogicXMLElement, suffix: string | undefined);
}

/** Create a list of annunciations from the instrument XML config. */
declare class XMLAnnunciationFactory {
    private instrument;
    /**
     * Create an XMLAnnunciationFactory.
     * @param instrument The instrument that holds this engine display.
     */
    constructor(instrument: BaseInstrument);
    /**
     * Parse an panel.xml configuration
     * @param document The configuration as an XML document.
     * @returns An array of Annunciations.
     */
    parseConfig(document: Document): Array<Annunciation>;
}

/**
 * Weather radar mode data for the BingComponent.
 */
interface WxrMode {
    /** The weather mode. */
    mode: EWeatherRadar;
    /** The size of the weather radar arc in front of the plane, in radians. */
    arcRadians: number;
}
/**
 * Component props for the MapComponent.
 */
interface BingComponentProps extends ComponentProps {
    /** The unique ID to assign to this Bing component. */
    id: string;
    /** The mode of the Bing component. */
    mode: EBingMode;
    /** A callback to call when the Bing component is bound. */
    onBoundCallback?: (component: BingComponent) => void;
    /**
     * A subscribable which provides the internal resolution for the Bing component. If not defined, the resolution
     * defaults to 1024x1024 pixels.
     */
    resolution?: Subscribable<ReadonlyFloat64Array>;
    /**
     * A subscribable array which provides the earth colors for the Bing component. The array should have a length of
     * exactly 61, with index 0 defining the water color and indexes 1 through 60 defining terrain colors from 0 to
     * 60000 feet. If not defined, the earth colors default to black.
     */
    earthColors?: SubscribableArray<number>;
    /**
     * A subscribable which provides the sky color for the Bing component. The sky color is only visible in synthetic
     * vision (`EBingMode.HORIZON`) mode. If not defined, the sky color defaults to black.
     */
    skyColor?: Subscribable<number>;
    /**
     * A subscribable which provides the reference mode for the Bing component. If not defined, the reference mode
     * defaults to `EBingReference.SEA`.
     */
    reference?: Subscribable<EBingReference>;
    /**
     * A subscribable which provides the weather radar mode for the Bing component. If not defined, the weather radar
     * mode defaults to `EWeatherRadar.NONE`.
     */
    wxrMode?: Subscribable<WxrMode>;
    /**
     * A subscribable which provides whether the map isolines should be shown or not. If true, they are shown, if
     * false, they are not.
     */
    isoLines?: Subscribable<boolean>;
    /**
     * How long to delay binding the map in ms. Defaults to 3000.
     */
    delay?: number;
    /** CSS class(es) to add to the Bing component's image. */
    class?: string | SubscribableSet<string>;
}
/**
 * A FSComponent that displays the MSFS Bing Map, weather radar, and 3D terrain.
 */
declare class BingComponent extends DisplayComponent<BingComponentProps> {
    static readonly DEFAULT_RESOLUTION = 1024;
    private readonly modeFlags;
    private mapListener;
    private isListenerRegistered;
    private readonly imgRef;
    private binder?;
    private uid;
    private _isBound;
    private _isAwake;
    private isDestroyed;
    private pos;
    private radius;
    private readonly resolution;
    private readonly earthColors;
    private readonly skyColor;
    private readonly reference;
    private readonly wxrMode;
    private readonly isoLines;
    private gameStateSub?;
    private resolutionPropSub?;
    private earthColorsPropSub?;
    private skyColorPropSub?;
    private referencePropSub?;
    private wxrModePropSub?;
    private isoLinesPropSub?;
    private resolutionSub?;
    private earthColorsSub?;
    private skyColorSub?;
    private referenceSub?;
    private wxrModeSub?;
    private isoLinesSub?;
    private readonly resolutionPropHandler;
    private readonly earthColorsPropHandler;
    private readonly skyColorPropHandler;
    private readonly referencePropHandler;
    private readonly wxrModePropHandler;
    private readonly isoLinesPropHandler;
    private readonly resolutionHandler;
    private readonly earthColorsHandler;
    private readonly skyColorHandler;
    private readonly referenceHandler;
    private readonly wxrModeHandler;
    private readonly isoLinesHandler;
    /**
     * Checks whether this Bing component has been bound.
     * @returns whether this Bing component has been bound.
     */
    isBound(): boolean;
    /**
     * Checks whether this Bing component is awake.
     * @returns whether this Bing component is awake.
     */
    isAwake(): boolean;
    /** @inheritdoc */
    onAfterRender(): void;
    /**
     * Registers this component's Bing map listener.
     */
    private registerListener;
    /**
     * A callback called when this component's Bing map listener is registered.
     */
    private onListenerRegistered;
    /**
     * A callback called when the listener is fully bound.
     * @param binder The binder from the listener.
     * @param uid The unique ID of the bound map.
     */
    private onListenerBound;
    /**
     * A callback called when the map image is updated.
     * @param uid The unique ID of the bound map.
     * @param imgSrc The img tag src attribute to assign to the bing map image.
     */
    private onMapUpdate;
    /**
     * Wakes this Bing component. Upon awakening, this component will synchronize its state from when it was put to sleep
     * to the Bing instance to which it is bound.
     */
    wake(): void;
    /**
     * Puts this Bing component to sleep. While asleep, this component cannot make changes to the Bing instance to which
     * it is bound.
     */
    sleep(): void;
    /**
     * Sets the center position and radius.
     * @param pos The center position.
     * @param radius The radius, in meters.
     */
    setPositionRadius(pos: LatLong, radius: number): void;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
    /**
     * Resets the img element's src attribute.
     */
    resetImgSrc(): void;
    /**
     * Converts an HTML hex color string to a numerical map RGB value.
     * @param hexColor The hex color string to convert.
     * @returns A numerical map RGB value.
     */
    static hexaToRGBColor(hexColor: string): number;
    /**
     * Converts RGB color components to a numerical map RGB value.
     * @param r The red component, from 0 to 255.
     * @param g The green component, from 0 to 255.
     * @param b The blue component, from 0 to 255.
     * @returns A numerical map RGB value.
     */
    static rgbColor(r: number, g: number, b: number): number;
    /**
     * Creates a full Bing component earth colors array. The earth colors array will contain the specified water color
     * and terrain colors (including interpolated values between the explicitly defined ones, as necessary).
     * @param waterColor The desired water color, as a hex string with the format `#hhhhhh`.
     * @param terrainColors An array of desired terrain colors at specific elevations. Elevations should be specified in
     * feet and colors as hex strings with the format `#hhhhhh`.
     * @returns a full Bing component earth colors array.
     */
    static createEarthColorsArray(waterColor: string, terrainColors: {
        elev: number;
        color: string;
    }[]): number[];
}

/**
 * Component props for AbstractNumberUnitDisplay.
 */
interface AbstractNumberUnitDisplayProps<F extends string> extends ComponentProps {
    /** The {@link NumberUnitInterface} value to display, or a subscribable which provides it. */
    value: NumberUnitInterface<F> | Subscribable<NumberUnitInterface<F>>;
    /**
     * The unit type in which to display the value, or a subscribable which provides it. If the unit is `null`, then the
     * native type of the value is used instead.
     */
    displayUnit: Unit<F> | null | Subscribable<Unit<F> | null>;
}
/**
 * A component which displays a number with units.
 */
declare abstract class AbstractNumberUnitDisplay<F extends string, P extends AbstractNumberUnitDisplayProps<F> = AbstractNumberUnitDisplayProps<F>> extends DisplayComponent<P> {
    /** A subscribable which provides the value to display. */
    protected readonly value: Subscribable<NumberUnitInterface<F>>;
    /** A subscribable which provides the unit type in which to display the value. */
    protected readonly displayUnit: Subscribable<Unit<F> | null>;
    private valueSub?;
    private displayUnitSub?;
    /** @inheritdoc */
    onAfterRender(): void;
    /**
     * A callback which is called when this component's bound value changes.
     * @param value The new value.
     */
    protected abstract onValueChanged(value: NumberUnitInterface<F>): void;
    /**
     * A callback which is called when this component's bound display unit changes.
     * @param displayUnit The new display unit.
     */
    protected abstract onDisplayUnitChanged(displayUnit: Unit<F> | null): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Component props for DigitScroller.
 */
interface DigitScrollerProps extends ComponentProps {
    /** The value to which the scroller is bound. */
    value: Subscribable<number>;
    /** The number base used by the scroller. Must be an integer greater than or equal to `3`. */
    base: number;
    /**
     * The factor represented by the scroller's digit. The factor relates the digit to its nominal value as
     * `value = digit * factor`. Cannot be `0`.
     */
    factor: number;
    /**
     * The amount the scroller's value must deviate from the current displayed digit's nominal value before the digit
     * begins to scroll. Defaults to `0`.
     */
    scrollThreshold?: number;
    /**
     * A function which renders each digit of the scroller to a text string. If not defined, each digit will be rendered
     * using the `Number.toString()` method.
     */
    renderDigit?: (digit: number) => string;
    /** The string to render when the scroller's value is `NaN`. Defaults to ``. */
    nanString?: string;
    /** CSS class(es) to apply to the root of the digit scroller. */
    class?: string | SubscribableSet<string>;
}
/**
 * A scrolling digit display.
 */
declare class DigitScroller extends DisplayComponent<DigitScrollerProps> {
    private readonly digitCount;
    private readonly translationPerDigit;
    private readonly tapeStyle;
    private readonly nanTextStyle;
    private readonly digitPlaceFactor;
    private readonly scrollThreshold;
    private readonly translateY;
    private valueSub?;
    private cssClassSub?;
    /** @inheritdoc */
    constructor(props: DigitScrollerProps);
    /** @inheritdoc */
    onAfterRender(): void;
    /**
     * Updates this display.
     * @param value This display's value.
     */
    private update;
    /** @inheritdoc */
    render(): VNode;
    /**
     * Renders text for each of this display's individual digits.
     * @returns This display's individual digit text, as an array of VNodes.
     */
    private renderDigits;
    /** @inheritdoc */
    destroy(): void;
}

declare enum DurationDisplayFormat {
    /** hh:mm:ss. */
    hh_mm_ss = 0,
    /** hh:mm. */
    hh_mm = 1,
    /** mm:ss. */
    mm_ss = 2,
    /** hh:mm if value is greater or equal to 1 hour, otherwise mm:ss. */
    hh_mm_or_mm_ss = 3
}
declare enum DurationDisplayDelim {
    /** Colon (`:`). */
    Colon = 0,
    /** `:` if hh:mm:ss or mm:ss, `+` if hh:mm. */
    ColonOrCross = 1,
    /** Space (` `). */
    Space = 2
}
/**
 * Formatting options for DurationDisplay.
 */
declare type DurationDisplayOptions = {
    /** The format with which to display values. */
    format: DurationDisplayFormat;
    /** The delimiter to insert between parts of formatted values. */
    delim: DurationDisplayDelim;
    /** The number of digits to which to pad the first part of formatted values with leading zeroes. */
    pad: number;
    /** A function used to format the last part of formatted values. */
    numberFormatter: (value: number) => string;
    /** Whether to show units. */
    showUnits: boolean;
    /** A function used to format units. */
    unitFormatter: (value: number, unit: Unit<UnitFamily.Duration>) => string;
    /** The string to display when the value is NaN. */
    nanString: string;
};
/**
 * Component props for DurationDisplay.
 */
interface DurationDisplayProps extends ComponentProps {
    /** The duration to display, or a subscribable which provides it. */
    value: NumberUnitInterface<UnitFamily.Duration> | Subscribable<NumberUnitInterface<UnitFamily.Duration>>;
    /** Formatting options. Any options not explicitly set will revert to the default. */
    options?: Partial<DurationDisplayOptions>;
    /** CSS class(es) to add to the root of the icon component. */
    class?: string | SubscribableSet<string>;
}
/**
 * A component which displays duration values.
 */
declare class DurationDisplay extends DisplayComponent<DurationDisplayProps> {
    /** Default formatting options. */
    static readonly DEFAULT_OPTIONS: DurationDisplayOptions;
    private readonly value;
    private valueSub?;
    private readonly options;
    private readonly delim;
    private readonly text;
    /** @inheritdoc */
    constructor(props: DurationDisplayProps);
    /** @inheritdoc */
    onAfterRender(): void;
    /**
     * A callback which is called when this component's bound value changes.
     * @param value The new value.
     */
    private onValueChanged;
    /**
     * Displays this component's current value.
     * @param value The current value.
     */
    private setDisplay;
    /**
     * Pads the integer part of a string which represents a number.
     * @param str A string which represents a number.
     * @param maxLength The length to which the integer part of the string will be padded.
     * @param fillString The string with which to pad the original string.
     * @returns a new string which is the result of padding the original string.
     */
    private static padIntegerPart;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Component props for WaypointComponent.
 */
interface LatLonDisplayProps extends ComponentProps {
    /** A subscribable which provides a location to bind. */
    location: Subscribable<GeoPointInterface>;
    /** CSS class(es) to add to the root of the icon component. */
    class?: string | SubscribableSet<string>;
}
/**
 * A component which displays lat/lon coordinates.
 */
declare class LatLonDisplay extends DisplayComponent<LatLonDisplayProps> {
    private locationSub?;
    private readonly latPrefix;
    private readonly latNum;
    private readonly lonPrefix;
    private readonly lonNum;
    private readonly formatter;
    /** @inheritdoc */
    onAfterRender(): void;
    /**
     * A callback which is called when this component's bound location changes.
     * @param location The new location.
     */
    private onLocationChanged;
    /**
     * Displays the formatted lat/lon coordinates of a location.
     * @param location A location.
     */
    private setDisplay;
    /**
     * Sets coordinate subjects for a given set of coordinate values.
     * @param prefixSub The coordinate prefix subject.
     * @param numSub The coordinate number subject.
     * @param coordValues The DMS values of the coordinate.
     * @param padDeg The number of digits to which to pad the degrees value.
     */
    private setCoordSub;
    /**
     * Displays the blank default value.
     */
    private clearDisplay;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * A handler for events emitted by UiControl2.
 * @template T The type of event sources.
 * @template Args A tuple type describing additional arguments for an event after the source control. Defaults to an
 * empty (zero-length) tuple.
 */
declare type UiControlEventHandler<T extends HardwareUiControl<any, any>, Args extends any[] = []> = (source: T, ...args: Args) => boolean;
/** A requested scroll direction. */
declare type ScrollDirection = 'forward' | 'backward';
/**
 * Maps an event definition type to an event handler interface. Each event in the definition type is mapped to a
 * handler with the name `on[Event]`.
 */
declare type UiControlEventHandlers<Events> = {
    [Event in keyof Events as `on${Event & string}`]: Events[Event];
};
/**
 * Maps an event definition type to a prop event handler interface. Each event in the definition type is mapped to an
 * optional handler with the name `on[Event]`.
 */
declare type UiControlPropEventHandlers<Events> = Partial<UiControlEventHandlers<Events>>;
/** Properties on the UiControl2 component. */
interface HardwareUiControlProps extends ComponentProps {
    /** Whether or not the inner FMS knob scrolls also by default. */
    innerKnobScroll?: boolean;
    /**
     * When enabled, scroll commands will not propagate from this control to its parent while
     * the control is focused.
     */
    isolateScroll?: boolean;
    /** Whether the control requires one of its child controls to be focused for itself to be focused. */
    requireChildFocus?: boolean;
    /** An event called when the control is focused. */
    onFocused?: (source: HardwareUiControl) => void;
    /** An event called when the control loses focus. */
    onBlurred?: (source: HardwareUiControl) => void;
    /** An event called when the control is disabled. */
    onDisabled?: (source: HardwareUiControl) => void;
    /** An event called when the control is enabled. */
    onEnabled?: (source: HardwareUiControl) => void;
    /** A function which returns how the control should focus its children when it is focused from a scroll. */
    getFocusPositionOnScroll?: (direction: ScrollDirection) => FocusPosition;
    /** An event called when the control is scrolled. */
    onScroll?: (direction: ScrollDirection) => boolean;
    /** An event called when the scroll operation has completed. */
    onAfterScroll?: (control: HardwareUiControl, index: number) => void;
    /** An event called when a control is registered with this control. */
    onRegistered?: (source: HardwareUiControl) => void;
    /** An event called when a control is unregistered with this control. */
    onUnregistered?: (source: HardwareUiControl) => void;
    /** An event called when the control is destroyed. */
    onDestroyed?: (source: HardwareUiControl) => void;
    /**
     * A function which reconciles the focus state of the control's children when the control is focused with no focused
     * children after a child has been blurred.
     * @param index The index of the child control that was blurred.
     * @param child The child control that was blurred.
     * @returns The index of the child to focus, or a blur reconciliation strategy.
     */
    reconcileChildBlur?: (index: number, child: HardwareUiControl) => number | BlurReconciliation;
}
/**
 * The item position to focus a component's children when performing a focus operation.
 */
declare enum FocusPosition {
    /** The component's most recently focused descendants will be focused. */
    MostRecent = "MostRecent",
    /** The first focus-able child at each node in the descendant tree will be focused. */
    First = "First",
    /** The last focus-able child at each node in the descendant tree will be focused. */
    Last = "Last",
    /** No child components will be focused. */
    None = "None"
}
/**
 * A strategy to focus a component's children as part of a blur reconciliation operation.
 */
declare enum BlurReconciliation {
    /** The component's first focus-able child will be focused. */
    First = "First",
    /** The component's last focus-able child will be focused. */
    Last = "Last",
    /**
     * The component's next focus-able child after the child that was blurred will be focused. If no such child exists,
     * then the last focus-able child before the child that was blurred will be focused.
     */
    Next = "Next",
    /**
     * The component's last focus-able child before the child that was blurred will be focused. If no such child exists,
     * then the next focus-able child after the child that was blurred will be focused.
     */
    Prev = "Prev",
    /** No child components will be focused. */
    None = "None"
}
/**
 * An abstract implementation of a component that forms the base of a Garmin-like UI control system. Subclasses should
 * implement an appropriate event handler interface (using the utility type `UiControlEventHandlers<Events>`) and have
 * their props implement the corresponding prop event handler interface (using the utility type
 * `UiControlPropEventHandlers<Events>`).
 * @template E An event definition type for events supported by this control.
 * @template P The component prop type for this control.
 */
declare abstract class HardwareUiControl<E extends Record<string, any> = Record<string, any>, P extends HardwareUiControlProps = HardwareUiControlProps> extends DisplayComponent<P> {
    protected registeredControls: HardwareUiControl<E>[] | undefined;
    protected focusedIndex: number;
    private parent;
    private _isDisabled;
    private _isFocused;
    private _isIsolated;
    private readonly _UICONTROL_;
    /**
     * Creates an instance of a HardwareUiControl.
     * @param props The props for this component.
     */
    constructor(props: P);
    /**
     * Gets the current number of registered child controls.
     * @returns The current number of registered child controls.
     */
    get length(): number;
    /**
     * Gets whether or not the control is currently disabled.
     * @returns True if disabled, false otherwise.
     */
    get isDisabled(): boolean;
    /**
     * Gets whether or not the control is currently focused.
     * @returns True if disabled, false otherwise.
     */
    get isFocused(): boolean;
    /**
     * Gets whether or not the control is currently in scroll isolation.
     * @returns True if currently in scroll isolation, false otherwise.
     */
    get isIsolated(): boolean;
    /**
     * An event called when the control receives focus.
     * @param source The control that emitted this event.
     */
    protected onFocused(source: HardwareUiControl<E>): void;
    /**
     * An event called when the control is blurred.
     * @param source The control that emitted this event.
     */
    protected onBlurred(source: HardwareUiControl<E>): void;
    /**
     * An event called when the control is enabled.
     * @param source The control that emitted this event.
     */
    protected onEnabled(source: HardwareUiControl<E>): void;
    /**
     * An event called when the control is disabled.
     * @param source The control that emitted this event.
     */
    protected onDisabled(source: HardwareUiControl<E>): void;
    /**
     * An event called when a control is registered with this control.
     * @param source The control that emitted this event.
     */
    protected onRegistered(source: HardwareUiControl<E>): void;
    /**
     * An event called when a control is unregistered from this control.
     * @param source The control that emitted this event.
     */
    protected onUnregistered(source: HardwareUiControl<E>): void;
    /**
     * Gets the focus position to apply when this control is focused from a scroll.
     * @param direction The direction of the scroll.
     * @returns The focus position to apply when this control is focused from a scroll.
     */
    protected getFocusPositionOnScroll(direction: ScrollDirection): FocusPosition;
    /**
     * An event called when the control is scrolled.
     * @param direction The direction that is being requested to scroll.
     * @returns True if this control handled this event, false otherwise.
     */
    protected onScroll(direction: ScrollDirection): boolean;
    /**
     * An event called when a scroll operation has completed.
     * @param control The control that was scrolled to.
     * @param index The index of the control in the collection of registered controls.
     */
    protected onAfterScroll(control: HardwareUiControl<E>, index: number): void;
    /**
     * Scrolls the currently focused control in the supplied direction.
     * @param direction The direction that is being requested to scroll.
     * @returns True if propagation should be stopped, false otherwise.
     */
    scroll(direction: ScrollDirection): boolean;
    /**
     * Attempts to perform a scroll operation on the control, propagating the operation
     * upward in the tree if the control does not handle the operation.
     * @param direction The direction that is being requested to scroll.
     * @returns True if propagation should be stopped, false otherwise.
     */
    private tryPerformScroll;
    /**
     * A method which is called when this control receives an interaction event.
     * @param event The event.
     * @returns True if the event was handled, false otherwise.
     */
    abstract onInteractionEvent(event: keyof E): boolean;
    /**
     * Triggers an event on this control. The event will first be routed to the deepest focused descendent of this
     * control and will propagate up the control tree until it is handled or there are no more controls to which to
     * propagate.
     * @param event The event to trigger.
     * @param source The source of the event. Defaults to this if not supplied.
     * @param args Additional arguments to pass to the event handler.
     * @returns True if the event was handled, false otherwise.
     */
    triggerEvent(event: keyof E, source: HardwareUiControl, ...args: any[]): boolean;
    /**
     * Propagates an event up the control tree.
     * @param event The event to propagate.
     * @param source The source of the event.
     * @param args Additional arguments to pass to the event handler.
     * @returns True if the event was handled, false otherwise.
     */
    private propagateEvent;
    /**
     * Validates that the control can be focused by checking if any ancestors in the
     * control tree are disabled.
     * @returns True if there are no disabled ancestors, false otherwise.
     */
    private canBeFocused;
    /**
     * Brings focus to the control. Focusing the control will also blur the currently
     * focused control, if any.
     * @param focusPosition The focus position to activate for descendents of this control.
     * @returns Whether this control was successfully focused.
     */
    focus(focusPosition: FocusPosition): boolean;
    /**
     * Gets the path from this control to the deepest descendent control that is focused. If this control is not focused,
     * then the path is empty.
     * @param path The stack of control nodes defining the path to the currently
     * focused descendent control.
     * @returns A stack of nodes that defines the path to the deepest focused descendent
     * node, in order of deepest descendent first.
     */
    private getFocusedComponentPath;
    /**
     * Gets the path from this control to its deepest ancestor that is focused (including itself). If none of this
     * control's ancestors are focused, the path will contain this control and all of its ancestors up to and including
     * the root of its control tree.
     * @param path An array in which to store the path.
     * @returns A stack of controls that defines the path from this control to its deepest focused ancestor, ordered
     * from descendents to ancestors (the control at the shallowest tree depth is located at the top of the stack).
     */
    private getDeepestFocusedAncestorPath;
    /**
     * Builds the path of controls to focus from this control downward in children based on the provided default focus
     * position. If this control cannot be focused, the path will be empty.
     * @param focusPosition The focus position to use to build the path.
     * @param focusStack The stack in which to store the path.
     * @returns A stack of components that defines the path from the deepest descendent to focus to this control if this
     * control were to be focused with the specified focus position, ordered from descendents to ancestors (the control
     * at the shallowest tree depth is located at the top of the stack).
     */
    private buildFocusPath;
    /**
     * Blurs, or removes focus, from the component.
     */
    blur(): void;
    /**
     * Handles the case where this control is left focused with no focused child control after a child control is
     * blurred.
     * @param indexBlurred The index of the child control that was blurred. If the child is no longer registered, then
     * this is the index of the child prior to being unregistered.
     * @param childBlurred The child control that was blurred.
     */
    private handleNoFocusedChild;
    /**
     * Reconciles the focus state of this control's children when this control is focused with no focused children after
     * a child has been blurred.
     * @param index The index of the child control that was blurred. If the child is no longer registered, then this is
     * the index of the child prior to being unregistered.
     * @param child The child control that was blurred.
     * @returns The index of the child control to focus.
     */
    protected reconcileChildBlur(index: number, child: HardwareUiControl<E>): number | BlurReconciliation;
    /**
     * Sets the component to be disabled, removing the ability for the component to scroll. Setting
     * a component to disabled will also blur the component and its children, if necessary.
     * @param isDisabled Whether or not the component is disabled.
     */
    setDisabled(isDisabled: boolean): void;
    /**
     * Registers a child control with this control.
     * @param control The control to register.
     * @param index The index at which to register the control. If none is provided,
     * the control will be registered at the end of the collection of child controls.
     */
    register(control: HardwareUiControl<E>, index?: number): void;
    /**
     * Unregisters a child control with this control.
     * @param item The child control or index of a child control to unregister. If a
     * child control is provided, it will attempt to be located in the control's
     * child registry and then removed. If an index is provided, the child control
     * at that registered index will be removed.
     */
    unregister(item: HardwareUiControl<E> | number): void;
    /**
     * Clears the list of registered components.
     */
    clearRegistered(): void;
    /**
     * Gets the current focused index in the registered controls collection.
     * @returns The index of the focused control in the collection of registered controls.
     */
    getFocusedIndex(): number;
    /**
     * Gets the most recent focused index (including the current focused index, if one exists) in the registered controls
     * collection.
     * @returns The index of the most recently focused control in the collection of registered controls.
     */
    getMostRecentFocusedIndex(): number;
    /**
     * Sets the current most recently focused child control index. If this control is focused and has children
     * that have focus, this will also switch child focus to the new index.
     * @param index The index of the child control to set most recent focus for.
     * @param focusPosition The focus position to focus the child for, if required.
     */
    setFocusedIndex(index: number, focusPosition?: FocusPosition): void;
    /**
     * Gets a child control at the specified index.
     * @param index The index of the child control to get.
     * @returns The specified child control.
     */
    getChild(index: number): HardwareUiControl<E> | undefined;
    /**
     * Gets the index of a specified child control within the registered
     * child controls collection.
     * @param child The child to get the index of.
     * @returns The index of the child, or -1 if not found.
     */
    indexOf(child: HardwareUiControl<E>): number;
    /**
     * Sets the parent of this control.
     * @param parent The parent to set.
     */
    setParent(parent: HardwareUiControl<E>): void;
    /**
     * Sets whether or not this control is in scroll isolation. While scroll isolation
     * is enabled, scroll events will not propagate to the control's parent when the
     * control has focus.
     * @param isolated Whether or not the control is isolated.
     */
    setIsolated(isolated: boolean): void;
    /** @inheritdoc */
    onAfterRender(thisNode: VNode): void;
    /**
     * Renders the control.
     * @returns The component VNode.
     */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Properties on the ControlList component.
 */
interface HardwareControlListProps<T> extends HardwareUiControlProps {
    /** The data associated with this list component. */
    data: SubscribableArray<T>;
    /** A function that renders a single data item into the list. */
    renderItem: (data: T, index: number) => VNode;
    /** A callback called when an item in the list is selected. */
    onItemSelected?: (data: T | null, node: HardwareUiControl | null, index: number) => void;
    /** Indicates that the list should be ordered by a specified function. */
    orderBy?: (a: T, b: T) => number;
    /** The size, in pixels, of each item in the list. */
    itemSize?: number;
    /** The max number of items to display in the list. */
    numItems?: number;
    /** Whether or not to hide the list scrollbar. */
    hideScrollbar?: boolean;
    /** The CSS class to apply to this list container. */
    class?: string;
    /** An alternate HTML element to scroll to ensure the selected element is in view. */
    scrollContainer?: NodeReference<HTMLElement>;
    /** Disables automatically ensuring that the container scrolls to the focused item. */
    disableContainerScroll?: boolean;
}
/**
 * A component that displays a collection of UiControls in a list format.
 */
declare abstract class HardwareUiControlList<T, E extends Record<string, any> = Record<string, never>, P extends HardwareControlListProps<T> = HardwareControlListProps<T>> extends HardwareUiControl<E, P> {
    private readonly el;
    private readonly itemsContainer;
    private dataToControlMap;
    private controlToElementMap;
    private controlToDataMap;
    private currentControlOrder;
    /**
     * Creates an instance of a ControlList.
     * @param props The props on the ControlList component.
     */
    constructor(props: P);
    /** @inheritdoc */
    onAfterRender(node: VNode): void;
    /**
     * A callback fired when the array subject data changes.
     * @param index The index of the change.
     * @param type The type of change.
     * @param data The item that was changed.
     */
    private onDataChanged;
    /**
     * An event called when data is added to the subscription.
     * @param index The index that the data was added at.
     * @param data The data that was added.
     */
    private onDataAdded;
    /**
     * Adds a data item to the control list and performs the required rendering and
     * ordering operations.
     * @param dataItem The data item to add to the list.
     * @param indexToAdd The index to add the item at.
     * @param currentItemElement The current DOM element that resides at the location to add to.
     */
    private addDataItem;
    /**
     * An event called when data is removed from the subscription.
     * @param index The index that the data was removed at.
     * @param data The data that was removed;
     */
    private onDataRemoved;
    /**
     * Removes a data item from the control list.
     * @param data The data item to remove.
     * @param index The index of the data that was removed.
     */
    private removeDataItem;
    /**
     * An event called when the data is cleared in the subscription.
     */
    private onDataCleared;
    /**
     * Adds a data item to element order tracking information.
     * @param control The index to add the data item at.
     * @param data The data to add tracking information for.
     * @param element The DOM element to associate with this data item.
     */
    private addToOrderTracking;
    /**
     * Removes a data item from element order tracking information.
     * @param data The data item to remove order tracking information for.
     */
    private removeFromOrderTracking;
    /**
     * Clears all data item element order tracking information.
     */
    private clearOrderTracking;
    /**
     * Updates the order of data items in the list by the props supplied
     * comparison function, if one exists.
     */
    updateOrder(): void;
    /**
     * Checks whether or not the control order is the same as it was previously.
     * @returns True if the order is the same, false otherwise.
     */
    private orderUnchanged;
    /**
     * Sorts the registered controls by the provided ordering comparison function.
     * @param a The first control to compare.
     * @param b The second control to compare.
     * @returns Negative if the first control is less than, zero if equal, positive if greater than.
     */
    private sortControls;
    /**
     * Removes a dom node from the collection at the specified index.
     * @param index The index to remove.
     */
    private removeDomNode;
    /**
     * Adds a list rendered dom node to the collection.
     * @param node Item to render and add.
     * @param index The index to add at.
     * @param el The element to add to.
     * @returns The created DOM element.
     */
    private renderToDom;
    /**
     * Scrolls to an item.
     * @param index is the index of the list item to scroll to.
     * @param focusPosition The focus position to apply to children of the item being scrolled to.
     */
    scrollToIndex(index: number, focusPosition?: FocusPosition): void;
    /**
     * Ensures an indexed list item is in view.
     * @param index The index of the list item.
     */
    ensureIndexInView(index: number): void;
    /**
     * Gets an element at the specified data/control index.
     * @param index The data/control index to get the element for.
     * @returns The request HTML element.
     */
    private getElement;
    /**
     * Gets the data object related to the selected DOM element.
     * @param index The index of the data to get.
     * @returns The selected item, if found.
     */
    getData(index: number): T | null;
    /**
     * Get the selected HTMLElement.
     * @returns The selected element, if found.
     */
    getSelectedElement(): HTMLElement | null;
    /**
     * Gets the index of the currently selected element.
     * @returns Selected element index. Returns -1 if nothing found.
     */
    getSelectedIndex(): number;
    /**
     * Gets the instance of the node at the specified index.
     * @param index The index to get the instance for.
     * @returns The node instance of specified type.
     */
    getChildInstance<TControl extends HardwareUiControl<E>>(index: number): TControl | null;
    /** @inheritdoc */
    protected onBlurred(source: HardwareUiControl<E, P>): void;
    /**
     * Responds to when a list item is focused.
     */
    private onItemFocused;
    /**
     * Renders the complete list of data items as control components.
     */
    private renderList;
    /**
     * Renders the control list scroll bar.
     */
    protected abstract renderScrollbar(): VNode;
    /** @inheritdoc */
    render(): VNode;
}

/**
 * A parameter object for HorizonProjection.
 */
declare type HorizonProjectionParameters = {
    /** The position of the airplane. */
    readonly position?: LatLonInterface;
    /** The altitude of the airplane, in meters above mean sea level. */
    readonly altitude?: number;
    /** The true heading of the airplane, in degrees. */
    readonly heading?: number;
    /** The pitch of the airplane, in degrees. */
    readonly pitch?: number;
    /** The roll of the airplane, in degrees. */
    readonly roll?: number;
    /**
     * The offset of the projection camera relative to the airplane, as `[x, y, z]` in meters using the airplane's
     * coordinate system. The positive z axis points in the forward direction of the airplane, the positive x axis points
     * in the upward direction, and the positive y axis points to the right.
     */
    readonly offset?: ReadonlyFloat64Array;
    /** The size of the projected window, as `[x, y]` in pixels. */
    readonly projectedSize?: ReadonlyFloat64Array;
    /** The field of view, in degrees. */
    readonly fov?: number;
    /**
     * The projected endpoints at which to measure the field of view, as `[x1, y1, x2, y2]`, with each component
     * expressed relative to the width or height of the projected window.
     */
    readonly fovEndpoints?: ReadonlyFloat64Array;
    /** The offset of the center of the projection, as `[x, y]` in pixels. */
    readonly projectedOffset?: ReadonlyFloat64Array;
};
/**
 * The different types of horizon projection changes.
 */
declare enum HorizonProjectionChangeType {
    Position = 1,
    Altitude = 2,
    Heading = 4,
    Pitch = 8,
    Roll = 16,
    Offset = 32,
    ProjectedSize = 64,
    Fov = 128,
    FovEndpoints = 256,
    ScaleFactor = 512,
    ProjectedOffset = 1024,
    OffsetCenterProjected = 2048
}
/**
 * A change listener callback for a HorizonProjection.
 */
interface HorizonProjectionChangeListener {
    (source: HorizonProjection, changeFlags: number): void;
}
/**
 * A perspective projection from the point of view of an airplane.
 */
declare class HorizonProjection {
    private static readonly vec2Cache;
    private static readonly vec3Cache;
    private static readonly geoPointCache;
    private readonly position;
    private altitude;
    private heading;
    private roll;
    private pitch;
    private readonly offset;
    private readonly projectedSize;
    private fov;
    private readonly fovEndpoints;
    private scaleFactor;
    private readonly projectedOffset;
    private readonly offsetCenterProjected;
    private readonly positionAngleTransforms;
    private readonly altitudeTransform;
    private readonly positionAltitudeTransforms;
    private readonly positionTransform;
    private readonly planeAngles;
    private readonly planeAngleTransforms;
    private readonly planeTransform;
    private readonly cameraPos;
    private readonly surfacePos;
    private readonly perspectiveTransform;
    private readonly oldParameters;
    private readonly queuedParameters;
    private updateQueued;
    private readonly changeEvent;
    /**
     * Constructor.
     * @param projectedWidth The initial projected width of the projection, in pixels.
     * @param projectedHeight The initial projected height of the projection, in pixels.
     * @param fov The initial field of view of the projection, in degrees.
     */
    constructor(projectedWidth: number, projectedHeight: number, fov: number);
    /**
     * Gets the position of this projection.
     * @returns The position of this projection.
     */
    getPosition(): GeoPointReadOnly;
    /**
     * Gets the altitude of this projection, in meters above mean sea level.
     * @returns The altitude of this projection, in meters above mean sea level.
     */
    getAltitude(): number;
    /**
     * Gets the true heading of this projection, in degrees.
     * @returns The true heading of this projection, in degrees.
     */
    getHeading(): number;
    /**
     * Gets the pitch of this projection, in degrees.
     * @returns The pitch of this projection, in degrees.
     */
    getPitch(): number;
    /**
     * Gets the roll of this projection, in degrees.
     * @returns The roll of this projection, in degrees.
     */
    getRoll(): number;
    /**
     * Gets the size of the projected window, as `[width, height]` in pixels.
     * @returns The size of the projected window, as `[width, height]` in pixels.
     */
    getProjectedSize(): ReadonlyFloat64Array;
    /**
     * Gets the field of view of this projection, in degrees.
     * @returns The field of view of this projection, in degrees.
     */
    getFov(): number;
    /**
     * Gets the projected endpoints at which the field of view is measured, as `[x1, y1, x2, y2]`, with each component
     * expressed relative to the width or height of the projected window.
     * @returns The projected endpoints at which the field of view is measured, as `[x1, y1, x2, y2]`, with each
     * component expressed relative to the width or height of the projected window.
     */
    getFovEndpoints(): ReadonlyFloat64Array;
    /**
     * Gets the focal length of this projection, in meters. The focal length is set such that one meter at a distance
     * from the camera equal to the focal length subtends an angle equal to the field of view.
     * @returns The focal length of this projection, in meters.
     */
    getFocalLength(): number;
    /**
     * Gets the nominal scale factor of this projection. At a distance from the camera equal to the focal length, one
     * meter will be projected to a number of pixels equal to the nominal scale factor.
     * @returns The nominal scale factor of this projection.
     */
    getScaleFactor(): number;
    /**
     * Gets the projected offset of this projection's center, as `[x, y]` in pixels.
     * @returns The projected offset of this projection's center, as `[x, y]` in pixels.
     */
    getProjectedOffset(): ReadonlyFloat64Array;
    /**
     * Gets the projected center of this projection, including offset, as `[x, y]` in pixels.
     * @returns The projected center of this projection, including offset, as `[x, y]` in pixels.
     */
    getOffsetCenterProjected(): ReadonlyFloat64Array;
    /**
     * Recomputes this projection's computed parameters.
     */
    private recompute;
    /**
     * Sets this projection's parameters. Parameters not explicitly defined in the parameters argument will be left
     * unchanged.
     * @param parameters The new parameters.
     */
    set(parameters: HorizonProjectionParameters): void;
    /**
     * Sets the projection parameters to be applied when `applyQueued()` is called.
     * @param parameters The parameter changes to queue.
     */
    setQueued(parameters: HorizonProjectionParameters): void;
    /**
     * Applies the set of queued projection changes, if any are queued.
     */
    applyQueued(): void;
    /**
     * Stores this projection's current parameters into a record.
     * @param record The record in which to store the parameters.
     */
    private storeParameters;
    /**
     * Computes change flags given a set of old parameters.
     * @param oldParameters The old parameters.
     * @returns Change flags based on the specified old parameters.
     */
    private computeChangeFlags;
    /**
     * Computes change flags for derived parameters given a set of old parameters.
     * @param oldParameters The old parameters.
     * @returns Change flags for derived parameters based on the specified old parameters.
     */
    private computeDerivedChangeFlags;
    /**
     * Subscribes a change listener to this projection. The listener will be called every time this projection changes.
     * A listener can be subscribed multiple times; it will be called once for every time it is registered.
     * @param listener The change listener to subscribe.
     * @returns The new subscription.
     */
    onChange(listener: HorizonProjectionChangeListener): Subscription;
    /**
     * Projects a point represented by a set of lat/lon coordinates and altitude.
     * @param position The lat/lon coordinates of the point to project.
     * @param altitude The altitude of the point to project, in meters.
     * @param out The 2D vector to which to write the result.
     * @returns The projected point, as `[x, y]` in pixels.
     */
    project(position: LatLonInterface, altitude: number, out: Float64Array): Float64Array;
    /**
     * Projects a point relative to the position of the airplane in spherical space.
     * @param bearing The true bearing of the point to project relative to the airplane, in degrees.
     * @param distance The geodetic horizontal distance from the point to project to the airplane, in meters.
     * @param height The geodetic height of the point to project relative to the airplane, in meters.
     * @param out The 2D vector to which to write the result.
     * @returns The projected point, as `[x, y]` in pixels.
     */
    projectRelativeSpherical(bearing: number, distance: number, height: number, out: Float64Array): Float64Array;
    /**
     * Projects a point relative to the position of the airplane in Euclidean space. The coordinate system is defined at
     * the position of the airplane, with the vertical axis perpendicular to the surface of the Earth and the horizontal
     * plane parallel to the Earth's surface at the point directly underneath the airplane.
     * @param bearing The true bearing of the point to project relative to the airplane, in degrees.
     * @param distance The Euclidean horizontal distance from the point to project to the airplane, in meters.
     * @param height The Euclidean height of the point to project relative to the airplane, in meters.
     * @param out The 2D vector to which to write the result.
     * @returns The projected point, as `[x, y]` in pixels.
     */
    projectRelativeEuclidean(bearing: number, distance: number, height: number, out: Float64Array): Float64Array;
    /**
     * Projects a 3D vector defined relative to the airplane, as `[x, y, z]` in meters with the coordinate system
     * defined as follows for an airplane with heading/roll/pitch of zero degrees:
     * * The positive z axis points in the direction of the airplane.
     * * The positive x axis points directly upward.
     * * The positive y axis points to the right.
     * @param vec The vector to project.
     * @param out The 2D vector to which to write the result.
     * @returns The projected vector.
     */
    private projectRelativeVec;
    /**
     * Checks whether a point falls within certain projected bounds.
     * @param point The lat/lon coordinates of the point to check.
     * @param altitude The altitude of the point to check, in meters.
     * @param bounds The bounds to check against, expressed as `[left, top, right, bottom]` in pixels. Defaults to the
     * bounds of the projected window.
     * @returns Whether the point falls within the projected bounds.
     */
    isInProjectedBounds(point: LatLonInterface, altitude: number, bounds?: ReadonlyFloat64Array): boolean;
    /**
     * Checks whether a projected point falls within certain projected bounds.
     * @param point The projected point to check, as `[x, y]` in pixels.
     * @param bounds The bounds to check against, expressed as `[left, top, right, bottom]` in pixels. Defaults to the
     * bounds of the projected window.
     * @returns Whether the point falls within the projected bounds.
     */
    isInProjectedBounds(point: ReadonlyFloat64Array, bounds?: ReadonlyFloat64Array): boolean;
}

/**
 * Component props for HorizonLayer.
 */
interface HorizonLayerProps extends ComponentProps {
    /** The layer's horizon projection. */
    projection: HorizonProjection;
    /**
     * A subscribable which provides the maximum update frequency of the layer, in hertz. Note that the actual update
     * frequency will not exceed the update frequency of the layer's parent map. If not defined, the frequency will
     * default to that of the layer's parent map.
     */
    updateFreq?: Subscribable<number>;
}
/**
 * A base component for horizon layers.
 */
declare abstract class HorizonLayer<P extends HorizonLayerProps = HorizonLayerProps> extends DisplayComponent<P> {
    private _isAttached;
    private _isVisible;
    /**
     * Checks whether this layer is attached to a horizon component.
     * @returns Whether this layer is attached to a horizon component.
     */
    protected isAttached(): boolean;
    /**
     * Checks whether this layer is visible.
     * @returns whether this layer is visible.
     */
    isVisible(): boolean;
    /**
     * Sets this layer's visibility.
     * @param val Whether this layer should be visible.
     */
    setVisible(val: boolean): void;
    /**
     * This method is called when this layer's visibility changes.
     * @param isVisible Whether the layer is now visible.
     */
    protected onVisibilityChanged(isVisible: boolean): void;
    /**
     * This method is called when this layer is attached to its parent horizon component.
     */
    onAttached(): void;
    /**
     * This method is called when this layer's parent horizon component is awakened.
     */
    onWake(): void;
    /**
     * This method is called when this layer's parent horizon component is put to sleep.
     */
    onSleep(): void;
    /**
     * This method is called when this layer's horizon projection changes.
     * @param projection This layer's horizon projection.
     * @param changeFlags The types of changes made to the projection.
     */
    onProjectionChanged(projection: HorizonProjection, changeFlags: number): void;
    /**
     * This method is called once every update cycle.
     * @param time The current time as a UNIX timestamp.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    onUpdated(time: number, elapsed: number): void;
    /**
     * This method is called when this layer is detached from its parent horizon component.
     */
    onDetached(): void;
}

/**
 * Component props for HorizonComponent.
 */
interface HorizonComponentProps extends ComponentProps {
    /** The size, as `[width, height]` in pixels, of the horizon component's projected window. */
    projectedSize: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /** The field of view, in degrees, of the horizon component's projected window. */
    fov: number | Subscribable<number>;
    /**
     * The projected endpoints at which to measure the field of view as `[x1, y1, x2, y2]` with each component expressed
     * relative to the width or height of the projected window. Defaults to `[0.5, 0, 0.5, 1]`.
     */
    fovEndpoints?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /** The projected offset of the center of the projection, as `[x, y]` in pixels. Defaults to `[0, 0]`. */
    projectedOffset?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /** A projection to inject. A default will be used if none is provided. */
    projection?: HorizonProjection;
    /** CSS class(es) to apply to the root of the horizon component. */
    class?: string | SubscribableSet<string>;
}
/**
 * A component which displays an artificial horizon. A horizon tracks the position, altitude, heading, pitch, and roll
 * of an airplane and uses a persepctive projection to project points in space to a planar pixel grid. Each horizon
 * component maintains a {@link HorizonComponent} instance which handles the details of the projection.
 * {@link HorizonLayer} objects added to the horizon as children determine what is drawn in the horizon window.
 */
declare class HorizonComponent<P extends HorizonComponentProps = HorizonComponentProps> extends DisplayComponent<P> {
    /**
     * This horizon component's projection.
     */
    readonly projection: HorizonProjection;
    private readonly layerEntries;
    private readonly projectedSize;
    private readonly fov;
    private readonly fovEndpoints?;
    private readonly projectedOffset?;
    private lastUpdateTime;
    private _isAwake;
    private projectedSizeSub?;
    private fovSub?;
    private fovEndpointsSub?;
    private projectedOffsetSub?;
    /** @inheritdoc */
    constructor(props: P);
    /**
     * Gets the size of this map's projected window, in pixels.
     * @returns The size of this map's projected window.
     */
    getProjectedSize(): ReadonlyFloat64Array;
    /**
     * Whether this horizon is awake.
     */
    get isAwake(): boolean;
    /**
     * Puts this horizon to sleep. While asleep, this horizon will not be updated.
     */
    sleep(): void;
    /**
     * Wakes this horizon, allowing it to be updated.
     */
    wake(): void;
    /**
     * Sets this horizon's awake state. If the new awake state is the same as the current state, nothing will happen.
     * Otherwise, this horizon's layers will be notified that the map has either been woken or put to sleep.
     * @param isAwake The new awake state.
     */
    private setAwakeState;
    /** @inheritdoc */
    onAfterRender(thisNode: VNode): void;
    /**
     * Scans this component's VNode sub-tree for HorizonLayer components and attaches them when found. Only the top-most
     * level of HorizonLayer components are attached; layers that are themselves children of other layers are not
     * attached.
     * @param thisNode This component's VNode.
     */
    protected attachLayers(thisNode: VNode): void;
    /**
     * This method is called when this horizon is awakened.
     */
    protected onWake(): void;
    /**
     * Calls the onWake() method of this horizon's layers.
     */
    protected wakeLayers(): void;
    /**
     * This method is called when this horizon is put to sleep.
     */
    protected onSleep(): void;
    /**
     * Calls the onSleep() method of this horizon's layers.
     */
    protected sleepLayers(): void;
    /**
     * This method is called when this horizon's projection changes.
     * @param projection This horizon's projection.
     * @param changeFlags The types of changes made to the projection.
     */
    protected onProjectionChanged(projection: HorizonProjection, changeFlags: number): void;
    /**
     * This method is called when the size of this horizon's projected window changes.
     */
    protected onProjectedSizeChanged(): void;
    /**
     * Attaches a layer to this horizon component. If the layer is already attached, then this method has no effect.
     * @param layer The layer to attach.
     */
    protected attachLayer(layer: HorizonLayer): void;
    /**
     * Detaches a layer from this horizon component.
     * @param layer The layer to detach.
     * @returns Whether the layer was succesfully detached.
     */
    protected detachLayer(layer: HorizonLayer): boolean;
    /**
     * Updates this horizon.
     * @param time The current real time as a UNIX timestamp in milliseconds.
     */
    update(time: number): void;
    /**
     * This method is called once every update cycle.
     * @param time The current real time as a UNIX timestamp in milliseconds.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    protected onUpdated(time: number, elapsed: number): void;
    /**
     * Updates this horizon's attached layers.
     * @param time The current real time as a UNIX timestamp in milliseconds.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    protected updateLayers(time: number, elapsed: number): void;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Properties for a MapCanvasLayer.
 */
interface HorizonCanvasLayerProps extends HorizonLayerProps {
    /** Whether to include an offscreen buffer. False by default. */
    useBuffer?: boolean;
    /** CSS class(es) to apply to the canvas element. */
    class?: string | SubscribableSet<string>;
}
/**
 * An instance of a canvas within a MapCanvasLayer.
 */
interface HorizonCanvasLayerCanvasInstance {
    /** This instance's canvas element. */
    readonly canvas: HTMLCanvasElement;
    /** This instance's canvas 2D rendering context. */
    readonly context: CanvasRenderingContext2D;
    /** Whether this instance's canvas is displayed. */
    readonly isDisplayed: boolean;
    /** Clears this canvas. */
    clear(): void;
    /**
     * Resets this instance's canvas. This will erase the canvas of all drawn pixels, reset its state (including all
     * styles, transformations, and cached paths), and clear the Coherent GT command buffer associated with it.
     */
    reset(): void;
}
/**
 * An implementation of MapCanvasLayerCanvasInstance.
 */
declare class HorizonCanvasLayerCanvasInstanceClass implements HorizonCanvasLayerCanvasInstance {
    readonly canvas: HTMLCanvasElement;
    readonly context: CanvasRenderingContext2D;
    readonly isDisplayed: boolean;
    /**
     * Creates a new canvas instance.
     * @param canvas The canvas element.
     * @param context The canvas 2D rendering context.
     * @param isDisplayed Whether the canvas is displayed.
     */
    constructor(canvas: HTMLCanvasElement, context: CanvasRenderingContext2D, isDisplayed: boolean);
    /** @inheritdoc */
    clear(): void;
    /** @inheritdoc */
    reset(): void;
}
/**
 * A layer which uses a canvas to draw graphics.
 */
declare class HorizonCanvasLayer<P extends HorizonCanvasLayerProps = HorizonCanvasLayerProps, C extends HorizonCanvasLayerCanvasInstance = HorizonCanvasLayerCanvasInstance> extends HorizonLayer<P> {
    private readonly displayCanvasRef;
    private width;
    private height;
    private displayCanvasContext;
    private _display?;
    private _buffer?;
    protected isInit: boolean;
    /**
     * Gets this layer's display canvas instance.
     * @returns This layer's display canvas instance.
     * @throws Error if this layer's display canvas instance has not been initialized.
     */
    get display(): C;
    /**
     * Gets this layer's buffer canvas instance.
     * @returns This layer's buffer canvas instance.
     * @throws Error if this layer's buffer canvas instance has not been initialized.
     */
    get buffer(): C;
    /**
     * Attempts to get this layer's display canvas instance.
     * @returns This layer's display canvas instance, or undefined if it has not been initialized.
     */
    tryGetDisplay(): C | undefined;
    /**
     * Attempts to get this layer's buffer canvas instance.
     * @returns This layer's buffer canvas instance, or undefined if it has not been initialized.
     */
    tryGetBuffer(): C | undefined;
    /**
     * Gets the width of the canvas element, in pixels.
     * @returns the width of the canvas element.
     */
    getWidth(): number;
    /**
     * Gets the height of the canvas element, in pixels.
     * @returns the height of the canvas element.
     */
    getHeight(): number;
    /**
     * Sets the width of the canvas element, in pixels.
     * @param width The new width.
     */
    setWidth(width: number): void;
    /**
     * Sets the height of the canvas element, in pixels.
     * @param height The new height.
     */
    setHeight(height: number): void;
    /**
     * Copies the contents of the buffer to the display. Has no effect if this layer does not have a buffer.
     */
    copyBufferToDisplay(): void;
    /**
     * A callback called after the component renders.
     */
    onAfterRender(): void;
    /** @inheritdoc */
    protected onVisibilityChanged(): void;
    /** @inheritdoc */
    onAttached(): void;
    /**
     * Initializes this layer's canvas instances.
     */
    private initCanvasInstances;
    /**
     * Creates a canvas instance.
     * @param canvas The canvas element.
     * @param context The canvas 2D rendering context.
     * @param isDisplayed Whether the canvas is displayed.
     * @returns a canvas instance.
     */
    protected createCanvasInstance(canvas: HTMLCanvasElement, context: CanvasRenderingContext2D, isDisplayed: boolean): C;
    /**
     * Updates the canvas element's size.
     */
    protected updateCanvasSize(): void;
    /**
     * Updates the visibility of the display canvas.
     */
    private updateCanvasVisibility;
    /** @inheritdoc */
    render(): VNode;
}

/**
 * A canvas horizon layer whose size and position is synced with the horizon projection window.
 */
declare class HorizonSyncedCanvasLayer extends HorizonCanvasLayer<HorizonCanvasLayerProps> {
    /** @inheritdoc */
    onAttached(): void;
    /**
     * Updates this layer according to the current size of the horizon projected window.
     * @param projectedSize The size of the horizon projected window.
     */
    private updateFromProjectedSize;
    /** @inheritdoc */
    onMapProjectionChanged(projection: HorizonProjection, changeFlags: number): void;
}

/**
 * A model for maps. Specific functionality is added by adding one or more modules to the model. Each module added to
 * the model is assigned a name which is used to retrieve it from the model.
 */
declare class MapModel<M> {
    private readonly modules;
    /**
     * Gets a module from this model.
     * @param name The name of the module.
     * @returns A module.
     */
    getModule<K extends keyof M & string>(name: K): M[K];
    /**
     * Gets a module instance from the model and assigns it
     * to the provided type.
     * @param module The module to get.
     * @returns The requested map data module.
     */
    getModule<T>(module: new (...args: any) => T): T;
    /**
     * Adds a module to this model.
     * @param name The name of the module to add.
     * @param module The module to add.
     */
    addModule<K extends keyof M & string>(name: K, module: M[K]): void;
}

/**
 * A parameter object for MapProjection.
 */
declare type MapProjectionParameters = {
    /**
     * The target of the projection. The target is guaranteed to be projected to a specific point in the projected
     * window defined by the center of the window plus the target projected offset.
     */
    target?: GeoPointInterface;
    /** The projected offset from the center of the projected window of the projection's target, in pixels. */
    targetProjectedOffset?: ReadonlyFloat64Array;
    /**
     * The range of the projection, in great-arc radians. The range is measured between the projection's two range
     * endpoints.
     */
    range?: number;
    /**
     * The endpoints used to measure the range of the projection, as a 4-tuple `[relX1, relY1, relX2, relY2]`. Each
     * component is expressed in relative projected coordinates, where `0` is the left/top of the projected window, and
     * `1` is the right/bottom of the projected window.
     */
    rangeEndpoints?: ReadonlyFloat64Array;
    /** The post-projected rotation angle, in radians. */
    rotation?: number;
    /** The size of the projected window, in pixels. */
    projectedSize?: ReadonlyFloat64Array;
};
/**
 * The different types of map projection changes.
 */
declare enum MapProjectionChangeType {
    Target = 1,
    Center = 2,
    TargetProjected = 4,
    Range = 8,
    RangeEndpoints = 16,
    ScaleFactor = 32,
    Rotation = 64,
    ProjectedSize = 128,
    ProjectedResolution = 256
}
/**
 * A change listener callback for a MapProjection.
 */
interface MapProjectionChangeListener {
    (source: MapProjection, changeFlags: number): void;
}
/**
 * A geographic projection model for a map. MapProjection uses a mercator projection.
 */
declare class MapProjection {
    private static readonly SCALE_FACTOR_MAX_ITER;
    private static readonly SCALE_FACTOR_TOLERANCE;
    private static readonly tempVec2_1;
    private static readonly tempVec2_2;
    private static readonly tempVec2_3;
    private static readonly tempVec2_4;
    private static readonly tempGeoPoint_1;
    private static readonly tempGeoPoint_2;
    private readonly geoProjection;
    private readonly target;
    private readonly targetProjectedOffset;
    private readonly targetProjected;
    private range;
    private readonly rangeEndpoints;
    private readonly projectedSize;
    private readonly center;
    private readonly centerProjected;
    private projectedRange;
    private widthRange;
    private heightRange;
    private readonly oldParameters;
    private readonly queuedParameters;
    private updateQueued;
    private readonly changeListeners;
    /**
     * Creates a new map projection.
     * @param projectedWidth The initial width of the projection window, in pixels.
     * @param projectedHeight The initial height of the projection window, in pixels.
     */
    constructor(projectedWidth: number, projectedHeight: number);
    /**
     * Gets this map projection's GeoProjection instance.
     * @returns This map projection's GeoProjection instance.
     */
    getGeoProjection(): GeoProjection;
    /**
     * Gets the target geographic point of this projection. The target is guaranteed to be projected to a specific
     * point in the projected window defined by the center of the window plus the target projected offset.
     * @returns The target geographic point of this projection.
     */
    getTarget(): GeoPointReadOnly;
    /**
     * Gets the projected offset from the center of the projected window of the target of this projection.
     * @returns The projected offset from the center of the projected window of the target of this projection.
     */
    getTargetProjectedOffset(): ReadonlyFloat64Array;
    /**
     * Gets the projected location of the target of this projection.
     * @returns The projected location of the target of this projection.
     */
    getTargetProjected(): ReadonlyFloat64Array;
    /**
     * Gets the range of this projection, in great-arc radians, as measured between the projection's two range endpoints.
     * @returns The range of this projection, in great-arc radians.
     */
    getRange(): number;
    /**
     * Gets the endpoints used to measure the range of the projection, as a 4-tuple `[relX1, relY1, relX2, relY2]`. Each
     * component is expressed in relative projected coordinates, where `0` is the left/top of the projected window, and
     * `1` is the right/bottom of the projected window.
     * @returns The endpoints used to measure the range of the projection, as a 4-tuple `[relX1, relY1, relX2, relY2]`.
     */
    getRangeEndpoints(): ReadonlyFloat64Array;
    /**
     * Gets the range of this projection, in great-arc radians, as measured from the center-left to the center-right of
     * the projected window.
     * @returns The range of this projection's projected window width, in great-arc radians.
     */
    getWidthRange(): number;
    /**
     * Gets the range of this projection, in great-arc radians, as measured from the top-center to the bottom-center of
     * the projected window.
     * @returns The range of this projection's projected window height, in great-arc radians.
     */
    getHeightRange(): number;
    /**
     * Gets the nominal scale factor of this projection. At a scale factor of 1, a distance of one great-arc radian will
     * be projected to a distance of one pixel.
     * @returns The nominal scale factor of this projection.
     */
    getScaleFactor(): number;
    /**
     * Gets the post-projected (planar) rotation angle of this projection in radians.
     * @returns The post-projected rotation angle of this projection.
     */
    getRotation(): number;
    /**
     * Gets the size of the projected window, in pixels.
     * @returns The size of the projected window.
     */
    getProjectedSize(): ReadonlyFloat64Array;
    /**
     * Gets the geographic point located at the center of this projection's projected window.
     * @returns The geographic point located at the center of this projection's projected window.
     */
    getCenter(): GeoPointReadOnly;
    /**
     * Gets the center of this projection's projected window.
     * @returns The center of this projection's projected window.
     */
    getCenterProjected(): ReadonlyFloat64Array;
    /**
     * Gets the average resolution, in great-arc radians per pixel, of the projected map along a line between the range
     * endpoints.
     * @returns The average resolution of the projected map along a line between the range endpoints.
     */
    getProjectedResolution(): number;
    /**
     * Calculates the true range of this projection, in great-arc radians, given a hypothetical projected center point.
     * @param centerProjected The projected location of the hypothetical center point to use for the calculation.
     * @returns The true range of this projection given the hypothetical projected center point.
     */
    private calculateRangeAtCenter;
    /**
     * Recomputes this projection's computed parameters.
     */
    private recompute;
    /**
     * Sets this projection's parameters. Parameters not explicitly defined in the parameters argument will be left
     * unchanged.
     * @param parameters The new parameters.
     */
    set(parameters: MapProjectionParameters): void;
    /**
     * Sets the projection parameters to be applied when applyQueued() is called.
     * @param parameters The parameter changes to queue.
     */
    setQueued(parameters: MapProjectionParameters): void;
    /**
     * Applies the set of queued projection changes, if any are queued.
     */
    applyQueued(): void;
    /**
     * Sets the size of the projected window.
     * @param size The new size, in pixels.
     */
    private setProjectedSize;
    /**
     * Sets the projected offset from the center of the projected window of the target of this projection.
     * @param offset The new offset, in pixels.
     */
    private setTargetProjectedOffset;
    /**
     * Stores this projection's current parameters into a record.
     * @param record The record in which to store the parameters.
     */
    private storeParameters;
    /**
     * Computes change flags given a set of old parameters.
     * @param oldParameters The old parameters.
     * @returns Change flags based on the specified old parameters.
     */
    private computeChangeFlags;
    /**
     * Projects a set of lat/lon coordinates.
     * @param point The point to project.
     * @param out The vector to which to write the result.
     * @returns The projected point, as a vector.
     */
    project(point: LatLonInterface, out: Float64Array): Float64Array;
    /**
     * Inverts a set of projected coordinates. This method will determine the geographic point whose projected location
     * is the equal to that described by a 2D position vector.
     * @param vec The 2D position vector describing the location of the projected coordinates.
     * @param out The point to which to write the result.
     * @returns The inverted point.
     */
    invert(vec: ReadonlyFloat64Array, out: GeoPoint): GeoPoint;
    /**
     * Checks whether a point falls within certain projected bounds. The point can be specified as either a GeoPoint
     * object or a 2D vector. If a GeoPoint object is supplied, it will be projected before the bounds check takes
     * place.
     * @param point The point to check.
     * @param bounds The bounds to check against, expressed as a vector ([left, top, right, bottom]). Defaults to the
     * bounds of the projected window.
     * @returns Whether the point falls within the projected bounds.
     */
    isInProjectedBounds(point: LatLonInterface | ReadonlyFloat64Array, bounds?: ReadonlyFloat64Array): boolean;
    /**
     * Gets the geographic great-circle distance between two points in great-arc radians. The points can be specified as
     * either GeoPoint objects or 2D vectors. If 2D vectors are supplied, they are interpreted as projected points and
     * inverse projection will be used to convert them to geographic points.
     * @param point1 The first point.
     * @param point2 The second point.
     * @returns The geographic great-circle distance between the points.
     */
    geoDistance(point1: GeoPointInterface | ReadonlyFloat64Array, point2: GeoPointInterface | ReadonlyFloat64Array): number;
    /**
     * Gets the projected Euclidean distance between two points in pixels. The points can be specified as either GeoPoint
     * objects or 2D vectors. If GeoPoint objects are supplied, they will be projected to convert them to projected
     * points.
     * @param point1 The first point.
     * @param point2 The second point.
     * @returns The projected Euclidean distance between two points.
     */
    projectedDistance(point1: GeoPointInterface | ReadonlyFloat64Array, point2: GeoPointInterface | ReadonlyFloat64Array): number;
    /**
     * Notifies all registered change listeners that this projection has been changed.
     * @param changeFlags The types of changes that were made.
     */
    protected notifyChangeListeners(changeFlags: number): void;
    /**
     * Registers a change listener with this projection. The listener will be called every time this projection changes.
     * A listener can be registered multiple times; it will be called once for every time it is registered.
     * @param listener The change listener to register.
     */
    addChangeListener(listener: MapProjectionChangeListener): void;
    /**
     * Removes a change listener from this projection. If the specified listener was registered multiple times, this
     * method will only remove one instance of the listener.
     * @param listener The listener to remove.
     * @returns Whether the listener was successfully removed.
     */
    removeChangeListener(listener: MapProjectionChangeListener): boolean;
}

/**
 * An interface for basic map layer properties.
 */
interface MapLayerProps<M> extends ComponentProps {
    /** A map model. */
    model: MapModel<M>;
    /** A map projection model. */
    mapProjection: MapProjection;
    /**
     * A subscribable which provides the maximum update frequency of the layer, in hertz. Note that the actual update
     * frequency will not exceed the update frequency of the layer's parent map. If not defined, the frequency will
     * default to that of the layer's parent map.
     */
    updateFreq?: Subscribable<number>;
    /** The CSS class(es) to apply to the root of this layer. */
    class?: string | SubscribableSet<string>;
}
/**
 * A base component for map layers.
 */
declare abstract class MapLayer<P extends MapLayerProps<any> = MapLayerProps<any>> extends DisplayComponent<P> {
    private _isVisible;
    /**
     * Checks whether this layer is visible.
     * @returns whether this layer is visible.
     */
    isVisible(): boolean;
    /**
     * Sets this layer's visibility.
     * @param val Whether this layer should be visible.
     */
    setVisible(val: boolean): void;
    /**
     * This method is called when this layer's visibility changes.
     * @param isVisible Whether the layer is now visible.
     */
    onVisibilityChanged(isVisible: boolean): void;
    /**
     * This method is called when this layer is attached to its parent map component.
     */
    onAttached(): void;
    /**
     * This method is called when this layer's parent map is woken.
     */
    onWake(): void;
    /**
     * This method is called when this layer's parent map is put to sleep.
     */
    onSleep(): void;
    /**
     * This method is called when the map projection changes.
     * @param mapProjection - this layer's map projection.
     * @param changeFlags The types of changes made to the projection.
     */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /**
     * This method is called once every map update cycle.
     * @param time The current time as a UNIX timestamp.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    onUpdated(time: number, elapsed: number): void;
    /**
     * This method is called when this layer is detached from its parent map component.
     */
    onDetached(): void;
}

/**
 * Component props for MapComponent.
 */
interface MapComponentProps<M> extends ComponentProps {
    /** A map model. */
    model: MapModel<M>;
    /** The event bus. */
    bus: EventBus;
    /** The update frequency of the map, in hertz. */
    updateFreq?: Subscribable<number>;
    /** The size, as `[width, height]` in pixels, of the map component's projected window. */
    projectedSize: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /** A projection to inject. A default will be used if none is provided. */
    projection?: MapProjection;
}
/**
 * A component which displays a map. A map projects geographic coordinates onto a planar pixel grid. Each map component
 * maintains a MapProjection instance which handles the details of the projection. MapLayer objects added to the map
 * as children determine what is drawn on the map.
 */
declare abstract class MapComponent<P extends MapComponentProps<any> = MapComponentProps<any>> extends DisplayComponent<P> {
    /**
     * This map component's projection model.
     */
    readonly mapProjection: MapProjection;
    private readonly layerEntries;
    private readonly projectedSize;
    private lastUpdateTime;
    private _isAwake;
    private updateCycleSub?;
    private readonly updateCycleHandler;
    private projectedSizeSub?;
    /** @inheritdoc */
    constructor(props: P);
    /**
     * Gets the size of this map's projected window, in pixels.
     * @returns The size of this map's projected window.
     */
    getProjectedSize(): ReadonlyFloat64Array;
    /**
     * Whether this map is awake.
     */
    get isAwake(): boolean;
    /**
     * Puts this map to sleep. While asleep, this map will not be updated.
     */
    sleep(): void;
    /**
     * Wakes this map, allowing it to be updated.
     */
    wake(): void;
    /**
     * Sets this map's awake state. If the new awake state is the same as the current state, nothing will happen.
     * Otherwise, this map's layers will be notified that the map has either been woken or put to sleep.
     * @param isAwake The new awake state.
     */
    private setAwakeState;
    /** @inheritdoc */
    onAfterRender(thisNode: VNode): void;
    /**
     * Scans this component's VNode sub-tree for MapLayer components and attaches them when found. Only the top-most
     * level of MapLayer components are attached; layers that are themselves children of other layers are not attached.
     * @param thisNode This component's VNode.
     */
    protected attachLayers(thisNode: VNode): void;
    /**
     * This method is called when the map is awakened.
     */
    protected onWake(): void;
    /**
     * Calls the onWake() method of this map's layers.
     */
    protected wakeLayers(): void;
    /**
     * This method is called when the map is put to sleep.
     */
    protected onSleep(): void;
    /**
     * Calls the onSleep() method of this map's layers.
     */
    protected sleepLayers(): void;
    /**
     * This method is called when the map projection changes.
     * @param mapProjection This layer's map projection.
     * @param changeFlags The types of changes made to the projection.
     */
    protected onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /**
     * This method is called when the size of this map's projected window changes.
     */
    protected abstract onProjectedSizeChanged(): void;
    /**
     * Attaches a layer to this map component. If the layer is already attached, then this method has no effect.
     * @param layer The layer to attach.
     */
    protected attachLayer(layer: MapLayer): void;
    /**
     * Detaches a layer from this map component.
     * @param layer The layer to detach.
     * @returns Whether the layer was succesfully detached.
     */
    protected detachLayer(layer: MapLayer): boolean;
    /**
     * Updates this map.
     * @param time The current real time as a UNIX timestamp in milliseconds.
     */
    update(time: number): void;
    /**
     * This method is called once every update cycle.
     * @param time The current real time as a UNIX timestamp in milliseconds.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    protected onUpdated(time: number, elapsed: number): void;
    /**
     * Updates this map's attached layers.
     * @param time The current real time as a UNIX timestamp in milliseconds.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    protected updateLayers(time: number, elapsed: number): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * A text label to be displayed on a map.
 */
interface MapTextLabel {
    /** The text of this label. */
    readonly text: Subscribable<string>;
    /** The render priority of this label. */
    readonly priority: Subscribable<number>;
    /**
     * Draws this label to a canvas.
     * @param context The canvas rendering context to use to draw.
     * @param mapProjection The projection to use to project the location of the label.
     */
    draw(context: CanvasRenderingContext2D, mapProjection: MapProjection): void;
}
/**
 * Options for a AbstractMapTextLabel.
 */
interface AbstractMapTextLabelOptions {
    /**
     * The anchor point of the label, expressed relative to the width/height of the label. `[0, 0]` is the top-left
     * corner, and `[1, 1]` is the bottom-right corner. Defaults to `[0, 0]`.
     */
    anchor?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /** The font type of the label. Defaults to `''` (the default canvas font). */
    font?: string | Subscribable<string>;
    /** The font size of the label, in pixels. Defaults to 10 pixels. */
    fontSize?: number | Subscribable<number>;
    /** The font color of the label. Defaults to `'white'`. */
    fontColor?: string | Subscribable<string>;
    /** The font outline width of the label, in pixels. Defaults to 0. */
    fontOutlineWidth?: number | Subscribable<number>;
    /** The font outline color of the label. Defaults to `'black'`. */
    fontOutlineColor?: string | Subscribable<string>;
    /** Whether to show the background for the label. Defaults to `false`. */
    showBg?: boolean | Subscribable<boolean>;
    /** The label's background color. Defaults to `'black'`. */
    bgColor?: string | Subscribable<string>;
    /** The padding of the label's background, in pixels. Expressed as `[top, right, bottom, left]`. Defaults to `[0, 0, 0, 0]`. */
    bgPadding?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /** The border radius of the label's background, in pixels. Defaults to 0. */
    bgBorderRadius?: number | Subscribable<number>;
    /** The outline width of the label's background, in pixels. Defaults to 0. */
    bgOutlineWidth?: number | Subscribable<number>;
    /** The outline color of the label's background. Defaults to `'white'`. */
    bgOutlineColor?: string | Subscribable<string>;
}
/**
 * An abstract implementation of a map text label.
 */
declare abstract class AbstractMapTextLabel implements MapTextLabel {
    protected static readonly tempVec2: Float64Array;
    /** @inheritdoc */
    readonly text: Subscribable<string>;
    /** @inheritdoc */
    readonly priority: Subscribable<number>;
    /**
     * The anchor point of this label, expressed relative to this label's width/height. [0, 0] is the top-left corner,
     * and [1, 1] is the bottom-right corner.
     */
    readonly anchor: Subscribable<ReadonlyFloat64Array>;
    /** The font type of this label. */
    readonly font: Subscribable<string>;
    /** The font size of this label, in pixels. */
    readonly fontSize: Subscribable<number>;
    /** The font color of this label. */
    readonly fontColor: Subscribable<string>;
    /** The font outline width of this label, in pixels. */
    readonly fontOutlineWidth: Subscribable<number>;
    /** The font outline color of this label. */
    readonly fontOutlineColor: Subscribable<string>;
    /** Whether to show the background for this label. */
    readonly showBg: Subscribable<boolean>;
    /** This label's background color. */
    readonly bgColor: Subscribable<string>;
    /** The padding of this label's background, in pixels. Expressed as [top, right, bottom, left]. */
    readonly bgPadding: Subscribable<ReadonlyFloat64Array>;
    /** The border radius of this label's background. */
    readonly bgBorderRadius: Subscribable<number>;
    /** The outline width of this label's background. */
    readonly bgOutlineWidth: Subscribable<number>;
    /** The outline color of this label's background. */
    readonly bgOutlineColor: Subscribable<string>;
    /**
     * Constructor.
     * @param text The text of this label, or a subscribable which provides it.
     * @param priority The render priority of this label, or a subscribable which provides it.
     * @param options Options with which to initialize this label.
     */
    constructor(text: string | Subscribable<string>, priority: number | Subscribable<number>, options?: AbstractMapTextLabelOptions);
    draw(context: CanvasRenderingContext2D, mapProjection: MapProjection): void;
    /**
     * Gets the projected position of the label, in pixels.
     * @param mapProjection The map projection to use.
     * @param out The vector to which to write the result.
     * @returns The projected position of the label.
     */
    protected abstract getPosition(mapProjection: MapProjection, out: Float64Array): Float64Array;
    /**
     * Loads this label's text style to a canvas rendering context.
     * @param context The canvas rendering context to use.
     */
    protected setTextStyle(context: CanvasRenderingContext2D): void;
    /**
     * Draws this label's text to a canvas.
     * @param context The canvas rendering context.
     * @param centerX The x-coordinate of the center of the label, in pixels.
     * @param centerY the y-coordinate of the center of the label, in pixels.
     */
    protected drawText(context: CanvasRenderingContext2D, centerX: number, centerY: number): void;
    /**
     * Draws this label's background to a canvas.
     * @param context The canvas rendering context.
     * @param centerX The x-coordinate of the center of the label, in pixels.
     * @param centerY the y-coordinate of the center of the label, in pixels.
     * @param width The width of the background, in pixels.
     * @param height The height of the background, in pixels.
     */
    protected drawBackground(context: CanvasRenderingContext2D, centerX: number, centerY: number, width: number, height: number): void;
    /**
     * Loads the path of this label's background to a canvas rendering context.
     * @param context The canvas rendering context to use.
     * @param left The x-coordinate of the left edge of the background, in pixels.
     * @param top The y-coordinate of the top edge of the background, in pixels.
     * @param width The width of the background, in pixels.
     * @param height The height of the background, in pixels.
     * @param radius The border radius of the background, in pixels.
     */
    protected loadBackgroundPath(context: CanvasRenderingContext2D, left: number, top: number, width: number, height: number, radius: number): void;
}
/**
 * Options for a MapLocationTextLabel.
 */
interface MapLocationTextLabelOptions extends AbstractMapTextLabelOptions {
    /** The offset of the label from its projected position, as `[x, y]` in pixels. Defaults to `[0, 0]`. */
    offset?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
}
/**
 * A text label associated with a specific geographic location.
 */
declare class MapLocationTextLabel extends AbstractMapTextLabel {
    readonly location: Subscribable<GeoPointInterface>;
    readonly offset: Subscribable<ReadonlyFloat64Array>;
    /**
     * Constructor.
     * @param text The text of this label, or a subscribable which provides it.
     * @param priority The render priority of this label, or a subscribable which provides it.
     * @param location The geographic location of this label, or a subscribable which provides it.
     * @param options Options with which to initialize this label.
     */
    constructor(text: string | Subscribable<string>, priority: number | Subscribable<number>, location: GeoPointInterface | Subscribable<GeoPointInterface>, options?: MapLocationTextLabelOptions);
    /** @inheritdoc */
    protected getPosition(mapProjection: MapProjection, out: Float64Array): Float64Array;
}

/**
 * A map text label which can be culled to prevent collision with other labels.
 */
interface MapCullableTextLabel extends MapTextLabel {
    /** Whether this label is immune to culling. */
    readonly alwaysShow: Subscribable<boolean>;
    /** The bounding box of this label. */
    readonly bounds: Float64Array;
    /** An invalidation event. */
    readonly invalidation: ReadonlySubEvent<this, void>;
    /**
     * Updates this label's bounding box.
     * @param mapProjection The map projection to use.
     */
    updateBounds(mapProjection: MapProjection): void;
}
/**
 * A cullable text label associated with a specific geographic location.
 */
declare class MapCullableLocationTextLabel extends MapLocationTextLabel implements MapCullableTextLabel {
    /** @inheritdoc */
    readonly alwaysShow: Subscribable<boolean>;
    /** @inheritdoc */
    readonly bounds: Float64Array;
    /** @inheritdoc */
    readonly invalidation: SubEvent<this, void>;
    private readonly subs;
    /**
     * Constructor.
     * @param text The text of this label, or a subscribable which provides it.
     * @param priority The priority of this label, or a subscribable which provides it.
     * @param location The geographic location of this label, or a subscribable which provides it.
     * @param alwaysShow Whether this label is immune to culling, or a subscribable which provides it.
     * @param options Options with which to initialize this label.
     */
    constructor(text: string | Subscribable<string>, priority: number | Subscribable<number>, location: GeoPointInterface | Subscribable<GeoPointInterface>, alwaysShow: boolean | Subscribable<boolean>, options?: MapLocationTextLabelOptions);
    /** @inheritdoc */
    updateBounds(mapProjection: MapProjection): void;
    /**
     * Destroys this label.
     */
    destroy(): void;
}
/**
 * Manages a set of MapCullableTextLabels. Colliding labels will be culled based on their render priority. Labels with
 * lower priorities will be culled before labels with higher priorities.
 */
declare class MapCullableTextLabelManager {
    private cullingEnabled;
    private static readonly SCALE_UPDATE_THRESHOLD;
    private static readonly ROTATION_UPDATE_THRESHOLD;
    private static readonly SORT_FUNC;
    private readonly registered;
    private _visibleLabels;
    /** An array of labels registered with this manager that are visible. */
    get visibleLabels(): readonly MapCullableTextLabel[];
    private needUpdate;
    private lastScaleFactor;
    private lastRotation;
    private readonly invalidationHandler;
    /**
     * Creates an instance of the MapCullableTextLabelManager.
     * @param cullingEnabled Whether or not culling of labels is enabled.
     */
    constructor(cullingEnabled?: boolean);
    /**
     * Registers a label with this manager. Newly registered labels will be processed with the next manager update.
     * @param label The label to register.
     */
    register(label: MapCullableTextLabel): void;
    /**
     * Deregisters a label with this manager. Newly deregistered labels will be processed with the next manager update.
     * @param label The label to deregister.
     */
    deregister(label: MapCullableTextLabel): void;
    /**
     * Sets whether or not text label culling is enabled.
     * @param enabled Whether or not culling is enabled.
     */
    setCullingEnabled(enabled: boolean): void;
    /**
     * Updates this manager.
     * @param mapProjection The projection of the map to which this manager's labels are to be drawn.
     */
    update(mapProjection: MapProjection): void;
    /**
     * Checks if two bounding boxes collide.
     * @param a The first bounding box, as a 4-tuple [left, top, right, bottom].
     * @param b The second bounding box, as a 4-tuple [left, top, right, bottom].
     * @returns whether the bounding boxes collide.
     */
    private static doesCollide;
}

/**
 * A waypoint which is renderable to a map.
 */
interface MapWaypoint {
    /** This waypoint's unique string ID. */
    readonly uid: string;
    /** The location of this waypoint. */
    readonly location: Subscribable<GeoPointInterface>;
}

/**
 * An icon for a waypoint displayed on a map.
 */
interface MapWaypointIcon<T extends MapWaypoint> {
    /** The waypoint associated with this icon. */
    readonly waypoint: T;
    /**
     * The render priority of this icon. Icons with higher priorities will be rendered on top of icons with lower
     * priorities.
     */
    readonly priority: Subscribable<number>;
    /**
     * Renders this icon to a canvas.
     * @param context The canvas 2D rendering context to which to render.
     * @param mapProjection The projection to use for rendering.
     */
    draw(context: CanvasRenderingContext2D, mapProjection: MapProjection): void;
}
/**
 * A blank waypoint icon.
 */
declare class MapBlankWaypointIcon<T extends MapWaypoint> implements MapWaypointIcon<T> {
    readonly waypoint: T;
    /** @inheritdoc */
    readonly priority: Subscribable<number>;
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     */
    constructor(waypoint: T, priority: number | Subscribable<number>);
    /**
     * Does nothing.
     */
    draw(): void;
}
/**
 * Initialization options for an AbstractMapWaypointIcon.
 */
declare type AbstractMapWaypointIconOptions = {
    /**
     * The anchor point of the icon, expressed as `[x, y]` relative to its width and height. `[0, 0]` is the top-left
     * corner, and `[1, 1]` is the bottom-right corner. Defaults to `[0.5, 0.5]`.
     */
    anchor?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /**
     * The offset of the icon from the projected position of its associated waypoint, as `[x, y]` in pixels. Defaults to
     * `[0, 0]`.
     */
    offset?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
};
/**
 * An abstract implementation of MapWaypointIcon which supports an arbitrary anchor point and offset.
 */
declare abstract class AbstractMapWaypointIcon<T extends MapWaypoint> implements MapWaypointIcon<T> {
    readonly waypoint: T;
    protected static readonly tempVec2: Float64Array;
    /** @inheritdoc */
    readonly priority: Subscribable<number>;
    /** The size of this icon, as `[width, height]` in pixels. */
    readonly size: Subscribable<ReadonlyFloat64Array>;
    /**
     * The anchor point of this icon, expressed relative to its width and height. [0, 0] is the top-left corner, and
     * [1, 1] is the bottom-right corner.
     */
    readonly anchor: Subscribable<ReadonlyFloat64Array>;
    /** The offset of this icon from the projected position of its associated waypoint, as `[x, y]` in pixels. */
    readonly offset: Subscribable<ReadonlyFloat64Array>;
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon, or a subscribable which provides it. Icons with higher
     * priorities should be rendered above those with lower priorities.
     * @param size The size of this icon, as `[width, height]` in pixels, or a subscribable which provides it.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint: T, priority: number | Subscribable<number>, size: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>, options?: AbstractMapWaypointIconOptions);
    /** @inheritdoc */
    draw(context: CanvasRenderingContext2D, mapProjection: MapProjection): void;
    /**
     * Draws the icon at the specified position.
     * @param context The canvas rendering context to use.
     * @param mapProjection The map projection to use.
     * @param left The x-coordinate of the left edge of the icon.
     * @param top The y-coordinate of the top edge of the icon.
     */
    protected abstract drawIconAt(context: CanvasRenderingContext2D, mapProjection: MapProjection, left: number, top: number): void;
}
/**
 * A waypoint icon with an image as the icon's graphic source.
 */
declare class MapWaypointImageIcon<T extends MapWaypoint> extends AbstractMapWaypointIcon<T> {
    protected readonly img: HTMLImageElement;
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param img This icon's image.
     * @param size The size of this icon, as `[width, height]` in pixels, or a subscribable which provides it.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint: T, priority: number | Subscribable<number>, img: HTMLImageElement, size: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>, options?: AbstractMapWaypointIconOptions);
    /** @inheritdoc */
    protected drawIconAt(context: CanvasRenderingContext2D, mapProjection: MapProjection, left: number, top: number): void;
}
/**
 * A waypoint icon with a sprite as the icon's graphic source.
 */
declare class MapWaypointSpriteIcon<T extends MapWaypoint> extends AbstractMapWaypointIcon<T> {
    protected readonly img: HTMLImageElement;
    protected readonly frameWidth: number;
    protected readonly frameHeight: number;
    private spriteFrameHandler?;
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param img This icon's sprite's image source.
     * @param frameWidth The frame width of the sprite, in pixels.
     * @param frameHeight The frame height of the sprite, in pixels.
     * @param size The size of this icon, as `[width, height]` in pixels, or a subscribable which provides it.
     * @param options Options with which to initialize this icon.
     * @param spriteFrameHandler An optional handler to determine the sprite frame to draw.
     */
    constructor(waypoint: T, priority: number | Subscribable<number>, img: HTMLImageElement, frameWidth: number, frameHeight: number, size: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>, options?: AbstractMapWaypointIconOptions, spriteFrameHandler?: ((mapProjection: MapProjection) => number) | undefined);
    /** @inheritdoc */
    protected drawIconAt(context: CanvasRenderingContext2D, mapProjection: MapProjection, left: number, top: number): void;
    /**
     * Gets the sprite frame to render.
     * @param mapProjection The map projection to use.
     * @returns The sprite frame to render.
     */
    protected getSpriteFrame(mapProjection: MapProjection): number;
}

/**
 * A waypoint icon factory.
 */
interface MapWaypointRendererIconFactory<W extends MapWaypoint> {
    /**
     * Gets an icon for a waypoint.
     * @param role The role that was selected for the waypoint for rendering.
     * @param waypoint A waypoint.
     * @returns a waypoint icon.
     */
    getIcon<T extends W>(role: number, waypoint: T): MapWaypointIcon<T>;
}
/**
 * A waypoint label factory.
 */
interface MapWaypointRendererLabelFactory<W extends MapWaypoint> {
    /**
     * Gets a label for a waypoint.
     * @param role The role that was selected for the waypoint for rendering.
     * @param waypoint A waypoint.
     * @returns a waypoint label.
     */
    getLabel<T extends W>(role: number, waypoint: T): MapCullableTextLabel;
}
/**
 * A render role definition.
 */
declare type MapWaypointRenderRoleDef<W extends MapWaypoint> = {
    /** The icon factory used to create icons for the render role. */
    iconFactory: MapWaypointRendererIconFactory<W> | null;
    /** The label factory used to create labels for the render role. */
    labelFactory: MapWaypointRendererLabelFactory<W> | null;
    /** The canvas rendering context used to draw icons and labels for the render role. */
    canvasContext: CanvasRenderingContext2D | null;
    /** A function which determines whether a waypoint is visible under the render role. */
    visibilityHandler: (waypoint: W) => boolean;
};
/**
 * A function which selects roles under which to render waypoints.
 */
declare type MapWaypointRenderRoleSelector<W extends MapWaypoint> = (entry: MapWaypointRendererEntry<W>, roleDefinitions: ReadonlyMap<number, Readonly<MapWaypointRenderRoleDef<W>>>) => number;
/**
 * Gets the waypoint type supported by a waypoint renderer.
 */
declare type MapWaypointRendererType<Renderer> = Renderer extends MapWaypointRenderer<infer W> ? W : never;
/**
 * A renderer that draws waypoints to a map. For the renderer to draw a waypoint, the waypoint must first be registered
 * with the renderer. Waypoints may be registered under multiple render roles. Each render role is represented as a bit
 * flag. During each render cycle, a specific role is chosen for each waypoint by a selector function. Once the role is
 * chosen, the waypoint will be rendered in that role.
 */
declare class MapWaypointRenderer<W extends MapWaypoint = MapWaypoint> {
    protected readonly textManager: MapCullableTextLabelManager;
    protected readonly selectRoleToRender: MapWaypointRenderRoleSelector<W>;
    /** A null render role definition. Icons rendered under this role are never visible. */
    protected static readonly NULL_ROLE_DEF: {
        iconFactory: null;
        labelFactory: null;
        canvasContext: null;
        visibilityHandler: () => boolean;
    };
    /**
     * Sorts waypoint entries such that those with icons of higher priority are sorted after those with icons of lower
     * priority.
     * @param a The first waypoint entry to sort.
     * @param b The second waypoint entry to sort.
     * @returns A negative number if the first entry is to be sorted before the second, a positive number if the second
     * entry is to be sorted before the first, and zero if the entries' relative sorting order does not matter.
     */
    protected static readonly ENTRY_SORT_FUNC: (a: MapWaypointRendererEntry<any>, b: MapWaypointRendererEntry<any>) => number;
    /**
     * The default render role selector. For each waypoint entry, iterates through all possible render roles in the order
     * they were originally added to the renderer and selects the first role under which the entry is registered and is
     * visible.
     * @param entry A waypoint entry.
     * @param roleDefinitions A map from all possible render roles to their definitions.
     * @returns The role under which the waypoint entry should be rendered, or 0 if the entry should not be rendered
     * under any role.
     */
    static readonly DEFAULT_RENDER_ROLE_SELECTOR: <T extends MapWaypoint>(entry: MapWaypointRendererEntry<T>, roleDefinitions: ReadonlyMap<number, Readonly<MapWaypointRenderRoleDef<T>>>) => number;
    protected readonly registered: Map<string, MapWaypointRendererEntry<W>>;
    protected readonly toCleanUp: Set<MapWaypointRendererEntry<W>>;
    /**
     * This renderer's render role definitions. Waypoints assigned to be rendered under a role or combination of roles
     * with no definition will not be rendered.
     */
    protected readonly roleDefinitions: Map<number, MapWaypointRenderRoleDef<W>>;
    /**
     * Constructor.
     * @param textManager The text manager to use for waypoint labels.
     * @param selectRoleToRender A function which selects roles under which to render waypoints. Defaults to
     * {@link MapWaypointRenderer.DEFAULT_RENDER_ROLE_SELECTOR}.
     */
    constructor(textManager: MapCullableTextLabelManager, selectRoleToRender?: MapWaypointRenderRoleSelector<W>);
    /**
     * Checks whether a render role has been added to this renderer.
     * @param role The render role to check.
     * @returns Whether the render role has been added to this renderer.
     */
    hasRenderRole(role: number): boolean;
    /**
     * Adds a render role to this renderer. If the role has already been added to this renderer, this method does
     * nothing.
     * @param role The render role to add.
     * @param def The render role's definition. If undefined, the new role will be assigned a default definition with
     * no defined rendering context, icon, or label factories, and a visibility handler which always returns true.
     * @returns Whether the render role was successfully added.
     */
    addRenderRole(role: number, def?: MapWaypointRenderRoleDef<W>): boolean;
    /**
     * Removes a render role from this renderer.
     * @param role The render role to remove.
     * @returns Whether the render role was successfully removed.
     */
    removeRenderRole(role: number): boolean;
    /**
     * Gets the definition for a render role.
     * @param role A render role.
     * @returns The definition for the specified render role, or undefined if no such role has been added to this
     * renderer.
     */
    getRenderRoleDefinition(role: number): Readonly<MapWaypointRenderRoleDef<W>> | undefined;
    /**
     * Gets an iterable of render roles added to this renderer. The iterable will return the roles in the order in which
     * they were added.
     * @returns An iterable of render roles added to this renderer.
     */
    renderRoles(): IterableIterator<number>;
    /**
     * Removes all render roles from this renderer.
     */
    clearRenderRoles(): void;
    /**
     * Sets the factory to use to create waypoint icons for a render role. If the render role has not been added to this
     * renderer, this method does nothing.
     * @param role A render role.
     * @param factory A waypoint icon factory.
     * @returns Whether the factory was set.
     */
    setIconFactory(role: number, factory: MapWaypointRendererIconFactory<W>): boolean;
    /**
     * Sets the factory to use to create waypoint labels for a render role. If the render role has not been added to this
     * renderer, this method does nothing.
     * @param role A render role.
     * @param factory A waypoint label factory.
     * @returns Whether the factory was set.
     */
    setLabelFactory(role: number, factory: MapWaypointRendererLabelFactory<W>): boolean;
    /**
     * Sets the canvas rendering context for a render role. If the render role has not been added to this renderer, this
     * method does nothing.
     * @param role A render role.
     * @param context A canvas 2D rendering context.
     * @returns Whether the context was set.
     */
    setCanvasContext(role: number, context: CanvasRenderingContext2D): boolean;
    /**
     * Sets the handler that determines if a waypoint should visible for a render role. If the render role has not been
     * added to this renderer, this method does nothing.
     * @param role A render role.
     * @param handler A function that determines if a waypoint should be visible.
     * @returns Whether the handler was set.
     */
    setVisibilityHandler(role: number, handler: (waypoint: W) => boolean): boolean;
    /**
     * Checks if a waypoint is registered with this renderer. A role or roles can be optionally specified such that the
     * method will only return true if the waypoint is registered under those specific roles.
     * @param waypoint A waypoint.
     * @param role The specific role(s) to check.
     * @returns whether the waypoint is registered with this renderer.
     */
    isRegistered(waypoint: W, role?: number): boolean;
    /**
     * Registers a waypoint with this renderer under a specific role or roles. Registered waypoints will be drawn as
     * appropriate the next time this renderer's update() method is called. Registering a waypoint under a role under
     * which it is already registered has no effect unless the source of the registration is different.
     * @param waypoint The waypoint to register.
     * @param role The role(s) under which the waypoint should be registered.
     * @param sourceId A unique string ID for the source of the registration.
     */
    register(waypoint: W, role: number, sourceId: string): void;
    /**
     * Removes a registration for a waypoint for a specific role or roles. Once all of a waypoint's registrations for a
     * role are removed, it will no longer be rendered in that role the next this renderer's update() method is called.
     * @param waypoint The waypoint to deregister.
     * @param role The role(s) from which the waypoint should be deregistered.
     * @param sourceId The unique string ID for the source of the registration to remove.
     */
    deregister(waypoint: W, role: number, sourceId: string): void;
    /**
     * Deletes and cleans up a registered waypoint entry.
     * @param entry The entry to delete.
     */
    private deleteEntry;
    /**
     * Redraws waypoints registered with this renderer.
     * @param mapProjection The map projection to use.
     */
    update(mapProjection: MapProjection): void;
    /**
     * Gets the nearest waypoint currently registered in the renderer.
     * @param pos The position to get the closest waypoint to.
     * @param first A predicate that will search the list of closest waypoints for a match, and return the first one found.
     * @returns The nearest waypoint, or undefined if none found.
     */
    getNearestWaypoint<T extends W = W>(pos: LatLonInterface, first?: (waypoint: W) => boolean): T | undefined;
    /**
     * Orders waypoints by their distance to the plane PPOS.
     * @param a The first waypoint.
     * @param b The second waypoint.
     * @param pos The position to compare against.
     * @returns The comparison order number.
     */
    private orderByDistance;
}
/**
 * An entry for a waypoint registered with {@link MapWaypointRenderer}.
 */
declare class MapWaypointRendererEntry<W extends MapWaypoint> {
    readonly waypoint: W;
    private readonly textManager;
    private readonly roleDefinitions;
    private readonly selectRoleToRender;
    private readonly registrations;
    private _roles;
    private _icon;
    private _label;
    private _lastRenderedRole;
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this entry.
     * @param textManager The text manager to which to register this entry's labels.
     * @param roleDefinitions A map of all valid render roles to their definitions.
     * @param selectRoleToRender A function to use to select roles under which to render this entry.
     */
    constructor(waypoint: W, textManager: MapCullableTextLabelManager, roleDefinitions: ReadonlyMap<number, Readonly<MapWaypointRenderRoleDef<W>>>, selectRoleToRender: MapWaypointRenderRoleSelector<W>);
    /** The render role(s) assigned to this entry. */
    get roles(): number;
    /** The role under which this entry was last rendered, or 0 if this entry has not yet been rendered. */
    get lastRenderedRole(): number;
    /** This entry's waypoint icon. */
    get icon(): MapWaypointIcon<W> | null;
    /** This entry's waypoint label. */
    get label(): MapCullableTextLabel | null;
    /**
     * Checks whether this entry is assigned any of the specified render roles. Optionally, this method can also check
     * if this entry was last rendered in any of the specified roles instead.
     * @param roles The render roles against which to check.
     * @param useLastRendered Whether to check the role(s) in which this entry was last rendered instead of the current
     * roles assigned to this entry. False by default.
     * @returns whether the check passed.
     */
    isAnyRole(roles: number, useLastRendered?: boolean): boolean;
    /**
     * Checks whether this entry is assigned only the specified render role(s). Optionally, this method can also check
     * if this entry was last rendered in only the specified role(s) instead.
     * @param roles The render roles against which to check.
     * @param useLastRendered Whether to check the role(s) in which this entry was last rendered instead of the current
     * roles assigned to this entry. False by default.
     * @returns whether the check passed.
     */
    isOnlyRole(roles: number, useLastRendered?: boolean): boolean;
    /**
     * Checks whether this entry is assigned all the specified render role(s). Optionally, this method can also check
     * if this entry was last rendered in all the specified role(s) instead.
     * @param roles - the render role(s) against which to check.
     * @param useLastRendered Whether to check the role(s) in which this entry was last rendered instead of the current
     * roles assigned to this entry. False by default.
     * @returns whether the check passed.
     */
    isAllRoles(roles: number, useLastRendered?: boolean): boolean;
    /**
     * Assigns one or more render roles to this entry.
     * @param roles The render role(s) to assign.
     * @param sourceId The unique string ID of the source of the assignment.
     */
    addRole(roles: number, sourceId: string): void;
    /**
     * Removes one or more render roles from this entry.
     * @param roles The render role(s) to remove.
     * @param sourceId The unique string ID of the soruce of the de-assignment.
     */
    removeRole(roles: number, sourceId: string): void;
    /**
     * Prepares this entry for rendering.
     * @param showRole The role in which this entry should be rendered.
     * @param iconFactory The factory to use to get a waypoint icon.
     * @param labelFactory The factory to use to get a waypoint label.
     */
    private prepareRender;
    /**
     * Updates this entry. An appropriate render role is selected, then the icon and label are updated as appropriate
     * for the chosen role. If the waypoint's label should be visible, it is added to the appropriate text manager.
     * Of note, this method will not draw the waypoint icon to a canvas element; it will simply ensure the .showIcon
     * property contains the correct value depending on whether the icon should be visible.
     */
    update(): void;
    /**
     * Destroys this entry. Any label from this entry currently registered with the text manager will be deregistered.
     */
    destroy(): void;
}

/**
 * A stream of canvas 2D rendering context-like path commands.
 */
interface PathStream {
    /**
     * Begins a path. Erases all previous path state.
     */
    beginPath(): void;
    /**
     * Moves to a specified point.
     * @param x The x-coordinate of the point to which to move.
     * @param y The y-coordinate of the point to which to move.
     */
    moveTo(x: number, y: number): void;
    /**
     * Paths a straight line from the current point to a specified point.
     * @param x The x-coordinate of the end point.
     * @param y The y-coordinate of the end point.
     */
    lineTo(x: number, y: number): void;
    /**
     * Paths a cubic Bezier curve from the current point to a specified point.
     * @param cp1x The x-coordinate of the first control point.
     * @param cp1y The y-coordinate of the first control point.
     * @param cp2x The x-coordinate of the second control point.
     * @param cp2y The y-coordinate of the second control point.
     * @param x The x-coordinate of the end point.
     * @param y The y-coordinate of the end point.
     */
    bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;
    /**
     * Paths a quadrative Bezier curve from the current point to a specified point.
     * @param cpx The x-coordinate of the control point.
     * @param cpy The y-coordinate of the control point.
     * @param x The x-coordinate of the end point.
     * @param y The y-coordinate of the end point.
     */
    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;
    /**
     * Paths an arc.
     * @param x The x-coordinate of the center of the circle containing the arc.
     * @param y The y-coordinate of the center of the circle containing the arc.
     * @param radius The radius of the arc.
     * @param startAngle The angle of the start of the arc, in radians.
     * @param endAngle The angle of the end of the arc, in radians.
     * @param counterClockwise Whether the arc should be drawn counterclockwise. False by default.
     */
    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterClockwise?: boolean): void;
    /**
     * Paths a line from the current point to the first point defined by the current path.
     */
    closePath(): void;
}
/**
 * A path stream which does nothing on any input.
 */
declare class NullPathStream implements PathStream {
    /** An instance of a {@link NullPathStream}. */
    static readonly INSTANCE: NullPathStream;
    /**
     * Does nothing.
     */
    beginPath(): void;
    /**
     * Does nothing.
     */
    moveTo(): void;
    /**
     * Does nothing.
     */
    lineTo(): void;
    /**
     * Does nothing.
     */
    bezierCurveTo(): void;
    /**
     * Does nothing.
     */
    quadraticCurveTo(): void;
    /**
     * Does nothing.
     */
    arc(): void;
    /**
     * Does nothing.
     */
    closePath(): void;
}
/**
 * A path stream which sends a transformed version of its input to be consumed by another stream.
 */
interface TransformingPathStream extends PathStream {
    /**
     * Gets the path stream that is consuming this stream's transformed output.
     * @returns The path stream that is consuming this stream's transformed output.
     */
    getConsumer(): PathStream;
    /**
     * Sets the path stream that consumes this stream's transformed output.
     * @param consumer The new consuming path stream.
     */
    setConsumer(consumer: PathStream): void;
}
/**
 * An abstract implementation of a path stream which sends a transformed version of its input to be consumed by another
 * stream.
 */
declare abstract class AbstractTransformingPathStream implements TransformingPathStream {
    protected consumer: PathStream;
    /**
     * Constructor.
     * @param consumer The path stream that consumes this stream's transformed output.
     */
    constructor(consumer: PathStream);
    /** @inheritdoc */
    getConsumer(): PathStream;
    /** @inheritdoc */
    setConsumer(consumer: PathStream): void;
    /** @inheritdoc */
    abstract beginPath(): void;
    /** @inheritdoc */
    abstract moveTo(x: number, y: number): void;
    /** @inheritdoc */
    abstract lineTo(x: number, y: number): void;
    /** @inheritdoc */
    abstract bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;
    /** @inheritdoc */
    abstract quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;
    /** @inheritdoc */
    abstract arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterClockwise?: boolean): void;
    /** @inheritdoc */
    abstract closePath(): void;
}
/**
 * A path stream which sends its inputs unchanged to be consumed by another stream.
 */
declare class PassThroughPathStream extends AbstractTransformingPathStream {
    /** @inheritdoc */
    beginPath(): void;
    /** @inheritdoc */
    moveTo(x: number, y: number): void;
    /** @inheritdoc */
    lineTo(x: number, y: number): void;
    /** @inheritdoc */
    bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;
    /** @inheritdoc */
    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;
    /** @inheritdoc */
    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterClockwise?: boolean): void;
    /** @inheritdoc */
    closePath(): void;
}

/**
 * A path stream which performs clipping to an axis-aligned rectangular bounding box before sending the clipped path
 * to another stream. Clipping is only supported for path segments added via the `lineTo()` and `arc()` methods. Path
 * segments added via `bezierCurveTo()` and `quadraticCurveTo()` will be passed to the consumer stream unclipped.
 */
declare class ClippedPathStream extends AbstractTransformingPathStream {
    private readonly bounds;
    private static readonly vec2Cache;
    private static readonly vec3Cache;
    private static readonly intersectionCache;
    private readonly boundsHandler;
    private readonly boundsLines;
    private isBoundingRectNonZero;
    private readonly firstPoint;
    private readonly prevPoint;
    private prevPointOutcode;
    /**
     * Constructor.
     * @param consumer The path stream that consumes this stream's transformed output.
     * @param bounds A subscribable which provides the clipping bounds for this stream, as `[left, top, right, bottom]`.
     * Whenever the clipping bounds change, the state of this stream will be reset, as if `beginPath()` were called.
     */
    constructor(consumer: PathStream, bounds: Subscribable<ReadonlyFloat64Array>);
    /** @inheritdoc */
    beginPath(): void;
    /** @inheritdoc */
    moveTo(x: number, y: number): void;
    /** @inheritdoc */
    lineTo(x: number, y: number): void;
    /** @inheritdoc */
    bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;
    /** @inheritdoc */
    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;
    /** @inheritdoc */
    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterClockwise?: boolean): void;
    /** @inheritdoc */
    closePath(): void;
    /**
     * Resets the state of this stream.
     */
    private reset;
    /**
     * Gets the Cohen-Sutherland outcode for a point.
     * @param x The x-coordinate of the query point.
     * @param y The y-coordinate of the query point.
     * @returns The outcode for the point.
     */
    private getOutcode;
    /**
     * Handles clipping bounds change events.
     */
    private onBoundsChanged;
    /**
     * Destroys this stream.
     */
    destroy(): void;
    /**
     * Gets the line coordinate vector for a line passing through two points.
     * @param x1 The x-coordinate of the first point on the line.
     * @param y1 The y-coordinate of the first point on the line.
     * @param x2 The x-coordinate of the second point on the line.
     * @param y2 The y-coordinate of the second point on the line.
     * @param out A Float64Array object to which to write the result.
     * @returns The line coordinate vector of the line passing through the two points.
     */
    private static getLineCoordinates;
    /**
     * Finds the intersection point between two lines in 2D Euclidean space.
     * @param line1 The line coordinate vector of the first line.
     * @param line2 The line coordinate vector of the second line.
     * @param out A Float64Array object to which to write the result.
     * @returns The intersection point of the two lines, or undefined if the two lines are parallel.
     */
    private static findLineLineIntersection;
}

/**
 * A path stream which transforms a path stream in geographic spherical coordinates to one in projected planar
 * coordinates.
 */
declare class GeoProjectionPathStream extends AbstractTransformingPathStream {
    private projection;
    private static readonly geoPointCache;
    private static readonly geoCircleCache;
    private readonly resampler;
    private readonly firstPoint;
    private readonly prevPoint;
    private readonly prevPointProjected;
    private readonly resampleHandler;
    /**
     * Constructor.
     * @param consumer The path stream that consumes this stream's transformed output.
     * @param projection The projection this stream uses.
     * @param minDistance The minimum great-circle distance this stream's resampler enforces between two adjacent
     * resampled points, in great-arc radians.
     * @param dpTolerance The Douglas-Peucker tolerance this stream's resampler uses when deciding whether to discard a
     * resampled point during the line simplification process.
     * @param maxDepth The maximum depth of the resampling algorithm used by this stream's resampler. The number of
     * resampled points is bounded from above by 2^[maxDepth] - 1.
     */
    constructor(consumer: PathStream, projection: GeoProjection, minDistance: number, dpTolerance: number, maxDepth: number);
    /**
     * Constructor.
     * @param consumer The path stream that consumes this stream's transformed output.
     * @param projection The projection this stream uses.
     * @param resampler The geo circle resampler this stream uses.
     */
    constructor(consumer: PathStream, projection: GeoProjection, resampler: GeoCircleResampler);
    /**
     * Gets the projection used by this stream.
     * @returns The projection used by this stream.
     */
    getProjection(): GeoProjection;
    /**
     * Sets the projection used by this stream.
     * @param projection A projection.
     */
    setProjection(projection: GeoProjection): void;
    /** @inheritdoc */
    beginPath(): void;
    /**
     * Moves to a specified point.
     * @param lon The longitude of the point to which to move, in degrees.
     * @param lat The latitude of the point to which to move, in degrees.
     */
    moveTo(lon: number, lat: number): void;
    /**
     * Paths a great-circle arc from the current point to a specified point.
     * @param lon The longitude of the end point, in degrees.
     * @param lat The latitude of the end point, in degrees.
     * @throws Error if the specified point is antipodal to the last pathed point.
     */
    lineTo(lon: number, lat: number): void;
    /**
     * Not supported by this path stream.
     * @throws Error when called.
     */
    bezierCurveTo(): void;
    /**
     * Not supported by this path stream.
     * @throws Error when called.
     */
    quadraticCurveTo(): void;
    /**
     * Paths a small-circle arc.
     * @param lon The longitude of the center of the circle containing the arc, in degrees.
     * @param lat The latitude of the center of the circle containing the arc, in degrees.
     * @param radius The radius of the arc, in great-arc radians.
     * @param startAngle If the center of the circle containing the arc is not one of the poles, the true bearing, in
     * degrees, from the center of the circle to the start of the arc; otherwise the longitude, in degrees, of the start
     * of the arc.
     * @param endAngle If the center of the circle containing the arc is not one of the poles, the true bearing, in
     * degrees, from the center of the circle to the end of the arc; otherwise the longitude, in degrees, of the end of
     * the arc.
     * @param counterClockwise Whether the arc should be drawn counterclockwise. False by default.
     */
    arc(lon: number, lat: number, radius: number, startAngle: number, endAngle: number, counterClockwise?: boolean): void;
    /**
     * Paths a great-circle arc from the current point to the first point defined by the current path.
     */
    closePath(): void;
    /**
     * Resets the state of this stream.
     */
    private reset;
    /**
     * Handles resampled points.
     * @param vector A vector which describes the projected path terminating at the resampled point.
     */
    private onResampled;
}

/**
 * A {@link TransformingPathStream} which applies an affine transformation to its input.
 *
 * The types of transformation supported by this class are:
 * * Translation.
 * * Uniform scaling.
 * * Rotation.
 */
declare class AffineTransformPathStream extends AbstractTransformingPathStream {
    private static readonly vec2Cache;
    private static readonly transformCache;
    private readonly transform;
    private readonly concatCache;
    private scale;
    private rotation;
    /**
     * Adds a translation to this stream's transformation.
     * @param x The x translation.
     * @param y The y translation.
     * @param order The order in which to add the translation (defaults to `'after'`):
     * * `'before'` - Applies the translation before this stream's current transformation.
     * * `'after'` - Applies the translation after this stream's current transformation.
     * @returns This stream, after its transformation has been changed.
     */
    addTranslation(x: number, y: number, order?: 'before' | 'after'): this;
    /**
     * Adds a uniform scaling to this stream's transformation.
     * @param factor The scaling factor.
     * @param order The order in which to add the translation (defaults to `'after'`):
     * * `'before'` - Applies the scaling before this stream's current transformation.
     * * `'after'` - Applies the scaling after this stream's current transformation.
     * @returns This stream, after its transformation has been changed.
     */
    addScale(factor: number, order?: 'before' | 'after'): this;
    /**
     * Adds a rotation to this stream's transformation.
     * @param angle The rotation angle, in radians.
     * @param order The order in which to add the translation (defaults to `'after'`):
     * * `'before'` - Applies the rotation before this stream's current transformation.
     * * `'after'` - Applies the rotation after this stream's current transformation.
     * @returns This stream, after its transformation has been changed.
     */
    addRotation(angle: number, order?: 'before' | 'after'): this;
    /**
     * Resets this stream's transformation to the identity transformation.
     * @returns This stream, after its transformation has been changed.
     */
    resetTransform(): this;
    /** @inheritdoc */
    beginPath(): void;
    /** @inheritdoc */
    moveTo(x: number, y: number): void;
    /** @inheritdoc */
    lineTo(x: number, y: number): void;
    /** @inheritdoc */
    bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;
    /** @inheritdoc */
    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;
    /** @inheritdoc */
    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterClockwise?: boolean): void;
    /** @inheritdoc */
    closePath(): void;
    /**
     * Updates this stream's cached scale and rotation values from its transformation.
     */
    private updateScaleRotation;
    /**
     * Applies this stream's transformation to a point.
     * @param x The x-coordinate of the point to transform.
     * @param y The y-coordinate of the point to transform.
     * @returns The transformed point.
     */
    private applyTransform;
}

/**
 * A pattern which can be drawn along a path.
 */
interface PathPattern {
    /** The along-path length of each repeating unit of this pattern. */
    readonly length: number;
    /**
     * The anchor point of each repeating unit of this pattern along its length, as a fraction of the total length. The
     * orientation of each pattern unit is determined by the direction of the path at its anchor point.
     */
    readonly anchor: number;
    /**
     * Draws a single unit of this pattern to a path stream. The coordinate system of the path stream is set such that
     * the anchor point of the pattern unit is located at the origin (0, 0), and the positive x-axis points in the
     * direction of the path on which the pattern unit is placed.
     * @param stream The path stream to which to draw this pattern.
     */
    draw(stream: PathStream): void;
}
/**
 * A {@link TransformingPathStream} which converts an input path into path commands to draw a repeating pattern along
 * the input path.
 */
declare class PatternPathStream implements TransformingPathStream {
    private pattern;
    private static readonly vec2Cache;
    private readonly clipBounds;
    private readonly transformStream;
    private readonly clipStream;
    private readonly firstPoint;
    private readonly prevPoint;
    private distanceLeft;
    /**
     * Constructor.
     * @param consumer The path stream that consumes this stream's transformed output.
     * @param pattern The pattern drawn by this stream. If the pattern is `null`, then this stream will pass through path
     * commands to its consumer without transforming them into a pattern.
     */
    constructor(consumer: PathStream, pattern: PathPattern | null);
    /**
     * Gets the pattern drawn by this stream.
     * @returns The pattern drawn by this stream.
     */
    getPattern(): PathPattern | null;
    /**
     * Sets the pattern drawn by this stream. If the pattern is `null`, then this stream will pass through path commands
     * to its consumer without transforming them into a pattern.
     * @param pattern A pattern.
     */
    setPattern(pattern: PathPattern | null): void;
    /** @inheritdoc */
    getConsumer(): PathStream;
    /** @inheritdoc */
    setConsumer(consumer: PathStream): void;
    /** @inheritdoc */
    beginPath(): void;
    /** @inheritdoc */
    moveTo(x: number, y: number): void;
    /** @inheritdoc */
    lineTo(x: number, y: number): void;
    /**
     * Not supported by this path stream. Calling this method will execute a `moveTo()` command to the specified end
     * point.
     * @param cp1x The x-coordinate of the first control point.
     * @param cp1y The y-coordinate of the first control point.
     * @param cp2x The x-coordinate of the second control point.
     * @param cp2y The y-coordinate of the second control point.
     * @param x The x-coordinate of the end point.
     * @param y The y-coordinate of the end point.
     */
    bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;
    /**
     * Not supported by this path stream. Calling this method will execute a `moveTo()` command to the specified end
     * point.
     * @param cpx The x-coordinate of the control point.
     * @param cpy The y-coordinate of the control point.
     * @param x The x-coordinate of the end point.
     * @param y The y-coordinate of the end point.
     */
    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;
    /** @inheritdoc */
    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterClockwise?: boolean): void;
    /** @inheritdoc */
    closePath(): void;
    /**
     * Resets the state of this stream.
     */
    private reset;
}

/**
 * A stack of {@link TransformingPathStream}s. Inputs are passed through the entire stack from top to bottom before the
 * final transformed output is sent to a consuming stream.
 */
declare class TransformingPathStreamStack extends AbstractTransformingPathStream {
    private readonly stack;
    /**
     * Adds a transforming path stream to the top of this stack.
     * @param stream A transforming path stream.
     */
    push(stream: TransformingPathStream): void;
    /**
     * Removes the top-most path stream from this stack. The removed stream will have its consumer set to
     * {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    pop(): TransformingPathStream | undefined;
    /**
     * Adds a transforming path stream to the bottom of this stack.
     * @param stream A transforming path stream.
     */
    unshift(stream: TransformingPathStream): void;
    /**
     * Removes the bottom-most path stream from this stack. The removed stream will have its consumer set to
     * {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    shift(): TransformingPathStream | undefined;
    /** @inheritdoc */
    setConsumer(consumer: PathStream): void;
    /** @inheritdoc */
    beginPath(): void;
    /** @inheritdoc */
    moveTo(x: number, y: number): void;
    /** @inheritdoc */
    lineTo(x: number, y: number): void;
    /** @inheritdoc */
    bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;
    /** @inheritdoc */
    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;
    /** @inheritdoc */
    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterClockwise?: boolean): void;
    /** @inheritdoc */
    closePath(): void;
}

/**
 * A stack of {@link TransformingPathStream}s which transforms an input in spherical geographic coordinates to planar
 * projected coordinates. The stack contains two sub-stacks: a pre-projected stack which transforms the path before
 * it is projected, and a post-projected stack which transforms the projected path before it is sent to the consumer.
 * Transforming streams can be added to the top and bottom of each sub-stack. The input will be passed through each
 * stream in the pre-projected stack from top to bottom, then projected, then passed through each stream in the post-
 * projected stack from top to bottom, and the final transformed output will be passed to the consumer.
 */
declare class GeoProjectionPathStreamStack extends AbstractTransformingPathStream {
    private readonly projectionStream;
    private readonly preStack;
    private readonly postStack;
    /**
     * Constructor.
     * @param consumer The path stream that consumes this stream's transformed output.
     * @param projection The projection this stream uses.
     * @param minDistance The minimum great-circle distance this stream's resampler enforces between two adjacent
     * resampled points, in great-arc radians.
     * @param dpTolerance The Douglas-Peucker tolerance this stream's resampler uses when deciding whether to discard a
     * resampled point during the line simplification process.
     * @param maxDepth The maximum depth of the resampling algorithm used by this stream's resampler. The number of
     * resampled points is bounded from above by 2^[maxDepth] - 1.
     */
    constructor(consumer: PathStream, projection: GeoProjection, minDistance: number, dpTolerance: number, maxDepth: number);
    /**
     * Constructor.
     * @param consumer The path stream that consumes this stream's transformed output.
     * @param projection The projection this stream uses.
     * @param resampler The geo circle resampler this stream uses.
     */
    constructor(consumer: PathStream, projection: GeoProjection, resampler: GeoCircleResampler);
    /**
     * Gets the projection used by this stream.
     * @returns The projection used by this stream.
     */
    getProjection(): GeoProjection;
    /**
     * Sets the projection used by this stream.
     * @param projection A projection.
     */
    setProjection(projection: GeoProjection): void;
    /**
     * Adds a transforming path stream to the top of the pre-projected stack.
     * @param stream A transforming path stream.
     */
    pushPreProjected(stream: TransformingPathStream): void;
    /**
     * Removes the top-most path stream from the pre-projected stack. The removed stream will have its consumer set to
     * {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    popPreProjected(): TransformingPathStream | undefined;
    /**
     * Adds a transforming path stream to the bottom of the pre-projected stack.
     * @param stream A transforming path stream.
     */
    unshiftPreProjected(stream: TransformingPathStream): void;
    /**
     * Removes the bottom-most path stream from the pre-projected stack. The removed stream will have its consumer set to
     * {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    shiftPreProjected(): TransformingPathStream | undefined;
    /**
     * Adds a transforming path stream to the top of the post-projected stack.
     * @param stream A transforming path stream.
     */
    pushPostProjected(stream: TransformingPathStream): void;
    /**
     * Removes the top-most path stream from the post-projected stack. The removed stream will have its consumer set to
     * {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    popPostProjected(): TransformingPathStream | undefined;
    /**
     * Adds a transforming path stream to the bottom of the post-projected stack.
     * @param stream A transforming path stream.
     */
    unshiftPostProjected(stream: TransformingPathStream): void;
    /**
     * Removes the bottom-most path stream from the post-projected stack. The removed stream will have its consumer set
     * to {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    shiftPostProjected(): TransformingPathStream | undefined;
    /** @inheritdoc */
    setConsumer(consumer: PathStream): void;
    /** @inheritdoc */
    beginPath(): void;
    /** @inheritdoc */
    moveTo(x: number, y: number): void;
    /** @inheritdoc */
    lineTo(x: number, y: number): void;
    /** @inheritdoc */
    bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;
    /** @inheritdoc */
    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;
    /** @inheritdoc */
    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterClockwise?: boolean): void;
    /** @inheritdoc */
    closePath(): void;
}

/**
 * Renders arcs along geo circles to a path stream stack.
 */
declare class GeoCirclePathRenderer {
    private static readonly NORTH_POLE_VEC;
    private static readonly geoPointCache;
    private static readonly vec3Cache;
    /**
     * Renders an arc along a geo circle to a path stream stack.
     * @param circle The geo circle containing the arc to render.
     * @param startLat The latitude of the start of the arc, in degrees.
     * @param startLon The longitude of the start of the arc, in degrees.
     * @param endLat The latitude of the end of the arc, in degrees.
     * @param endLon The longitude of the end of the arc, in degrees.
     * @param streamStack The path stream stack to which to render.
     * @param continuePath Whether to continue the previously rendered path. If true, a discontinuity in the rendered
     * path will not be inserted before the arc is rendered. This may lead to undesired artifacts if the previously
     * rendered path does not terminate at the point where the projected arc starts. Defaults to false.
     */
    render(circle: GeoCircle, startLat: number, startLon: number, endLat: number, endLon: number, streamStack: GeoProjectionPathStreamStack, continuePath?: boolean): void;
}

/**
 * Renders arcs along geo circles as curved lines.
 */
declare class GeoCircleLineRenderer {
    private static readonly EMPTY_DASH;
    private readonly pathRenderer;
    /**
     * Renders an arc along a geo circle to a canvas.
     * @param circle The geo circle containing the arc to render.
     * @param startLat The latitude of the start of the arc, in degrees.
     * @param startLon The longitude of the start of the arc, in degrees.
     * @param endLat The latitude of the end of the arc, in degrees.
     * @param endLon The longitude of the end of the arc, in degrees.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream stack to which to render.
     * @param width The width of the rendered line.
     * @param style The style of the rendered line.
     * @param dash The dash array of the rendered line. Defaults to no dash.
     */
    render(circle: GeoCircle, startLat: number, startLon: number, endLat: number, endLon: number, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack, width: number, style: string, dash?: readonly number[]): void;
}

/**
 * Renders arcs along geo circles as repeating patterns.
 */
declare class GeoCirclePatternRenderer {
    private readonly pathRenderer;
    private readonly patternStream;
    /**
     * Renders an arc along a geo circle to a canvas.
     * @param circle The geo circle containing the arc to render.
     * @param startLat The latitude of the start of the arc, in degrees.
     * @param startLon The longitude of the start of the arc, in degrees.
     * @param endLat The latitude of the end of the arc, in degrees.
     * @param endLon The longitude of the end of the arc, in degrees.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream stack to which to render.
     * @param pattern The pattern to render.
     * @param continuePath Whether to continue the previously rendered path. If true, a discontinuity in the rendered
     * path will not be inserted before the arc is rendered. This may lead to undesired artifacts if the previously
     * rendered path does not terminate at the point where the projected arc starts. Defaults to false.
     */
    render(circle: GeoCircle, startLat: number, startLon: number, endLat: number, endLon: number, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack, pattern: PathPattern, continuePath?: boolean): void;
}

/**
 * Rendering order of flight plan legs.
 */
declare type FlightPathPlanRenderOrder = 'forward' | 'reverse';
/**
 * Renders flight plan paths one leg at a time in either forward or reverse order. Optionally forces the rendering of
 * the active flight plan leg to be last.
 */
declare abstract class AbstractFlightPathPlanRenderer<Args extends any[] = []> {
    protected readonly renderOrder: FlightPathPlanRenderOrder;
    protected readonly renderActiveLegLast: boolean;
    /**
     * Constructor.
     * @param renderOrder The order which this renderer renders the flight plan legs. Forward order renders the legs in
     * a first-to-last fashion. Reverse order renders the legs in a last-to-first fashion. Defaults to forward.
     * @param renderActiveLegLast Whether to render the active leg last. Defaults to true.
     */
    constructor(renderOrder?: FlightPathPlanRenderOrder, renderActiveLegLast?: boolean);
    /**
     * Renders a flight plan path to a canvas.
     * @param plan The flight plan to render.
     * @param startIndex The global index of the first flight plan leg to render, inclusive. Defaults to `0`.
     * @param endIndex The global index of the last flight plan leg to render, inclusive. Defaults to `plan.length - 1`.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream stack to which to render.
     * @param args Additional arguments.
     */
    render(plan: FlightPlan, startIndex: number | undefined, endIndex: number | undefined, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack, ...args: Args): void;
    /**
     * Renders a flight plan leg.
     * @param leg The flight plan leg to render.
     * @param plan The flight plan containing the leg to render.
     * @param activeLeg The active leg in the flight plan.
     * @param legIndex The global index of the leg in its flight plan.
     * @param activeLegIndex The global index of the active flight plan leg.
     * @param projection The map projection to use when rendering.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream stack to which to render.
     */
    protected abstract renderLeg(leg: LegDefinition, plan: FlightPlan, activeLeg: LegDefinition | undefined, legIndex: number, activeLegIndex: number, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack, ...args: Args): void;
}

/**
 * Parts of a flight plan leg path to render.
 */
declare enum FlightPathLegRenderPart {
    /** None. */
    None = 0,
    /** The ingress transition. */
    Ingress = 1,
    /** The base path. */
    Base = 2,
    /** The egress transition. */
    Egress = 4,
    /** The entire leg path. */
    All = 7
}
/**
 * Renders flight plan leg paths one vector at a time, optionally excluding the ingress and/or egress transition
 * vectors.
 */
declare abstract class AbstractFlightPathLegRenderer<Args extends any[] = []> {
    protected static readonly geoPointCache: GeoPoint[];
    protected static readonly geoCircleCache: GeoCircle[];
    protected readonly tempVector: CircleVector;
    /**
     * Renders a flight plan leg path to a canvas.
     * @param leg The flight plan leg to render.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream stack to which to render.
     * @param partsToRender The parts of the leg to render, as a combination of {@link FlightPathLegRenderPart}
     * values.
     * @param args Additional arguments.
     */
    render(leg: LegDefinition, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack, partsToRender: number, ...args: Args): void;
    /**
     * Renders a flight path vector.
     * @param vector The flight path vector to render.
     * @param isIngress Whether the vector is part of the ingress transition.
     * @param isEgress Whether the vector is part of the egress transition.
     * @param leg The flight plan leg containing the vector to render.
     * @param projection The map projection to use when rendering.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream stack to which to render.
     */
    protected abstract renderVector(vector: FlightPathVector, isIngress: boolean, isEgress: boolean, leg: LegDefinition, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack, ...args: Args): void;
}

/**
 * Renders flight plan leg paths one vector at a time, optionally excluding the ingress and/or egress transition
 * vectors. The rendering behavior for each vector is controlled by a function passed to the class constructor.
 */
declare class CustomFlightPathLegRenderer<Args extends any[]> extends AbstractFlightPathLegRenderer<Args> {
    protected readonly renderVector: (vector: CircleVector, isIngress: boolean, isEgress: boolean, leg: LegDefinition, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack, ...args: Args) => void;
    /**
     * Constructor.
     * @param renderVector A function which renders individual flight path vectors.
     */
    constructor(renderVector: (vector: CircleVector, isIngress: boolean, isEgress: boolean, leg: LegDefinition, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack, ...args: Args) => void);
}

/**
 * A style definition for a line rendered by {@link FlightPathLegLineRenderer}.
 */
declare type FlightPathLegLineStyle = {
    /** The width of the line stroke, in pixels. A width of zero or less will cause the stroke to not be rendered. */
    strokeWidth: number;
    /** The style of the line stroke. */
    strokeStyle: string | CanvasPattern | CanvasGradient;
    /** The dash array of the line stroke, or `null` if the stroke is solid. */
    strokeDash: readonly number[] | null;
    /** The width of the line outline, in pixels. A width of zero or less will cause the outline to not be rendered. */
    outlineWidth: number;
    /** The style of the line outline. */
    outlineStyle: string | CanvasPattern | CanvasGradient;
    /** The dash array of the line outline, or `null` if the outline is solid. */
    outlineDash: readonly number[] | null;
    /** Whether the line is continuous with the last vector. */
    isContinuous: boolean;
};
/**
 * A function which selects a line style for a rendered vector.
 * @param vector The vector for which to select a style.
 * @param isIngress Whether the vector is part of the ingress transition.
 * @param isEgress Whether the vector is part of the egress transition.
 * @param leg The flight plan leg containing the vector to render.
 * @param projection The map projection to use when rendering.
 * @param out The line style object to which to write the selected style.
 * @param args Additional arguments.
 * @returns The selected line style for the vector.
 */
declare type FlightPathLegLineStyleSelector<Args extends any[]> = (vector: CircleVector, isIngress: boolean, isEgress: boolean, leg: LegDefinition, projection: GeoProjection, out: FlightPathLegLineStyle, ...args: Args) => FlightPathLegLineStyle;
/**
 * Renders flight plan leg paths as lines, with support for different styles for each flight path vector in the leg.
 */
declare class FlightPathLegLineRenderer<Args extends any[] = any[]> extends AbstractFlightPathLegRenderer<Args> {
    private readonly styleSelector;
    private static readonly EMPTY_DASH;
    protected static readonly geoCircleCache: GeoCircle[];
    private readonly pathRenderer;
    private readonly styleBuffer;
    private activeStyleIndex;
    private isAtLegStart;
    private needStrokeLineAtLegEnd;
    /**
     * Constructor.
     * @param styleSelector A function which selects a style for each rendered vector.
     */
    constructor(styleSelector: FlightPathLegLineStyleSelector<Args>);
    /** @inheritdoc */
    render(leg: LegDefinition, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack, partsToRender: number, ...args: Args): void;
    /** @inheritdoc */
    protected renderVector(vector: CircleVector, isIngress: boolean, isEgress: boolean, leg: LegDefinition, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack, ...args: Args): void;
    /**
     * Applies a stroke to a canvas context.
     * @param context A canvas 2D rendering context.
     * @param style The style of the line to stroke.
     */
    private strokeLine;
    /**
     * Checks if two line styles are equal. Styles are considered equal if and only if their stroke and outline widths
     * are zero, or their stroke and outline widths, styles, and dash arrays are the same.
     * @param style1 The first style.
     * @param style2 The second style.
     * @returns Whether the two line styles are equal.
     */
    private static areStylesEqual;
}

/**
 * A style definition for a pattern rendered by {@link FlightPathLegPatternRenderer}.
 */
declare type FlightPathLegPatternStyle = {
    /** The pattern to render. */
    pattern: PathPattern | null;
    /** Whether the pattern is continuous with the previous vector. */
    isContinuous: boolean;
};
/**
 * A function which selects a pattern style for a rendered vector.
 * @param vector The vector for which to select a style.
 * @param isIngress Whether the vector is part of the ingress transition.
 * @param isEgress Whether the vector is part of the egress transition.
 * @param leg The flight plan leg containing the vector to render.
 * @param projection The map projection to use when rendering.
 * @param out The pattern style object to which to write the selected style.
 * @param args Additional arguments.
 * @returns The selected pattern style for the vector.
 */
declare type FlightPathLegPatternStyleSelector<Args extends any[]> = (vector: CircleVector, isIngress: boolean, isEgress: boolean, leg: LegDefinition, projection: GeoProjection, out: FlightPathLegPatternStyle, ...args: Args) => FlightPathLegPatternStyle;
/**
 * Renders flight plan leg paths as repeating patterns, with support for different patterns for each flight path vector
 * in the leg.
 */
declare class FlightPathLegPatternRenderer<Args extends any[] = any[]> extends AbstractFlightPathLegRenderer<Args> {
    private readonly styleSelector;
    private readonly pathRenderer;
    private readonly style;
    private isAtDiscontinuity;
    /**
     * Constructor.
     * @param styleSelector A function which selects a style for each rendered vector.
     */
    constructor(styleSelector: FlightPathLegPatternStyleSelector<Args>);
    /** @inheritdoc */
    render(leg: LegDefinition, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack, partsToRender: number, ...args: Args): void;
    /** @inheritdoc */
    protected renderVector(vector: CircleVector, isIngress: boolean, isEgress: boolean, leg: LegDefinition, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack, ...args: Args): void;
}

/**
 * Renders flight path vectors as a curved line.
 */
declare class FlightPathVectorLineRenderer {
    private static readonly geoCircleCache;
    private readonly renderer;
    /**
     * Renders a flight path vector to a canvas.
     * @param vector The flight path vector to render.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream to which to render.
     * @param width The width of the rendered line.
     * @param style The style of the rendered line.
     * @param dash The dash array of the rendered line. Defaults to no dash.
     */
    render(vector: CircleVector, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack, width: number, style: string, dash?: readonly number[]): void;
}

/**
 * Renders flight path vectors as repeating patterns.
 */
declare class FlightPathVectorPatternRenderer {
    private static readonly geoCircleCache;
    private readonly renderer;
    /**
     * Renders a flight path vector to a canvas.
     * @param vector The flight path vector to render.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream to which to render.
     * @param pattern The pattern to render.
     * @param continuePath Whether to continue the previously rendered path. If true, a discontinuity in the rendered
     * path will not be inserted before the vector is rendered. This may lead to undesired artifacts if the previously
     * rendered path does not terminate at the point where the projected vector starts. Defaults to false.
     */
    render(vector: CircleVector, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack, pattern: PathPattern, continuePath?: boolean): void;
}

/**
 * Renders an airspace to canvas.
 */
interface MapAirspaceRenderer {
    /**
     * Renders an airspace to canvas.
     * @param airspace The airspace to render.
     * @param projection The projection to use when rendering.
     * @param context The canvas rendering context to which to render.
     * @param lod The LOD to render. Defaults to 0.
     * @param stream The path stream to which to render. If undefined, the path will be rendered directly to the canvas
     * rendering context.
     */
    render(airspace: LodBoundary, projection: GeoProjection, context: CanvasRenderingContext2D, lod?: number, stream?: PathStream): void;
}
/**
 * An airspace renderer which does not draw any graphics.
 */
declare class NullAirspaceRenderer implements MapAirspaceRenderer {
    /** @inheritdoc */
    render(airspace: LodBoundary, projection: GeoProjection, context: CanvasRenderingContext2D, lod?: number, stream?: PathStream): void;
}
/**
 * An abstract implementation of MapAirspaceRenderer.
 */
declare abstract class MapAbstractAirspaceRenderer implements MapAirspaceRenderer {
    /** @inheritdoc */
    render(airspace: LodBoundary, projection: GeoProjection, context: CanvasRenderingContext2D, lod?: number, stream?: PathStream): void;
    /**
     * Renders a single contiguous shape within an airspace.
     * @param shape The shape to render.
     * @param projection The projection to use when rendering.
     * @param context The canvas rendering context to which to render.
     * @param stream The path stream to which to render. If undefined, the path will be rendered directly to the canvas
     * rendering context.
     */
    protected abstract renderShape(shape: Readonly<LodBoundaryShape>, projection: GeoProjection, context: CanvasRenderingContext2D, stream?: PathStream): void;
}

/**
 * An airspace renderer which renders airspace borders as a single line.
 */
declare class MapSingleLineAirspaceRenderer extends MapAbstractAirspaceRenderer {
    readonly lineWidth: number;
    readonly strokeStyle: string | CanvasGradient | CanvasPattern;
    readonly dash: readonly number[];
    private static readonly geoPointCache;
    private static readonly vec2Cache;
    private static readonly vec3Cache;
    /**
     * Constructor.
     * @param lineWidth The stroke width of the rendered airspace line.
     * @param strokeStyle The stroke style of the rendered airspace line.
     * @param dash The dash of the rendered airspace line.
     */
    constructor(lineWidth: number, strokeStyle: string | CanvasGradient | CanvasPattern, dash: readonly number[]);
    /** @inheritdoc */
    protected renderShape(shape: Readonly<LodBoundaryShape>, projection: GeoProjection, context: CanvasRenderingContext2D, stream?: PathStream): void;
    /**
     * Loads a projection of a great-circle path into a canvas rendering context.
     * @param circle The great circle defining the path.
     * @param start The start point of the path.
     * @param end The end point of the path.
     * @param projection The projection to use.
     * @param stream The path stream to which to load the projected path.
     */
    private pathGreatCircle;
    /**
     * Loads a projection of a small-circle path into a canvas rendering context.
     * @param circle The small circle defining the path.
     * @param start The start point of the path.
     * @param end The end point of the path.
     * @param projection The projection to use.
     * @param stream The path stream to which to load the projected path.
     */
    private pathSmallCircle;
}

/**
 * A projected airspace shape which can render its border as optionally offset lines.
 */
interface MapMultiLineAirspaceShape {
    /**
     * Renders this shape's border with a line.
     * @param context The canvas rendering context to which to render.
     * @param offset The offset, in pixels, of the rendered line with respect to this shape's border. A positive offset
     * will shift the line outside of the border.
     * @param lineWidth The stroke width of the line to render.
     * @param strokeStyle The stroke style of the line to render.
     * @param dash The dash of the line to render.
     * @param stream The path stream to which to render. If undefined, the path will be rendered directly to the canvas
     * rendering context.
     */
    renderLine(context: CanvasRenderingContext2D, offset: number, lineWidth: number, strokeStyle: string | CanvasGradient | CanvasPattern, dash: number[], stream?: PathStream): void;
}
/**
 * An airspace renderer which supports rendering airspace borders as multiple, optionally offset lines.
 */
declare abstract class MapMultiLineAirspaceRenderer extends MapAbstractAirspaceRenderer {
    private static tempShape?;
    /** @inheritdoc */
    protected renderShape(shape: Readonly<LodBoundaryShape>, projection: GeoProjection, context: CanvasRenderingContext2D, stream?: PathStream): void;
    /**
     * Renders a projected airspace shape with one or more lines.
     * @param shape The shape to render.
     * @param context The canvas rendering context to which to render.
     * @param stream The path stream to which to render. If undefined, the path will be rendered directly to the canvas
     * rendering context.
     */
    protected abstract renderLines(shape: MapMultiLineAirspaceShape, context: CanvasRenderingContext2D, stream?: PathStream): void;
}

/** A task. */
declare type Task = () => void;
/**
 * A task queue.
 */
interface TaskQueue {
    /**
     * Checks whether this queue has more tasks.
     * @returns whether this queue has more tasks.
     */
    hasNext(): boolean;
    /**
     * Gets the next task in this queue.
     * @returns the next task in this queue.
     * @throws when the queue is empty.
     */
    next(): Task;
}
/**
 * A task queue backed by an array.
 */
declare class ArrayTaskQueue {
    private readonly tasks;
    private head;
    /**
     * Constructor.
     * @param tasks The array of tasks in this queue.
     */
    constructor(tasks: Task[]);
    hasNext(): boolean;
    next(): Task;
}

/**
 * A handler which defines the behavior of a ThrottledTaskQueueProcess.
 */
interface ThrottledTaskQueueHandler {
    /**
     * This method is called when queue processing is started.
     */
    onStarted(): void;
    /**
     * Checks if queue processing can continue in the current frame. If this method returns false, queue processing will
     * pause in the current frame and resume in the next frame via requestAnimationFrame().
     * @param elapsedFrameCount The number of frames elapsed since queue processing started. Equal to 0 on the first
     * frame, 1 on the second, etc.
     * @param dispatchedTaskCount The number of tasks already dispatched in the current frame.
     * @param timeElapsed The time elapsed so far in the current frame, in milliseconds.
     * @returns whether queue processing can continue in the current frame.
     */
    canContinue(elapsedFrameCount: number, dispatchedTaskCount: number, timeElapsed: number): boolean;
    /**
     * This method is called when queue processing is paused.
     * @param elapsedFrameCount The number of frames elapsed since queue processing started. Equal to 0 on the first
     * frame, 1 on the second, etc.
     */
    onPaused(elapsedFrameCount: number): void;
    /**
     * This method is called when queue processing is finished.
     * @param elapsedFrameCount The number of frames elpased since queue processing started. Equal to 0 on the first
     * frame, 1 on the second, etc.
     */
    onFinished(elapsedFrameCount: number): void;
    /**
     * This method is called when queue processing is aborted.
     */
    onAborted(): void;
}
/**
 * A process which dispatches tasks in a task queue potentially over multiple frames.
 */
declare class ThrottledTaskQueueProcess {
    private readonly queue;
    private readonly handler;
    private _hasStarted;
    private _hasEnded;
    private _shouldAbort;
    /**
     * Constructor.
     * @param queue The queue to process.
     * @param handler A handler which defines the behavior of this process.
     */
    constructor(queue: TaskQueue, handler: ThrottledTaskQueueHandler);
    /**
     * Checks whether this process has been started.
     * @returns whether this process has been started.
     */
    hasStarted(): boolean;
    /**
     * Checks whether this process has ended.
     * @returns whether this process has ended.
     */
    hasEnded(): boolean;
    /**
     * Starts this process.
     */
    start(): void;
    /**
     * Processes the queue.
     * @param elapsedFrameCount The number of frames elapsed since queue processing started.
     */
    private processQueue;
    /**
     * Aborts this process. Has no effect if the process has not been started or if it has already ended.
     */
    abort(): void;
}

/**
 * A manager which facilitates the rendering of multiple airspaces.
 */
interface MapAirspaceRenderManager {
    /**
     * Gets all airspaces registered to this render manager.
     * @returns All airspaces registered to this render manager.
     */
    getRegisteredAirspaces(): readonly LodBoundary[];
    /**
     * Registers an airspace with this render manager. An airspace may only be registered once.
     * @param airspace The airspace to register.
     * @returns Whether the airspace was successfully registered.
     */
    registerAirspace(airspace: LodBoundary): boolean;
    /**
     * Deregisters an airspace with this render manager.
     * @param airspace The airspace to deregister.
     * @returns Whether the airspace was successfully deregistered.
     */
    deregisterAirspace(airspace: LodBoundary): boolean;
    /**
     * Replace all airspaces currently registered with this render manager with a new list of airspaces.
     * @param airspaces The new list of airspaces.
     * @returns Whether the replace operation changed the set of registered airspaces.
     */
    replaceRegisteredAirspaces(airspaces: LodBoundary[]): boolean;
    /**
     * Deregisters all airspaces currently registered with this render manager.
     * @returns Whether any airspaces were deregistered.
     */
    clearRegisteredAirspaces(): boolean;
    /**
     * Generates a throttled task queue process, which when started will render all the airspaces registered with this
     * manager.
     * @param projection The projection to use when rendering.
     * @param context The canvas rendering context to which to render.
     * @param taskQueueHandler The handler to assign to the task queue process.
     * @param lod The LOD to render. Defaults to 0.
     * @param stream The path stream to which to render. If undefined, the path will be rendered directly to the canvas
     * rendering context.
     * @returns A throttled task queue process.
     */
    prepareRenderProcess(projection: GeoProjection, context: CanvasRenderingContext2D, taskQueueHandler: ThrottledTaskQueueHandler, lod?: number, stream?: PathStream): ThrottledTaskQueueProcess;
}

/**
 * A module describing properties of the own airplane icon.
 */
declare class MapOwnAirplaneIconModule {
    /** Whether to show the airplane icon. */
    readonly show: Subject<boolean>;
}

/**
 * A module describing the state of the own airplane.
 */
declare class MapOwnAirplanePropsModule {
    /** The airplane's position. */
    readonly position: GeoPointSubject;
    /** The airplane's true heading, in degrees. */
    readonly hdgTrue: Subject<number>;
    /** The airplane's turn rate, in degrees per second. */
    readonly turnRate: Subject<number>;
    /** The airplane's indicated altitude. */
    readonly altitude: NumberUnitSubject<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
    /** The airplane's vertical speed. */
    readonly verticalSpeed: NumberUnitSubject<UnitFamily.Speed, CompoundUnit<UnitFamily.Speed>>;
    /** The airplane's true ground track, in degrees. */
    readonly trackTrue: Subject<number>;
    /** The airplane's ground speed. */
    readonly groundSpeed: NumberUnitSubject<UnitFamily.Speed, CompoundUnit<UnitFamily.Speed>>;
    /** Whether the airplane is on the ground. */
    readonly isOnGround: Subject<boolean>;
    /** The magnetic variation at the airplane's position. */
    readonly magVar: Subject<number>;
}

/**
 * A module describing the state of the autopilot.
 */
declare class MapAutopilotPropsModule {
    /** The altitude preselector setting. */
    readonly selectedAltitude: NumberUnitSubject<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
    private readonly apSelectedAltitudeHandler;
}

/**
 * A module describing the nominal range of a map.
 */
declare class MapRangeModule {
    /** The range of the map as a number unit. */
    readonly nominalRange: NumberUnitSubject<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
}

/**
 * A module describing the nominal range of a map.
 */
declare class MapIndexedRangeModule {
    /** The index of the nominal range. */
    readonly nominalRangeIndex: Subscribable<number>;
    /** The array of possible map nominal ranges. */
    readonly nominalRanges: Subject<readonly NumberUnitInterface<UnitFamily.Distance>[]>;
    /** The nominal range. */
    readonly nominalRange: Subscribable<NumberUnitInterface<UnitFamily.Distance, Unit<UnitFamily.Distance>>>;
    /** @inheritdoc */
    constructor();
    /**
     * A callback which is called when the nominal range array changes.
     * @param array The new array.
     */
    private onNominalRangesChanged;
    /**
     * Sets the nominal range by index.
     * @param index The index of the new nominal range.
     * @returns The value of the new nominal range.
     * @throws Error if index of out of bounds.
     */
    setNominalRangeIndex(index: number): NumberUnitInterface<UnitFamily.Distance>;
}

/**
 * A map of airspace show types to their associated nearest boundary search filter bitflags.
 */
declare type MapAirspaceShowTypes = Record<any, number>;
/**
 * A module describing the display of airspaces.
 */
declare class MapAirspaceModule<T extends MapAirspaceShowTypes> {
    readonly showTypes: T;
    /** Whether to show each type of airspace. */
    readonly show: Record<keyof T, Subject<boolean>>;
    /**
     * Constructor.
     * @param showTypes A map of this module's airspace show types to their associated nearest boundary search filter
     * bitflags.
     */
    constructor(showTypes: T);
}

/**
 * A map module describing whether or not various signals are valid.
 */
declare class MapDataIntegrityModule {
    /** Whether or not the GPS position signal is valid. */
    readonly gpsSignalValid: Subject<boolean>;
    /** Whether or not the heading magnetometer signal is valid. */
    readonly headingSignalValid: Subject<boolean>;
}

/**
 * Component props for the MapComponent.
 */
interface MapBingLayerProps<M> extends MapLayerProps<M> {
    /** The unique ID to assign to this Bing map. */
    bingId: string;
    /**
     * A subscribable array which provides the earth colors for the layer's Bing component. The array should have a
     * length of exactly 61, with index 0 defining the water color and indexes 1 through 60 defining terrain colors from
     * 0 to 60000 feet.
     */
    earthColors: SubscribableArray<number>;
    /**
     * A subscribable which provides the reference mode for the layer's Bing component.
     */
    reference: Subscribable<EBingReference>;
    /**
     * A subscribable which provides the weather radar mode for the layer's Bing component.
     */
    wxrMode?: Subscribable<WxrMode>;
    /**
     * A subscribable which provides whether or not the map isolines are visible.
     */
    isoLines?: Subscribable<boolean>;
    /**
     * How long to delay binding the map in ms.
     */
    delay?: number;
    /** The mode to put the map in. */
    mode?: EBingMode;
}
/**
 * A FSComponent that display the MSFS Bing Map, weather radar, and 3D terrain.
 */
declare class MapBingLayer<M = any> extends MapLayer<MapBingLayerProps<M>> {
    static readonly OVERDRAW_FACTOR: number;
    private readonly wrapperRef;
    private readonly bingRef;
    private readonly resolutionSub;
    private size;
    private needUpdate;
    /** @inheritdoc */
    onAfterRender(): void;
    /** @inheritdoc */
    onWake(): void;
    /** @inheritdoc */
    onSleep(): void;
    /**
     * Updates this layer according to the current size of the projected map window.
     * @param projectedSize The size of the projected map window.
     */
    private updateFromProjectedSize;
    /**
     * Gets an appropriate size, in pixels, for this Bing layer given specific map projection window dimensions.
     * @param projectedSize - the size of the projected map window.
     * @returns an appropriate size for this Bing layer.
     */
    private getSize;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /**
     * A callback which is called when the Bing component is bound.
     */
    private onBingBound;
    /** @inheritdoc */
    onUpdated(time: number, elapsed: number): void;
    /** @inheritdoc */
    setVisible(val: boolean): void;
    /**
     * Resets the underlying Bing component's img src attribute.
     */
    resetImgSrc(): void;
    /**
     * Updates the Bing map center position and radius.
     */
    protected updatePositionRadius(): void;
    /**
     * Gets the desired Bing map radius in meters given a map projection model.
     * @param mapProjection - a map projection model.
     * @returns the desired Bing map radius.
     */
    private calculateDesiredRadius;
    /** @inheritdoc */
    render(): VNode;
}

/**
 * Properties for a MapCanvasLayer.
 */
interface MapCanvasLayerProps<M> extends MapLayerProps<M> {
    /** Whether to include an offscreen buffer. False by default. */
    useBuffer?: boolean;
}
/**
 * An instance of a canvas within a MapCanvasLayer.
 */
interface MapCanvasLayerCanvasInstance {
    /** This instance's canvas element. */
    readonly canvas: HTMLCanvasElement;
    /** This instance's canvas 2D rendering context. */
    readonly context: CanvasRenderingContext2D;
    /** Whether this instance's canvas is displayed. */
    readonly isDisplayed: boolean;
    /** Clears this canvas. */
    clear(): void;
    /**
     * Resets this instance's canvas. This will erase the canvas of all drawn pixels, reset its state (including all
     * styles, transformations, and cached paths), and clear the Coherent GT command buffer associated with it.
     */
    reset(): void;
}
/**
 * An implementation of MapCanvasLayerCanvasInstance.
 */
declare class MapCanvasLayerCanvasInstanceClass implements MapCanvasLayerCanvasInstance {
    readonly canvas: HTMLCanvasElement;
    readonly context: CanvasRenderingContext2D;
    readonly isDisplayed: boolean;
    /**
     * Creates a new canvas instance.
     * @param canvas The canvas element.
     * @param context The canvas 2D rendering context.
     * @param isDisplayed Whether the canvas is displayed.
     */
    constructor(canvas: HTMLCanvasElement, context: CanvasRenderingContext2D, isDisplayed: boolean);
    clear(): void;
    reset(): void;
}
/**
 * A layer which uses a canvas to draw graphics.
 */
declare abstract class MapCanvasLayer<P extends MapCanvasLayerProps<any> = MapCanvasLayerProps<any>, C extends MapCanvasLayerCanvasInstance = MapCanvasLayerCanvasInstance> extends MapLayer<P> {
    private readonly displayCanvasRef;
    private width;
    private height;
    private displayCanvasContext;
    private _display?;
    private _buffer?;
    protected isInit: boolean;
    /**
     * Gets this layer's display canvas instance.
     * @returns This layer's display canvas instance.
     * @throws Error if this layer's display canvas instance has not been initialized.
     */
    get display(): C;
    /**
     * Gets this layer's buffer canvas instance.
     * @returns This layer's buffer canvas instance.
     * @throws Error if this layer's buffer canvas instance has not been initialized.
     */
    get buffer(): C;
    /**
     * Attempts to get this layer's display canvas instance.
     * @returns This layer's display canvas instance, or undefined if it has not been initialized.
     */
    tryGetDisplay(): C | undefined;
    /**
     * Attempts to get this layer's buffer canvas instance.
     * @returns This layer's buffer canvas instance, or undefined if it has not been initialized.
     */
    tryGetBuffer(): C | undefined;
    /**
     * Gets the width of the canvas element, in pixels.
     * @returns the width of the canvas element.
     */
    getWidth(): number;
    /**
     * Gets the height of the canvas element, in pixels.
     * @returns the height of the canvas element.
     */
    getHeight(): number;
    /**
     * Sets the width of the canvas element, in pixels.
     * @param width The new width.
     */
    setWidth(width: number): void;
    /**
     * Sets the height of the canvas element, in pixels.
     * @param height The new height.
     */
    setHeight(height: number): void;
    /**
     * Copies the contents of the buffer to the display. Has no effect if this layer does not have a buffer.
     */
    copyBufferToDisplay(): void;
    /**
     * A callback called after the component renders.
     */
    onAfterRender(): void;
    onVisibilityChanged(isVisible: boolean): void;
    /**
     * Updates this layer according to its current visibility.
     */
    protected updateFromVisibility(): void;
    onAttached(): void;
    /**
     * Initializes this layer's canvas instances.
     */
    private initCanvasInstances;
    /**
     * Creates a canvas instance.
     * @param canvas The canvas element.
     * @param context The canvas 2D rendering context.
     * @param isDisplayed Whether the canvas is displayed.
     * @returns a canvas instance.
     */
    protected createCanvasInstance(canvas: HTMLCanvasElement, context: CanvasRenderingContext2D, isDisplayed: boolean): C;
    /**
     * Updates the canvas element's size.
     */
    protected updateCanvasSize(): void;
    /**
     * Updates the visibility of the display canvas.
     */
    private updateCanvasVisibility;
    /** @inheritdoc */
    render(): VNode | null;
}

/**
 * A canvas map layer whose size and position is synced with the map projection window.
 */
declare class MapSyncedCanvasLayer<P extends MapCanvasLayerProps<any> = MapCanvasLayerProps<any>> extends MapCanvasLayer<P> {
    onAttached(): void;
    /**
     * Updates this layer according to the current size of the projected map window.
     * @param projectedSize The size of the projected map window.
     */
    protected updateFromProjectedSize(projectedSize: ReadonlyFloat64Array): void;
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
}

/**
 * Properties for a MapCachedCanvasLayer.
 */
interface MapCachedCanvasLayerProps<M> extends MapLayerProps<M> {
    /** Whether to include an offscreen buffer. Must be true. */
    useBuffer: true;
    /** The factor by which the canvas should be overdrawn. Values less than 1 will be clamped to 1. */
    overdrawFactor: number;
}
/**
 * A description of the reference projection of a MapCachedCanvasLayer.
 */
interface MapCachedCanvasLayerReference {
    /** The map center of this reference. */
    readonly center: GeoPointReadOnly;
    /** The projection scale factor of this reference. */
    readonly scaleFactor: number;
    /** The rotation angle, in radians, of this reference. */
    readonly rotation: number;
}
/**
 * A description of the transformation of a MapCachedCanvasLayer's canvas element.
 */
interface MapCachedCanvasLayerTransform {
    /** The scaling factor of this transform. */
    readonly scale: number;
    /** The rotation angle, in radians, of this transform. */
    readonly rotation: number;
    /** The translation, in pixels, of this transform. */
    readonly translation: Float64Array;
    /**
     * The total margin, in pixels, available for translation without invalidating the canvas with this transform's
     * scale factor taken into account.
     */
    readonly margin: number;
    /**
     * The remaining margin, in pixels, available for translation without invalidating the canvas given this transform's
     * current translation and scale factor.
     */
    readonly marginRemaining: number;
}
/**
 * An instance of a canvas within a MapCachedCanvasLayer.
 */
interface MapCachedCanvasLayerCanvasInstance extends MapCanvasLayerCanvasInstance {
    /**
     * This instance's map projection reference. The rendering of items to this instance's canvas is based on this
     * reference.
     */
    readonly reference: MapCachedCanvasLayerReference;
    /** This instance's transform. */
    readonly transform: MapCachedCanvasLayerTransform;
    /** Whether this instance's transform is invalid. */
    readonly isInvalid: boolean;
    /** The projection used to draw this instance's canvas image. */
    readonly geoProjection: GeoProjection;
    /**
     * Syncs this canvas instance with the current map projection.
     * @param mapProjection The current map projection.
     */
    syncWithMapProjection(mapProjection: MapProjection): void;
    /**
     * Syncs this canvas instance with another canvas instance.
     * @param other - the canvas instance with which to sync.
     */
    syncWithCanvasInstance(other: MapCachedCanvasLayerCanvasInstance): void;
    /**
     * Invalidates this canvas instance. This also clears the canvas.
     */
    invalidate(): void;
}
/**
 * An implementation of MapCachedCanvasLayerCanvasInstance.
 */
declare class MapCachedCanvasLayerCanvasInstanceClass extends MapCanvasLayerCanvasInstanceClass implements MapCachedCanvasLayerCanvasInstance {
    private readonly getReferenceMargin;
    private static readonly SCALE_INVALIDATION_THRESHOLD;
    private static readonly tempVec2_1;
    private readonly _reference;
    private readonly _transform;
    private _isInvalid;
    private readonly _geoProjection;
    /**
     * Creates a new canvas instance.
     * @param canvas The canvas element.
     * @param context The canvas 2D rendering context.
     * @param isDisplayed Whether the canvas is displayed.
     * @param getReferenceMargin A function which gets this canvas instance's reference margin, in pixels. The reference
     * margin is the maximum amount of translation allowed without invalidation at a scale factor of 1.
     */
    constructor(canvas: HTMLCanvasElement, context: CanvasRenderingContext2D, isDisplayed: boolean, getReferenceMargin: () => number);
    /** @inheritdoc */
    get reference(): MapCachedCanvasLayerReference;
    /** @inheritdoc */
    get transform(): MapCachedCanvasLayerTransform;
    /** @inheritdoc */
    get isInvalid(): boolean;
    /** @inheritdoc */
    get geoProjection(): GeoProjection;
    /** @inheritdoc */
    syncWithMapProjection(mapProjection: MapProjection): void;
    /** @inheritdoc */
    syncWithCanvasInstance(other: MapCachedCanvasLayerCanvasInstance): void;
    /**
     * Updates this canvas instance's transform given the current map projection.
     * @param mapProjection The current map projection.
     */
    updateTransform(mapProjection: MapProjection): void;
    /**
     * Transforms this instance's canvas element.
     */
    protected transformCanvasElement(): void;
    /** @inheritdoc */
    invalidate(): void;
}
/**
 * A canvas map layer whose image can be cached and transformed as the map projection changes.
 */
declare class MapCachedCanvasLayer<P extends MapCachedCanvasLayerProps<any> = MapCachedCanvasLayerProps<any>> extends MapCanvasLayer<P, MapCachedCanvasLayerCanvasInstance> {
    private size;
    private referenceMargin;
    private needUpdateTransforms;
    /** @inheritdoc */
    constructor(props: P);
    /**
     * Gets the size, in pixels, of this layer's canvas.
     * @returns the size of this layer's canvas.
     */
    getSize(): number;
    /**
     * Gets the reference translation margin, in pixels, of this layer's display canvas. This value is the maximum amount
     * the display canvas can be translated in the x or y direction at a scale factor of 1 without invalidation.
     * @returns the reference translation margin of this layer's display canvas.
     */
    getReferenceMargin(): number;
    /** @inheritdoc */
    onAttached(): void;
    /** @inheritdoc */
    protected createCanvasInstance(canvas: HTMLCanvasElement, context: CanvasRenderingContext2D, isDisplayed: boolean): MapCachedCanvasLayerCanvasInstanceClass;
    /**
     * Updates this layer according to the current size of the projected map window.
     * @param projectedSize The size of the projected map window.
     */
    protected updateFromProjectedSize(projectedSize: ReadonlyFloat64Array): void;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /** @inheritdoc */
    onUpdated(time: number, elapsed: number): void;
    /**
     * Updates this layer's canvas instances' transforms.
     */
    protected updateTransforms(): void;
}

/**
 * A ring label.
 */
interface MapLabeledRingLabel<T> {
    /** The content of this label. */
    readonly content: T;
    /**
     * Gets this label's anchor point. The anchor point is expressed relative to the label's width and height, such that
     * (0, 0) is located at the top-left corner and (1, 1) is located at the bottom-right corner.
     * @returns this label's anchor point.
     */
    getAnchor(): ReadonlyFloat64Array;
    /**
     * Gets the angle of the radial on which this label is positioned, in radians. Radial 0 is in the positive x
     * direction.
     * @returns the angle of the radial on which this label is positioned.
     */
    getRadialAngle(): number;
    /**
     * Gets the radial offset of this label from its parent ring, in pixels. Positive values denote displacement away
     * from the center of the ring.
     * @returns the radial offset of this label from its parent ring, in pixels.
     */
    getRadialOffset(): number;
    /**
     * Sets this label's anchor point. The anchor point is expressed relative to the label's width and height, such that
     * (0, 0) is located at the top-left corner and (1, 1) is located at the bottom-right corner.
     * @param anchor The new anchor point.
     */
    setAnchor(anchor: ReadonlyFloat64Array): void;
    /**
     * Sets the angle of the radial on which this label is positioned, in radians. Radial 0 is in the positive x
     * direction.
     * @param angle The new radial angle.
     */
    setRadialAngle(angle: number): void;
    /**
     * Sets the radial offset of this label from its parent ring, in pixels. Positive values denote displacement away
     * from the center of the ring.
     * @param offset The new radial offset.
     */
    setRadialOffset(offset: number): void;
}
/**
 * A map layer which displays a ring (circle) with one or more labels.
 */
declare class MapLabeledRingLayer<T extends MapLayerProps<any>> extends MapLayer<T> {
    protected readonly labelContainerRef: NodeReference<HTMLDivElement>;
    protected readonly canvasLayerRef: NodeReference<MapSyncedCanvasLayer<MapLayerProps<any>>>;
    private readonly center;
    private radius;
    private strokeWidth;
    private strokeStyle;
    private strokeDash;
    private outlineWidth;
    private outlineStyle;
    private outlineDash;
    private needUpdateRingPosition;
    protected isInit: boolean;
    private readonly labels;
    /**
     * Gets the center position of this layer's ring, in pixels.
     * @returns the center position of this layer's ring.
     */
    getRingCenter(): ReadonlyFloat64Array;
    /**
     * Gets the radius of this layer's ring, in pixels.
     * @returns the radius of this layer's ring.
     */
    getRingRadius(): number;
    /**
     * Sets the center and radius of this layer's ring.
     * @param center The new center, in pixels.
     * @param radius The new radius, in pixels.
     */
    setRingPosition(center: ReadonlyFloat64Array, radius: number): void;
    /**
     * Sets the styling for this layer's ring stroke. Any style that is not explicitly defined will be left unchanged.
     * @param width The new stroke width.
     * @param style The new stroke style.
     * @param dash The new stroke dash.
     */
    setRingStrokeStyles(width?: number, style?: string | CanvasGradient | CanvasPattern, dash?: readonly number[]): void;
    /**
     * Sets the styling for this layer's ring outline. Any style that is not explicitly defined will be left unchanged.
     * @param width The new outline width.
     * @param style The new outline style.
     * @param dash The new outline dash.
     */
    setRingOutlineStyles(width?: number, style?: string | CanvasGradient | CanvasPattern, dash?: readonly number[]): void;
    /**
     * Creates a ring label. Labels can only be created after this layer has been rendered.
     * @param content The content of the new label.
     * @returns the newly created ring label, or null if a label could not be created.
     */
    createLabel<L extends string | number | HTMLElement | DisplayComponent<any> | SVGElement>(content: VNode): MapLabeledRingLabel<L> | null;
    /** @inheritdoc */
    onVisibilityChanged(isVisible: boolean): void;
    /** @inheritdoc */
    onAttached(): void;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /** @inheritdoc */
    onUpdated(time: number, elapsed: number): void;
    /**
     * Updates this layer according to its current visibility.
     */
    protected updateFromVisibility(): void;
    /**
     * Updates the position of this layer's ring.
     */
    protected updateRingPosition(): void;
    /**
     * Draws this layer's ring to canvas.
     */
    private drawRing;
    /**
     * Checks whether this layer's ring is in view.
     * @returns whether this layer's ring is in view.
     */
    protected isRingInView(): boolean;
    /**
     * Applies a stroke to a canvas rendering context.
     * @param context The canvas to which to apply a stroke.
     * @param lineWidth The stroke width.
     * @param strokeStyle The stroke style.
     * @param dash The stroke dash.
     */
    protected applyStrokeToContext(context: CanvasRenderingContext2D, lineWidth: number, strokeStyle: string | CanvasGradient | CanvasPattern, dash: readonly number[]): void;
    /**
     * Updates the position of this layer's labels based on the position of the ring.
     */
    private updateLabelPositions;
    /** @inheritdoc */
    render(): VNode;
}

/**
 * Modules required by MapOwnAirplaneLayer.
 */
interface MapOwnAirplaneLayerModules {
    /** Own airplane properties module. */
    ownAirplaneProps: MapOwnAirplanePropsModule;
    /** Own airplane icon module. */
    ownAirplaneIcon: MapOwnAirplaneIconModule;
}
/**
 * Component props for MapOwnAirplaneLayer.
 */
interface MapOwnAirplaneLayerProps<M extends MapOwnAirplaneLayerModules> extends MapLayerProps<M> {
    /** The path to the icon's image file. */
    imageFilePath: Subscribable<string>;
    /** The size of the airplane icon, in pixels. */
    iconSize: number;
    /**
     * The point on the icon which is anchored to the airplane's position, expressed relative to the icon's width and
     * height, with [0, 0] at the top left and [1, 1] at the bottom right.
     */
    iconAnchor: Subscribable<ReadonlyFloat64Array>;
}
/**
 * A layer which draws an own airplane icon.
 */
declare class MapOwnAirplaneLayer<M extends MapOwnAirplaneLayerModules = MapOwnAirplaneLayerModules> extends MapLayer<MapOwnAirplaneLayerProps<M>> {
    protected static readonly UPDATE_VISIBILITY = 1;
    protected static readonly UPDATE_TRANSFORM: number;
    private static readonly tempVec2_1;
    protected readonly iconImgRef: NodeReference<HTMLImageElement>;
    protected readonly iconOffset: Float64Array;
    protected updateFlags: number;
    onVisibilityChanged(isVisible: boolean): void;
    /** @inheritdoc */
    onAttached(): void;
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /**
     * Schedules an update.
     * @param updateFlags The types of updates to schedule.
     */
    protected scheduleUpdate(updateFlags: number): void;
    onUpdated(time: number, elapsed: number): void;
    /**
     * Updates the airplane icon's visibility.
     */
    protected updateIconVisibility(): void;
    /**
     * Updates the airplane icon's display transformation.
     */
    protected updateIconTransform(): void;
    /**
     * A callback which is called when the show airplane icon property changes.
     * @param show The new value of the show airplane icon property.
     */
    private onIconShowChanged;
    /**
     * A callback which is called when the airplane's position changes.
     * @param pos The new position of the airplane.
     */
    private onAirplanePositionChanged;
    /**
     * A callback which is called when the airplane's true heading changes.
     * @param hdgTrue - the new true heading of the airplane.
     */
    private onAirplaneHeadingChanged;
    /** @inheritdoc */
    render(): VNode;
}

/**
 * Component props for MapTextLayer.
 */
interface MapTextLayerProps extends MapLayerProps<any> {
    /** The text manager to use. */
    manager: MapCullableTextLabelManager;
}
/**
 * A layer which displays text which can be culled to avoid overlap.
 */
declare class MapCullableTextLayer extends MapSyncedCanvasLayer<MapTextLayerProps> {
    onUpdated(time: number, elapsed: number): void;
    /**
     * Clears this layer's canvas and redraws the currently visible labels registered to this layer's text manager.
     */
    private redrawLabels;
}

/**
 * Modules required by MapAirspaceLayer.
 */
interface MapAirspaceLayerModules {
    /** Airspace module. */
    airspace: MapAirspaceModule<MapAirspaceShowTypes>;
}
/**
 * Component props for MapAirspaceLayer.
 */
interface MapAirspaceLayerProps extends MapLayerProps<MapAirspaceLayerModules> {
    /** The event bus. */
    bus: EventBus;
    /** A cache of LodBoundary objects to use to cache airspace search results. */
    lodBoundaryCache: LodBoundaryCache;
    /** The airspace render manager to use to render airspaces. */
    airspaceRenderManager: MapAirspaceRenderManager;
    /** A subscribable which provides the maximum airspace search radius. */
    maxSearchRadius: Subscribable<NumberUnitInterface<UnitFamily.Distance>>;
    /** A subscribable which provides the maximum number of items to return per airspace search. */
    maxSearchItemCount: Subscribable<number>;
    /** The debounce delay, in milliseconds, for airspace searches. Defaults to 500. */
    searchDebounceDelay?: number;
    /** The maximum amount of time, in milliseconds, allotted per frame for rendering airspaces. Defaults to 0.2. */
    renderTimeBudget?: number;
}
/**
 * A layer which draws airspaces.
 */
declare class MapAirspaceLayer extends MapLayer<MapAirspaceLayerProps> {
    private static readonly DEFAULT_SEARCH_DEBOUNCE_DELAY;
    private static readonly DEFAULT_RENDER_TIME_BUDGET;
    private static readonly BACKGROUND_RENDER_MARGIN_THRESHOLD;
    private static readonly CLIP_BOUNDS_BUFFER;
    private static readonly geoPointCache;
    private static readonly vec2Cache;
    private readonly canvasLayerRef;
    private clippedPathStream?;
    private readonly clipBoundsSub;
    private readonly facLoader;
    private searchSession?;
    private readonly searchedAirspaces;
    private readonly searchDebounceDelay;
    private readonly renderTimeBudget;
    private activeRenderProcess;
    private readonly renderTaskQueueHandler;
    private searchDebounceTimer;
    private isSearchScheduled;
    private needRefilter;
    private isSearchBusy;
    private lastDesiredSearchRadius;
    private lastSearchRadius;
    private isRenderScheduled;
    private isBackgroundRenderScheduled;
    private isDisplayInvalidated;
    private isAttached;
    /** @inheritdoc */
    onAttached(): void;
    /**
     * Initializes this layer's airspace module property listeners.
     */
    private initModuleListeners;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /**
     * Updates this layer's canvas clipping bounds.
     */
    private updateClipBounds;
    /**
     * Schedules a search. If a search was previously scheduled but not yet executed, this new scheduled search will
     * replace the old one.
     * @param delay The delay, in milliseconds, before the search is executed.
     * @param refilter Whether to update the search's boundary class filter.
     */
    private scheduleSearch;
    /**
     * Schedules a render to be executed during the next update cycle.
     */
    private scheduleRender;
    /**
     * Searches for airspaces around the map center. After the search is complete, the list of search results is filtered
     * and, if necessary, rendered.
     * @param refilter Whether to update the search's boundary class filter.
     */
    private searchAirspaces;
    /**
     * Gets the boundary class filter based on the current airspace type visibility settings.
     * @returns The boundary class filter based on the current airspace type visibility settings.
     */
    private getBoundaryFilter;
    onUpdated(time: number, elapsed: number): void;
    /**
     * Checks if the display and buffer canvases have been invalidated, and if so, clears them and schedules a render.
     */
    private updateFromInvalidation;
    /**
     * If a search is scheduled, decrements the delay timer and if necessary, executes the search.
     * @param elapsed The time elapsed, in milliseconds, since the last update.
     */
    private updateScheduledSearch;
    /**
     * Executes a render if one is scheduled.
     */
    private updateScheduledRender;
    /**
     * Syncs this layer's display canvas instance with the current map projection and renders this layer's airspaces to
     * the display.
     */
    protected startRenderProcess(): void;
    /**
     * Checks whether an airspace is within the projected bounds of a cached canvas instance.
     * @param airspace An airspace.
     * @param canvas A cached canvas instance.
     * @returns Whether the airspace is within the projected bounds of the cached canvas instance.
     */
    private isAirspaceInBounds;
    /**
     * Selects an LOD level based on projected map resolution.
     * @param resolution A projected map resolution, in great-arc radians per pixel.
     * @returns An LOD level based on the projected map resolution.
     */
    private selectLod;
    /**
     * Cleans up the active render process.
     */
    private cleanUpRender;
    /**
     * Renders airspaces from the buffer to the display.
     */
    private renderAirspacesToDisplay;
    /**
     * This method is called when the airspace render process pauses.
     */
    private onRenderPaused;
    /**
     * This method is called when the airspace render process finishes.
     */
    private onRenderFinished;
    /**
     * This method is called when the airspace render process is aborted.
     */
    private onRenderAborted;
    /**
     * This method is called when an airspace show property changes.
     */
    private onAirspaceTypeShowChanged;
    /** @inheritdoc */
    render(): VNode;
}

/**
 * Facility search types supported by MapAbstractNearestWaypointsLayer.
 */
declare type MapNearestWaypointsLayerSearchTypes = FacilitySearchType.Airport | FacilitySearchType.Vor | FacilitySearchType.Ndb | FacilitySearchType.Intersection | FacilitySearchType.User;
/**
 * Component props for MapAbstractNearestWaypointsLayer.
 */
interface MapAbstractNearestWaypointsLayerProps<R extends MapWaypointRenderer<any> = MapWaypointRenderer> extends MapLayerProps<any> {
    /** The event bus. */
    bus: EventBus;
    /** The waypoint renderer to use. */
    waypointRenderer: R;
    /** A function which retrieves a waypoint for a facility. */
    waypointForFacility: (facility: Facility) => MapWaypointRendererType<R>;
    /** A function which registers a waypoint with this layer's waypoint renderer. */
    registerWaypoint: (waypoint: MapWaypointRendererType<R>, renderer: R) => void;
    /** A function which deregisters a waypoint with this layer's waypoint renderer. */
    deregisterWaypoint: (waypoint: MapWaypointRendererType<R>, renderer: R) => void;
    /** A function which initializes this layer's waypoint renderer. */
    initRenderer?: (waypointRenderer: R, canvasLayer: MapSyncedCanvasLayer) => void;
    /** A function which gets the search center. If not defined, the search center defaults to the center of the map. */
    getSearchCenter?: (mapProjection: MapProjection) => LatLonInterface;
    /** A function which checks if a search should be refreshed. Defaults to `true` if not defined. */
    shouldRefreshSearch?: (searchType: MapNearestWaypointsLayerSearchTypes, center: LatLonInterface, radius: number) => boolean;
    /** A function which gets the item limit for facility searches. */
    searchItemLimit?: (searchType: MapNearestWaypointsLayerSearchTypes, center: LatLonInterface, radius: number) => number;
    /** A function which gets the radius limit for facility searches, in great-arc radians. */
    searchRadiusLimit?: (searchType: MapNearestWaypointsLayerSearchTypes, center: LatLonInterface, radius: number) => number;
    /** The debounce delay for facility searches, in milliseconds. Defaults to 500 milliseconds. */
    searchDebounceDelay?: number;
    /** A callback called when the search sessions are started. */
    onSessionsStarted?: (airportSession: NearestAirportSearchSession, vorSession: NearestVorSearchSession, ndbSession: NearestSearchSession<string, string>, intSession: NearestIntersectionSearchSession, userSession: NearestUserFacilitySearchSession) => void;
}
/**
 * An abstract implementation of a map layer which displays waypoints (airports, navaids, and intersections) within a
 * search radius.
 */
declare class MapNearestWaypointsLayer<R extends MapWaypointRenderer<any> = MapWaypointRenderer, P extends MapAbstractNearestWaypointsLayerProps<R> = MapAbstractNearestWaypointsLayerProps<R>> extends MapLayer<P> {
    private static readonly SEARCH_RADIUS_OVERDRAW_FACTOR;
    private readonly canvasLayerRef;
    private readonly searchDebounceDelay;
    private readonly facLoader;
    private facilitySearches?;
    private searchRadius;
    private searchMargin;
    private readonly icaosToShow;
    private isInit;
    /**
     * A callback called when the facility loaded finishes initialization.
     */
    private onFacilityLoaderInitialized;
    /**
     * A callback called when the nearest facility search sessions have been started.
     * @param airportSession The airport search session.
     * @param vorSession The VOR search session.
     * @param ndbSession The NDB search session.
     * @param intSession The intersection search session.
     * @param userSession The user facility search session.
     */
    protected onSessionsStarted(airportSession: NearestAirportSearchSession, vorSession: NearestVorSearchSession, ndbSession: NearestSearchSession<string, string>, intSession: NearestIntersectionSearchSession, userSession: NearestUserFacilitySearchSession): void;
    /** @inheritdoc */
    onAttached(): void;
    /**
     * Initializes this layer.
     */
    private doInit;
    /**
     * Gets the search center for the waypoint searches on this layer.
     * @returns The waypoint search center geo point.
     */
    private getSearchCenter;
    /**
     * Initializes this layer's waypoint renderer.
     */
    private initWaypointRenderer;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /**
     * Updates the desired nearest facility search radius based on the current map projection.
     */
    private updateSearchRadius;
    /** @inheritdoc */
    onUpdated(time: number, elapsed: number): void;
    /**
     * Updates this layer's facility searches.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    private updateSearches;
    /**
     * Attempts to refresh all of the nearest facility searches. Searches will only be refreshed if the desired search
     * radius is different from the last refreshed search radius or the desired search center is outside of the margin
     * of the last refreshed search center.
     * @param center The center of the search area. Defaults to this layer's automatically calculated search center.
     * @param radius The radius of the search area, in great-arc radians. Defaults to this layer's automatically
     * calculated search radius.
     */
    tryRefreshAllSearches(center?: LatLonInterface, radius?: number): void;
    /**
     * Attempts to refresh a nearest search. The search will only be refreshed if the desired search radius is different
     * from the last refreshed search radius or the desired search center is outside of the margin of the last refreshed
     * search center.
     * @param type The type of nearest search to refresh.
     * @param center The center of the search area. Defaults to this layer's automatically calculated search center.
     * @param radius The radius of the search area, in great-arc radians. Defaults to this layer's automatically
     * calculated search radius.
     */
    tryRefreshSearch(type: MapNearestWaypointsLayerSearchTypes, center?: LatLonInterface, radius?: number): void;
    /**
     * Attempts to refresh all of the nearest facility searches.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     */
    private _tryRefreshAllSearches;
    /**
     * Attempts to refresh a nearest search. The search will only be refreshed if `this.shouldRefreshSearch()` returns
     * true and and the desired search radius is different from the last refreshed search radius or the desired search
     * center is outside of the margin of the last refreshed search center.
     * @param type The type of nearest search to refresh.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     */
    private _tryRefreshSearch;
    /**
     * Checks whether one of this layer's searches should be refreshed.
     * @param type The type of nearest search to refresh.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     * @returns Whether the search should be refreshed.
     */
    private shouldRefreshSearch;
    /**
     * Schedules a refresh of this one of this layer's searches.
     * @param type The type of nearest search to refresh.
     * @param search The search to refresh.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     */
    private scheduleSearchRefresh;
    /**
     * Processes nearest facility search results. New facilities are registered, while removed facilities are
     * deregistered.
     * @param results Nearest facility search results.
     */
    private processSearchResults;
    /**
     * Registers an ICAO string with this layer. Once an ICAO is registered, its corresponding facility is drawn to this
     * layer using a waypoint renderer.
     * @param icao The ICAO string to register.
     */
    private registerIcao;
    /**
     * Registers a facility with this layer's waypoint renderer.
     * @param renderer This layer's waypoint renderer.
     * @param facility The facility to register.
     */
    private registerWaypointWithRenderer;
    /**
     * Deregisters an ICAO string from this layer.
     * @param icao The ICAO string to deregister.
     */
    private deregisterIcao;
    /**
     * Deregisters a facility from this layer's waypoint renderer.
     * @param renderer This layer's waypoint renderer.
     * @param facility The facility to deregister.
     */
    private deregisterWaypointWithRenderer;
    /** @inheritdoc */
    render(): VNode;
}
/**
 * A nearest facility search for MapAbstractNearestWaypointsLayer.
 */
declare class MapNearestWaypointsLayerSearch<S extends NearestSearchSession<string, string> = NearestSearchSession<string, string>> {
    private readonly session;
    private readonly refreshCallback;
    private readonly _lastCenter;
    private _lastRadius;
    private maxItemCount;
    private refreshDebounceTimer;
    private isRefreshScheduled;
    /**
     * The center of this search's last refresh.
     */
    get lastCenter(): GeoPointReadOnly;
    /**
     * The radius of this search's last refresh, in great-arc radians.
     */
    get lastRadius(): number;
    /**
     * Constructor.
     * @param session The session used by this search.
     * @param refreshCallback A callback which is called every time the search refreshes.
     */
    constructor(session: S, refreshCallback: (results: NearestSearchResults<string, string>) => void);
    /**
     * Schedules a refresh of this search.  If a refresh was previously scheduled but not yet executed, this new
     * scheduled refresh will replace the old one.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     * @param maxItemCount The maximum number of results returned by the refresh.
     * @param delay The delay, in milliseconds, before the refresh is executed.
     */
    scheduleRefresh(center: LatLonInterface, radius: number, maxItemCount: number, delay: number): void;
    /**
     * Updates this search. Executes any pending refreshes if their delay timers have expired.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    update(elapsed: number): void;
    /**
     * Refreshes this search.
     * @returns a Promise which is fulfilled when the refresh completes.
     */
    private refresh;
}

/**
 * Component props for MapLineLayer.
 */
interface MapLineLayerProps extends MapLayerProps<any> {
    /**
     * A subscribable which provides the start point of the line, as a set of lat/lon coordinates or a 2D vector in
     * projected coordinates. If the start point is `null`, a line will not be drawn.
     */
    start: Subscribable<LatLonInterface | ReadonlyFloat64Array | null>;
    /**
     * A subscribable which provides the end point of the line, as a set of lat/lon coordinates or a 2D vector in
     * projected coordinates. If the end point is `null`, a line will not be drawn.
     */
    end: Subscribable<LatLonInterface | ReadonlyFloat64Array | null>;
    /** The width of the line stroke, in pixels. Defaults to 2 pixels. */
    strokeWidth?: number;
    /** The style of the line stroke. Defaults to `'white'`. */
    strokeStyle?: string | CanvasGradient | CanvasPattern;
    /** The dash array of the line stroke. Defaults to `[]`. */
    strokeDash?: readonly number[];
    /** The width of the line outline, in pixels. Defaults to 0 pixels. */
    outlineWidth?: number;
    /** The style of the line outline. Defaults to `'black'`. */
    outlineStyle?: string | CanvasGradient | CanvasPattern;
    /** The dash array of the line outline. Defaults to `[]`. */
    outlineDash?: readonly number[];
}
/**
 * A map layer that draws a line between two points. The line is drawn in projected coordinate space, so it will always
 * be straight on the projected map.
 */
declare class MapLineLayer extends MapSyncedCanvasLayer<MapLineLayerProps> {
    private static readonly DEFAULT_STROKE_WIDTH;
    private static readonly DEFAULT_STROKE_STYLE;
    private static readonly DEFAULT_STROKE_DASH;
    private static readonly DEFAULT_OUTLINE_WIDTH;
    private static readonly DEFAULT_OUTLINE_STYLE;
    private static readonly DEFAULT_OUTLINE_DASH;
    private readonly strokeWidth;
    private readonly strokeStyle;
    private readonly strokeDash;
    private readonly outlineWidth;
    private readonly outlineStyle;
    private readonly outlineDash;
    private vec;
    private isUpdateScheduled;
    /** @inheritdoc */
    onAttached(): void;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /**
     * Schedules the layer for a draw update.
     */
    private scheduleUpdate;
    /** @inheritdoc */
    onUpdated(time: number, elapsed: number): void;
    /**
     * Draws this layer's line.
     * @param x1 The x coordinate of the start of the line.
     * @param y1 The y coordinate of the start of the line.
     * @param x2 The x coordinate of the end of the line.
     * @param y2 The y coordinate of the end of the line.
     */
    private drawLine;
    /**
     * Applies a stroke to a canvas rendering context.
     * @param context A canvas rendering context.
     * @param width The width of the stroke, in pixels.
     * @param style The style of the stroke.
     * @param dash The dash array of the stroke.
     */
    private stroke;
}

/**
 * Component props for MapGenericLayer.
 */
interface MapGenericLayerProps<M> extends MapLayerProps<M> {
    /** A function to be called when the layer's visibility changes. */
    onVisibilityChanged?: (layer: MapGenericLayer<M>, isVisible: boolean) => void;
    /** A function to be called when the layer is attached to a map. */
    onAttached?: (layer: MapGenericLayer<M>) => void;
    /** A function to be called when the layer is awakened. */
    onWake?: (layer: MapGenericLayer<M>) => void;
    /** A function to be called when the layer is put to sleep. */
    onSleep?: (layer: MapGenericLayer<M>) => void;
    /** A function to be called when the projection of the layer's parent map changes. */
    onMapProjectionChanged?: (layer: MapGenericLayer<M>, mapProjection: MapProjection, changeFlags: number) => void;
    /** A function to be called when the layer updates. */
    onUpdated?: (layer: MapGenericLayer<M>, time: number, elapsed: number) => void;
    /** A function to be called when the layer is detached from a map. */
    onDetached?: (layer: MapGenericLayer<M>) => void;
}
/**
 * A generic map layer which renders its children.
 */
declare class MapGenericLayer<M = any> extends MapLayer<MapGenericLayerProps<M>> {
    /** @inheritdoc */
    onVisibilityChanged(isVisible: boolean): void;
    /** @inheritdoc */
    onAttached(): void;
    /** @inheritdoc */
    onWake(): void;
    /** @inheritdoc */
    onSleep(): void;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /** @inheritdoc */
    onUpdated(time: number, elapsed: number): void;
    /** @inheritdoc */
    onDetached(): void;
    /** @inheritdoc */
    render(): VNode;
}

/**
 * Component props for MapSystemComponent.
 */
interface MapSystemComponentProps<Modules> extends MapComponentProps<Modules> {
    /**
     * A subscribable which provides the size of the dead zone around each edge of the map projection window, which is
     * displayed but excluded in map range calculations. Expressed as [left, top, right, bottom] in pixels. Defaults to 0
     * on all sides.
     */
    deadZone?: Subscribable<Float64Array>;
    /** A function to be called after the map is rendered. */
    onAfterRender: () => void;
    /** A function to be called when the size of the map's dead zone changes. */
    onDeadZoneChanged: (deadZone: ReadonlyFloat64Array) => void;
    /** A function to be called when the map's projection changes. */
    onMapProjectionChanged: (mapProjection: MapProjection, changeFlags: number) => void;
    /** A function to be called immediately before the map's layers are updated. */
    onBeforeUpdated: (time: number, elapsed: number) => void;
    /** A function to be called immediately after the map's layers are updated. */
    onAfterUpdated: (time: number, elapsed: number) => void;
    /** A function to be called when the map is awakened. */
    onWake: () => void;
    /** A function to be called when the map is put to sleep. */
    onSleep: () => void;
    /** A function to be called when the map is destroyed. */
    onDestroy: () => void;
    /** CSS class(es) to apply to the root of the component. */
    class?: string | SubscribableSet<string>;
}
/**
 * A component that encompasses the compiled map system.
 */
declare class MapSystemComponent<P extends MapSystemComponentProps<any> = MapSystemComponentProps<any>> extends MapComponent<P> {
    protected readonly rootStyles: ObjectSubject<{
        width: string;
        height: string;
    }>;
    protected readonly deadZone: Subscribable<ReadonlyFloat64Array>;
    /** @inheritdoc */
    constructor(props: P);
    /** @inheritdoc */
    onAfterRender(thisNode: VNode): void;
    /**
     * This method is called when the size of this map's dead zone changes.
     * @param deadZone The dead zone.
     */
    protected onDeadZoneChanged(deadZone: ReadonlyFloat64Array): void;
    /** @inheritdoc */
    protected onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /**
     * Sets the size of this map's root HTML element.
     * @param size The new size, in pixels.
     */
    protected setRootSize(size: ReadonlyFloat64Array): void;
    /** @inheritdoc */
    protected onProjectedSizeChanged(): void;
    /** @inheritdoc */
    protected onUpdated(time: number, elapsed: number): void;
    /** @inheritdoc */
    protected onWake(): void;
    /** @inheritdoc */
    protected onSleep(): void;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * A map controller.
 */
declare abstract class MapSystemController<Modules extends ModuleRecord = any, Layers extends LayerRecord = any, Controllers extends ControllerRecord = any, Context extends ContextRecord = any> {
    private _isAlive;
    /** Whether this controller is alive. */
    get isAlive(): boolean;
    protected readonly context: MapSystemContext<Modules, Layers, Controllers, Context>;
    /**
     * Constructor.
     * @param context This controller's map context.
     */
    constructor(context: MapSystemContext<Modules, Layers, any, Context>);
    /**
     * This method is called after this controller' map is rendered.
     * @param ref A reference to the rendered map.
     */
    onAfterMapRender(ref: MapSystemComponent): void;
    /**
     * This method is called when the dead zone of this controller's map changes.
     * @param deadZone The map's new dead zone.
     */
    onDeadZoneChanged(deadZone: ReadonlyFloat64Array): void;
    /**
     * This method is called when the projection of this controller's map changes.
     * @param mapProjection The map projection.
     * @param changeFlags Bit flags describing the type of change.
     */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /**
     * This method is called immediately before this controller's map updates its layers.
     * @param time The current sim time, as a UNIX timestamp in milliseconds.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    onBeforeUpdated(time: number, elapsed: number): void;
    /**
     * This method is called immediately after this controller's map updates its layers.
     * @param time The current sim time, as a UNIX timestamp in milliseconds.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    onAfterUpdated(time: number, elapsed: number): void;
    /**
     * This method is called when this controller's map is awakened.
     */
    onWake(): void;
    /**
     * This method is called when this controller's map is put to sleep.
     */
    onSleep(): void;
    /**
     * This method is called when this controller's map is destroyed.
     */
    onMapDestroyed(): void;
    /**
     * Destroys this controller.
     */
    destroy(): void;
}

/**
 * A record of `string`-keyed map model modules.
 */
declare type ModuleRecord = Record<string, any>;
/**
 * A record of `string`-keyed map layers.
 */
declare type LayerRecord = Record<string, any>;
/**
 * A record of `string`-keyed map controllers.
 */
declare type ControllerRecord = Record<string, any>;
/**
 * A record of context properties.
 */
declare type ContextRecord = Record<string, any>;
/**
 * An empty record.
 */
declare type EmptyRecord = Record<never, never>;
/**
 * Adds all modules from a new module record to an existing record. Modules from the new record will overwrite the ones
 * in the existing record if there are key collisions.
 */
declare type ModuleUnion<Modules extends ModuleRecord, New extends ModuleRecord> = Omit<Modules, keyof New> & New;
/**
 * Adds all modules from a new layer record to an existing record. Layers from the new record will overwrite the ones
 * in the existing record if there are key collisions.
 */
declare type LayerUnion<Layers extends LayerRecord, New extends LayerRecord> = Omit<Layers, keyof New> & New;
/**
 * Adds all controllers from a new layer record to an existing record. Controllers from the new record will overwrite
 * the ones in the existing record if there are key collisions.
 */
declare type ControllerUnion<Controllers extends ControllerRecord, New extends ControllerRecord> = Omit<Controllers, keyof New> & New;
/**
 * Adds all properties from a new context record to an existing record. Properties with keys found in the base
 * {@link MapSystemContext} will be ignored. properties from the new record will overwrite the ones in the existing
 * record if there are key collisions.
 */
declare type ContextUnion<Context, New extends ContextRecord> = Omit<Context, keyof Omit<New, keyof MutableMapContext<MapSystemContext>>> & Omit<New, keyof MutableMapContext<MapSystemContext>>;
/**
 * Retrieves a map layer's required modules.
 */
declare type RequiredLayerModules<Layer> = Layer extends MapLayer<infer P> ? P extends MapLayerProps<infer M> ? M : never : never;
/**
 * Retrieves a map controller's required modules.
 */
declare type RequiredControllerModules<Controller> = Controller extends MapSystemController<infer M, any, any, any> ? M : never;
/**
 * Retrieves a map controller's required layers.
 */
declare type RequiredControllerLayers<Controller> = Controller extends MapSystemController<any, infer L, any, any> ? L : never;
/**
 * Retrieves a map controller's required context.
 */
declare type RequiredControllerContext<Controller> = Controller extends MapSystemController<any, any, any, infer Context> ? Context : never;
/**
 * A compiled map from {@link MapSystemBuilder}.
 */
declare type CompiledMapSystem<Modules extends ModuleRecord, Layers extends LayerRecord, Controllers extends ControllerRecord, Context extends ContextRecord> = {
    /** The compiled map context. */
    context: MapSystemContext<Modules, Layers, Controllers, Context>;
    /** The compiled map, rendered as a VNode. */
    map: VNode;
    /** A reference to the compiled map. */
    ref: NodeReference<MapSystemComponent<MapSystemComponentProps<Modules>>>;
};

/**
 * A context which holds data related to a compiled MapSystem map.
 */
declare type MapSystemContext<Modules extends ModuleRecord = EmptyRecord, Layers extends LayerRecord = EmptyRecord, Controllers extends ControllerRecord = EmptyRecord, Context extends ContextRecord = EmptyRecord> = {
    /** The event bus. */
    readonly bus: EventBus;
    /** This context's map model. */
    readonly model: MapModel<Modules>;
    /** This context's map projection. */
    readonly projection: MapProjection;
    /** A subscribable which provides the projected size of this context's map. */
    readonly projectedSize: Subscribable<ReadonlyFloat64Array>;
    /** A subscribable which provides the dead zone of this context's map. */
    readonly deadZone: Subscribable<ReadonlyFloat64Array>;
    /**
     * Retrieves a layer from this context.
     * @param key The key of the layer to retrieve.
     * @returns The layer in this context with the specified key.
     */
    getLayer<K extends keyof Layers & string>(key: K): Layers[K];
    /**
     * Retrieves a controller from this context.
     * @param key The key of the controller to retrieve.
     * @returns The controller in this context with the specified key.
     */
    getController<K extends keyof Controllers & string>(key: K): Controllers[K];
} & Readonly<Context>;
/**
 * A mutable version of {@link MapSystemContext} which allows adding layers and controllers.
 */
declare type MutableMapContext<T> = T extends MapSystemContext<any, infer Layers, infer Controllers, any> ? T & {
    /**
     * Adds a layer to this context.
     * @param key The key of the layer to add.
     * @param layer The layer to add.
     */
    setLayer<K extends keyof Layers & string>(key: K, layer: Layers[K]): void;
    /**
     * Adds a controller to this context.
     * @param key The key of the controller to add.
     * @param controller The controller to add.
     */
    setController<K extends keyof Controllers & string>(key: K, controller: Controllers[K]): void;
} : never;
/**
 * An implementation of the base properties in {@link MapSystemContext}.
 */
declare class DefaultMapSystemContext<Modules extends ModuleRecord = EmptyRecord, Layers extends LayerRecord = EmptyRecord, Controllers extends ControllerRecord = EmptyRecord> {
    readonly bus: EventBus;
    readonly projection: MapProjection;
    readonly projectedSize: Subscribable<ReadonlyFloat64Array>;
    readonly deadZone: Subscribable<ReadonlyFloat64Array>;
    /** This context's map model. */
    readonly model: MapModel<Modules>;
    private readonly layers;
    private readonly controllers;
    /**
     * Creates an instance of a MapSystemContext.
     * @param bus This context's event bus.
     * @param projection This context's map projection.
     * @param projectedSize A subscribable which provides the projected size of this context's map.
     * @param deadZone A subscribable which provides the dead zone of this context's map.
     */
    constructor(bus: EventBus, projection: MapProjection, projectedSize: Subscribable<ReadonlyFloat64Array>, deadZone: Subscribable<ReadonlyFloat64Array>);
    /**
     * Retrieves a layer from this context.
     * @param key The key of the layer to retrieve.
     * @returns The layer in this context with the specified key.
     */
    getLayer<K extends keyof Layers & string>(key: K): Layers[K] & MapLayer;
    /**
     * Retrieves a controller from this context.
     * @param key The key fo the controller to retrieve.
     * @returns The controller in this context with the specified key.
     */
    getController<K extends keyof Controllers & string>(key: K): Controllers[K];
    /**
     * Adds a layer to this context.
     * @param key The key of the layer to add.
     * @param layer The layer to add.
     */
    setLayer<K extends keyof Layers & string>(key: K, layer: Layers[K]): void;
    /**
     * Adds a controller to this context.
     * @param key The key of the controller to add.
     * @param controller The controller to add.
     */
    setController<K extends keyof Controllers & string>(key: K, controller: Controllers[K]): void;
}

/**
 * A binding from a source to a target.
 */
declare type MapBinding<T> = {
    /** The source of the binding. */
    source: Subscribable<T>;
    /** The target of the binding. */
    target: MutableSubscribable<any, T>;
};
/**
 * A binding from a transformed source to a target.
 */
declare type MapTransformedBinding<S, T> = {
    /** The source of the binding. */
    source: Subscribable<S>;
    /** The target of the binding. */
    target: MutableSubscribable<any, T>;
    /** A function which transforms source values before they are applied to the target. */
    map: (source: S) => T;
};
/**
 * A controller which maintains an arbitrary number of bindings.
 */
declare class MapBindingsController extends MapSystemController {
    private readonly bindings;
    private pipes?;
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param bindings This controller's bindings.
     */
    constructor(context: MapSystemContext<any, any, any, any>, bindings: Iterable<MapBinding<any> | MapTransformedBinding<any, any>>);
    /** @inheritdoc */
    onAfterMapRender(): void;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    onWake(): void;
    /** @inheritdoc */
    onSleep(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Context values required for MapClockUpdateController.
 */
interface MapClockUpdateControllerContext {
    /** The map update frequency. */
    updateFreq: Subscribable<number>;
}
/**
 * Updates a map at regular intervals based on event bus clock events.
 */
declare class MapClockUpdateController extends MapSystemController<any, any, any, MapClockUpdateControllerContext> {
    private freqSub?;
    private clockSub?;
    /** @inheritdoc */
    onAfterMapRender(ref: MapSystemComponent): void;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * A collection of common keys used by the MapSystem API.
 */
declare class MapSystemKeys {
    static readonly TargetControl: "targetControlModerator";
    static readonly RotationControl: "rotationControlModerator";
    static readonly RangeControl: "rangeControlModerator";
    static readonly ClockUpdate: "clockUpdate";
    static readonly OwnAirplaneProps: "ownAirplaneProps";
    static readonly AutopilotProps: "autopilotProps";
    static readonly TerrainColors: "terrainColors";
    static readonly Weather: "weather";
    static readonly FollowAirplane: "followAirplane";
    static readonly Rotation: "rotation";
    static readonly OwnAirplaneIcon: "ownAirplaneIcon";
    static readonly TextLayer: "text";
    static readonly TextManager: "textManager";
    static readonly Bing: "bing";
    static readonly WaypointRenderer: "waypointRenderer";
    static readonly IconFactory: "iconFactory";
    static readonly LabelFactory: "labelFactory";
    static readonly NearestWaypoints: "nearestWaypoints";
    static readonly FlightPlan: "flightPlan";
    static readonly FlightPlanner: "flightPlanner";
    static readonly FlightPathRenderer: "flightPathRenderer";
    static readonly Airspace: "airspace";
    static readonly AirspaceManager: "airspaceRenderManager";
    static readonly Traffic: "traffic";
    static readonly DataIntegrity: "dataIntegrity";
}

/**
 * A map data module that handles the display of flight plan data.
 */
declare class MapFlightPlanModule {
    private readonly plans;
    /**
     * Gets the flight plan subjects for a specified flight plan.
     * @param index The index of the flight plan.
     * @returns The subject for the specified plan index.
     */
    getPlanSubjects(index: number): PlanSubjects;
}
/**
 * A collection of subjects for consuming flight plan data in the flight plan module.
 */
declare class PlanSubjects {
    /** The current flight plan to display, if any. */
    flightPlan: Subject<FlightPlan | undefined>;
    /** An event that fires when the plan is changed. */
    planChanged: SubEvent<any, void>;
    /** An event that fired when the flight path of the plan is recalculated. */
    planCalculated: SubEvent<any, void>;
    /** The active leg index currently being navigated to. */
    activeLeg: Subject<number>;
}

/**
 * Modules required for MapFlightPlanController.
 */
interface MapFlightPlanControllerModules {
    /** Flight plan module. */
    [MapSystemKeys.FlightPlan]: MapFlightPlanModule;
}
/**
 * Context values required for MapFlightPlanController.
 */
interface MapFlightPlanControllerContext {
    /** The flight planner. */
    [MapSystemKeys.FlightPlanner]: FlightPlanner;
}
/**
 * Controls the map system's flight plan module.
 */
declare class MapFlightPlanController extends MapSystemController<MapFlightPlanControllerModules, any, any, MapFlightPlanControllerContext> {
    private readonly flightPlanModule;
    private planCopiedHandler;
    private planCreatedHandler;
    private planDeletedHandler;
    private planChangeHandler;
    private planCalculatedHandler;
    private activeLegChangedHandler;
    private fplCopiedSub?;
    private fplCreatedSub?;
    private fplDeletedSub?;
    private fplDirectToDataChangedSub?;
    private fplLoadedSub?;
    private fplOriginDestChangedSub?;
    private fplProcDetailsChangedSub?;
    private fplSegmentChangeSub?;
    private fplUserDataDeleteSub?;
    private fplUserDataSetSub?;
    private fplActiveLegChangeSub?;
    private fplCalculatedSub?;
    /** @inheritdoc */
    onAfterMapRender(): void;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * A heap which allocates instances of a resource.
 */
declare class ResourceHeap<T> {
    private readonly factory;
    private readonly destructor;
    private readonly onAllocated?;
    private readonly onFreed?;
    readonly maxSize: number;
    private readonly autoShrinkThreshold;
    private readonly cache;
    private numAllocated;
    /**
     * Constructor.
     * @param factory A function which creates new instances of this heap's resource.
     * @param destructor A function which destroys instances of this heap's resource.
     * @param onAllocated A function which is called when an instance of this heap's resource is allocated.
     * @param onFreed A function which is called when an instance of this heap's resource is freed.
     * @param initialSize The initial size of this heap. Defaults to `0`.
     * @param maxSize The maximum size of this heap. Defaults to `Number.MAX_SAFE_INTEGER`. This heap cannot allocate
     * more resources than its maximum size.
     * @param autoShrinkThreshold The size above which this heap will attempt to automatically reduce its size when
     * resources are freed. The heap will never reduce its size below this threshold. Defaults to
     * `Number.MAX_SAFE_INTEGER`.
     */
    constructor(factory: () => T, destructor: (resource: T) => void, onAllocated?: ((resource: T) => void) | undefined, onFreed?: ((resource: T) => void) | undefined, initialSize?: number, maxSize?: number, autoShrinkThreshold?: number);
    /**
     * Allocates a resource instance from this heap. If this heap has an existing free resource available, one will be
     * returned. Otherwise, a new resource instance will be created, added to the heap, and returned.
     * @returns A resource.
     * @throws Error if this heap has reached its allocation limit.
     */
    allocate(): T;
    /**
     * Frees a resource instance allocated from this heap, allowing it to be re-used.
     * @param resource The resource to free.
     */
    free(resource: T): void;
}

/**
 * A consumer of a resource.
 */
declare type ResourceConsumer<T = void> = {
    /**
     * This consumer's priority for its desired resource. Consumers with higher priority will gain access to the resource
     * over consumers with lower priority.
     */
    readonly priority: number;
    /**
     * A callback function which is called when this consumer gains access to its desired resource.
     */
    onAcquired: (resource: T) => void;
    /**
     * A callback function which is called when this consumer loses access to its desired resource.
     */
    onCeded: (resource: T) => void;
};
/**
 * Moderates access to a resource.
 */
declare class ResourceModerator<T = void> {
    private readonly resource;
    private pendingConsumer;
    private assignedConsumer;
    private readonly queuedConsumers;
    /**
     * Constructor.
     * @param resource This resource controlled by this moderator.
     */
    constructor(resource: T);
    /**
     * Makes a claim to this moderator's resource. If the resource is not currently owned, or the claiming consumer has
     * a higher priority than the current owner, access will attempt to pass to the claiming consumer. Otherwise, the
     * claiming consumer will enter a queue. After entering the queue, a consumer will gain access to the claimed
     * resource when all other consumers with a higher priority forfeit their claims to the resource.
     * @param consumer The consumer claiming the resource.
     */
    claim(consumer: ResourceConsumer<T>): void;
    /**
     * Forfeits a claim to this moderator's resource. If the consumer forfeiting its claim is the current owner of the
     * resource, it will immediately lose access to the resource, and access will attempt to pass to the next-highest
     * priority consumer with a claim to the resource. Otherwise, the forfeiting consumer will be removed from the queue
     * to gain access to the resource.
     * @param consumer The consumer that is forfeiting its claim.
     */
    forfeit(consumer: ResourceConsumer<T>): void;
}

/**
 * A module which describes whether the map is following the player airplane.
 */
declare class MapFollowAirplaneModule {
    /** Whether the map is following the player airplane. */
    readonly isFollowing: Subject<boolean>;
}

/**
 * Modules required for MapFollowAirplaneController.
 */
interface MapFollowAirplaneControllerModules {
    /** Own airplane properties module. */
    [MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule;
    /** Follow airplane module. */
    [MapSystemKeys.FollowAirplane]: MapFollowAirplaneModule;
}
/**
 * Context properties required for MapFollowAirplaneController.
 */
interface MapFollowAirplaneControllerContext {
    /** Resource moderator for control of the map's projection target. */
    [MapSystemKeys.TargetControl]: ResourceModerator;
}
/**
 * Controls the target position of a map to follow the player airplane.
 */
declare class MapFollowAirplaneController extends MapSystemController<MapFollowAirplaneControllerModules, any, any, MapFollowAirplaneControllerContext> {
    private readonly ownAirplanePropsModule;
    private readonly isFollowingAirplane;
    private readonly mapProjectionParams;
    private readonly targetControl;
    private readonly targetControlConsumer;
    /** @inheritdoc */
    onAfterMapRender(): void;
    /** @inheritdoc */
    onBeforeUpdated(): void;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Modules required for MapOwnAirplanePropsController.
 */
interface MapOwnAirplanePropsControllerModules {
    /** Own airplane properties. */
    [MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule;
}
/**
 * A key for a property in {@link MapOwnAirplanePropsModule}.
 */
declare type MapOwnAirplanePropsKey = Extract<keyof MapOwnAirplanePropsModule, string>;
/**
 * Updates the properties in a {@link MapOwnAirplanePropsModule}.
 */
declare class MapOwnAirplanePropsController extends MapSystemController<MapOwnAirplanePropsControllerModules> {
    private readonly properties;
    private readonly updateFreq;
    private readonly module;
    private readonly subs;
    private updateFreqSub?;
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param properties The properties to update on the module.
     * @param updateFreq A subscribable which provides the update frequency, in hertz.
     */
    constructor(context: MapSystemContext<MapOwnAirplanePropsControllerModules>, properties: Iterable<MapOwnAirplanePropsKey>, updateFreq: Subscribable<number>);
    /** @inheritdoc */
    onAfterMapRender(): void;
    /**
     * Binds a module property to data received through the event bus.
     * @param sub The event bus subscriber.
     * @param property The property to bind.
     * @param updateFreq The data update frequency.
     * @returns The subscription created by the binding.
     */
    private bindProperty;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * An enumeration of possible map rotation types.
 */
declare enum MapRotation {
    /** Map rotation points towards north up. */
    NorthUp = "NorthUp",
    /** Map up position points towards the current airplane track. */
    TrackUp = "TrackUp",
    /** Map up position points towards the current airplane heading. */
    HeadingUp = "HeadingUp",
    /** Map up position points towards the current nav desired track. */
    DtkUp = "DtkUp"
}
/**
 * A module describing the rotation behavior of the map.
 */
declare class MapRotationModule {
    /** The type of map rotation to use. */
    readonly rotationType: Subject<MapRotation>;
}

/**
 * Modules required for MapRotationController.
 */
interface MapRotationControllerModules {
    /** Rotation module. */
    [MapSystemKeys.Rotation]: MapRotationModule;
    /** Own airplane properties module. */
    [MapSystemKeys.OwnAirplaneProps]?: MapOwnAirplanePropsModule;
}
/**
 * Required context properties for MapRotationController.
 */
interface MapRotationControllerContext {
    /** Resource moderator for control of the map's rotation. */
    [MapSystemKeys.RotationControl]: ResourceModerator;
}
/**
 * Controls the rotation of a map based on the behavior defined in {@link MapRotationModule}.
 */
declare class MapRotationController extends MapSystemController<MapRotationControllerModules, any, any, MapRotationControllerContext> {
    private readonly rotationModule;
    private readonly ownAirplanePropsModule;
    private readonly rotationParam;
    private hasRotationControl;
    private readonly rotationControl;
    private readonly rotationControlConsumer;
    private readonly rotationFuncs;
    private rotationFunc;
    private rotationSub?;
    /** @inheritdoc */
    onAfterMapRender(): void;
    /** @inheritdoc */
    onBeforeUpdated(): void;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * A handler that takes some leg data and returns the appropriate flight path rendering style.
 */
declare type LegStyleHandler = (plan: FlightPlan, leg: LegDefinition, activeLeg: LegDefinition | undefined, legIndex: number, activeLegIndex: number) => FlightPathRenderStyle;
/**
 * A handler that takes some leg data and returns the waypoint rendering role that the
 * waypoint should be rendered under.
 */
declare type LegWaypointHandler = (plan: FlightPlan, leg: LegDefinition, activeLeg: LegDefinition | null, legIndex: number, activeLegIndex: number) => number;
/**
 * A map flight plan renderer that can be supplied styling from the outside.
 */
declare class MapSystemPlanRenderer extends AbstractFlightPathPlanRenderer {
    defaultRoleId: number;
    /**
     * Creates an instance of the MapSystemPlanRenderer.
     * @param defaultRoleId The default role ID to render the plan waypoints under.
     * @param renderOrder The order which this renderer renders the flight plan legs. Forward order renders the legs in a first-to-last
     * fashion. Reverse order renders the legs in a last-to-first fashion. Defaults to forward.
     * @param renderActiveLegLast Whether to render the active leg last. Defaults to true.
     */
    constructor(defaultRoleId: number, renderOrder?: FlightPathPlanRenderOrder, renderActiveLegLast?: boolean);
    protected readonly legRenderer: MapSystemLegRenderer;
    /**
     * A handler that returns a leg rendering style for a given set of leg data.
     * @returns A leg rendering style.
     */
    readonly legStyleHandlers: Map<number, LegStyleHandler>;
    /**
     * A handler that returns whether or not a leg waypoint should be displayed.
     * @returns Whether or not the leg should be displayed.
     */
    readonly legWaypointHandlers: Map<number, LegWaypointHandler>;
    /** Whether or not to render flight path ingress turns. */
    renderIngress: Subscribable<boolean>;
    /** Whether or not to render flight path egress turns. */
    renderEgress: Subscribable<boolean>;
    /** @inheritdoc */
    protected renderLeg(leg: LegDefinition, plan: FlightPlan, activeLeg: LegDefinition | undefined, legIndex: number, activeLegIndex: number, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack): void;
}
/**
 * A map system flight plan leg renderer that uses a swappable style.
 */
declare class MapSystemLegRenderer extends AbstractFlightPathLegRenderer {
    protected readonly vectorRenderer: FlightPathVectorLineRenderer;
    currentRenderStyle: FlightPathRenderStyle;
    /** @inheritdoc */
    protected renderVector(vector: CircleVector, isIngress: boolean, isEgress: boolean, leg: LegDefinition, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack): void;
}
/**
 * A vector line rendering style to apply to a flight path display on the map.
 */
declare class FlightPathRenderStyle {
    isDisplayed: boolean;
    /**
     * Creates an instance of a FlightPathRenderStyle.
     * @param isDisplayed Whether or not the path is displayed.
     */
    constructor(isDisplayed?: boolean);
    /** The pixel width of the path line. */
    width: number;
    /** The style string for the line. */
    style: string;
    /** A dash-array configuration for the line, if any. */
    dash?: number[];
    /** The default rendering style. */
    static readonly Default: FlightPathRenderStyle;
    /** A style that does not display the path. */
    static readonly Hidden: FlightPathRenderStyle;
}

/**
 * A waypoint renderer for the MapSystem API. Supports addition of string-keyed render roles. Each render role is
 * assigned a position in an ordered list that determines the priority of being chosen when roles are selected for
 * rendering waypoints. For each waypoint, the renderer iterates through all render roles in the priority order list
 * and selects the first role under which the waypoint is registered and is visible.
 */
declare class MapSystemWaypointsRenderer extends MapWaypointRenderer<Waypoint> {
    /** The default render role group. */
    static readonly DefaultGroup = "DEFAULT_GROUP";
    protected readonly rolePriorityOrder: number[];
    protected readonly rolesByGroup: Map<string, string[]>;
    protected readonly roleIdMap: Map<string, number>;
    protected currentBit: number;
    /** An event that fires when any roles are added. */
    readonly onRolesAdded: SubEvent<this, void>;
    /**
     * Constructor.
     * @param textManager The text manager to use for waypoint labels.
     */
    constructor(textManager: MapCullableTextLabelManager);
    /**
     * This method is disabled. Please use the `addRenderRole(name: string, def: MapWaypointRenderRoleDef<Waypoint>, group?: string)`
     * overload to add render roles to this renderer.
     * @param role The render role to add.
     * @param def The render role's definition.
     * @returns `false`.
     */
    addRenderRole(role: number, def?: MapWaypointRenderRoleDef<Waypoint>): false;
    /**
     * Adds a new named render role to this renderer. The new render role will be placed at the end of this renderer's
     * render role selection priority order. Roles positioned earlier in the order have a higher priority for being
     * chosen when roles are selected for rendering waypoints.
     * @param name The name of the render role to add.
     * @param def The render role's definition. If undefined, the new role will be assigned a default definition with
     * no defined rendering context, icon, or label factories, and a visibility handler which always returns true.
     * @param group The group in which to include the new render role, if any. Defaults to
     * {@link MapSystemWaypointsRenderer.DefaultGroup}.
     * @returns Whether the role was successfully added.
     */
    addRenderRole(name: string, def?: MapWaypointRenderRoleDef<Waypoint>, group?: string): boolean;
    /**
     * Adds a new named render role to this renderer and inserts it before an existing render role in this renderer's
     * render role selection priority order. Roles positioned earlier in the order have a higher priority for being
     * chosen when roles are selected for rendering waypoints.
     * @param name The name of the render role to add.
     * @param insertBefore The name of the role before which to insert the new role in this renderer's render role
     * selection priority order. If the name does not match any of this renderer's existing render roles, the new role
     * will be placed at the end of the priority order.
     * @param def The render role's definition. If undefined, the new role will be assigned a default definition with
     * no defined rendering context, icon, or label factories, and a visibility handler which always returns true.
     * @param group The group in which to include the new render role, if any. Defaults to
     * {@link MapSystemWaypointsRenderer.DefaultGroup}.
     * @returns Whether the role was successfully inserted.
     */
    insertRenderRole(name: string, insertBefore: string, def?: MapWaypointRenderRoleDef<Waypoint>, group?: string): boolean;
    /**
     * Gets a render role associated with a name.
     * @param name The name of the role.
     * @returns The render role associated with the specified name, or undefined if there is no such role.
     */
    getRoleFromName(name: string): number | undefined;
    /**
     * Gets the names of roles in a specified group.
     * @param group A render role group.
     * @returns An array of the names of all render roles belonging to the specified group.
     */
    getRoleNamesByGroup(group: string): readonly string[];
}
/**
 * A class that creates icons for the map system waypoint renderer.
 */
declare class MapSystemIconFactory implements MapWaypointRendererIconFactory<Waypoint> {
    private readonly cache;
    private readonly iconFactories;
    private readonly defaultIconFactories;
    /**
     * Adds an icon factory to the container.
     * @param role The role that this icon factory will be assigned to.
     * @param iconType The unique string type name of the icon.
     * @param factory The factory that will produce the icon.
     */
    addIconFactory<T extends Waypoint>(role: number, iconType: string, factory: (waypoint: T) => MapWaypointIcon<T>): void;
    /**
     * Adds a default icon factory for a role.
     * @param role The role to add a default icon factory for.
     * @param factory The factory that will produce the icons.
     */
    addDefaultIconFactory<T extends Waypoint>(role: number, factory: (waypoint: T) => MapWaypointIcon<T>): void;
    /** @inheritdoc */
    getIcon<T extends Waypoint>(role: number, waypoint: T): MapWaypointIcon<T>;
    /**
     * Creates a new icon for a waypoint.
     * @param role The role that has been selected to render.
     * @param waypoint The waypoint for which to create an icon.
     * @returns a waypoint icon.
     */
    private createIcon;
}
/**
 * A class that create labels for the map system waypoint renderer.
 */
declare class MapSystemLabelFactory implements MapWaypointRendererLabelFactory<Waypoint> {
    private readonly cache;
    private readonly labelFactories;
    private readonly defaultLabelFactories;
    /**
     * Adds an label factory to the container.
     * @param role The role to add this label factory for.
     * @param iconType The unique string type name of the waypoint.
     * @param factory The factory that will produce the waypoint label.
     */
    addLabelFactory<T extends Waypoint>(role: number, iconType: string, factory: (waypoint: T) => MapCullableLocationTextLabel): void;
    /**
     * Adds a default label factory for a role.
     * @param role The role to add a default label factory for.
     * @param factory The factory that will produce the labels.
     */
    addDefaultLabelFactory<T extends Waypoint>(role: number, factory: (waypoint: T) => MapCullableLocationTextLabel): void;
    /** @inheritdoc */
    getLabel<T extends Waypoint>(role: number, waypoint: T): MapCullableTextLabel;
    /**
     * Creates a new label for a waypoint.
     * @param role The role that has been selected to render.
     * @param waypoint The waypoint to create a label for.
     * @returns A new waypoint label.
     */
    createLabel(role: number, waypoint: Waypoint): MapCullableLocationTextLabel;
}

/**
 * Modules required by MapSystemFlightPlanLayer.
 */
interface MapSystemFlightPlanLayerModules {
    /** Flight plan module. */
    [MapSystemKeys.FlightPlan]: MapFlightPlanModule;
}
/** Props on the MapSystemFlightPlanLayer component. */
interface MapSystemFlightPlanLayerProps extends MapLayerProps<MapSystemFlightPlanLayerModules> {
    /** An instance of the event bus. */
    bus: EventBus;
    /** The waypoint renderer to use with this instance. */
    waypointRenderer: MapSystemWaypointsRenderer;
    /** The icon factory to use with this instance. */
    iconFactory: MapSystemIconFactory;
    /** The label factory to use with this instance. */
    labelFactory: MapSystemLabelFactory;
    /** The flight plan renderer to use with this instance. */
    flightPathRenderer: MapSystemPlanRenderer;
    /** The flight plan index to display. */
    planIndex: number;
}
/**
 * A map system layer that draws the flight plan.
 */
declare class MapSystemFlightPlanLayer extends MapLayer<MapSystemFlightPlanLayerProps> {
    private static readonly CLIP_BOUNDS_BUFFER;
    protected readonly flightPathLayerRef: NodeReference<MapCachedCanvasLayer<MapCachedCanvasLayerProps<any>>>;
    protected readonly waypointLayerRef: NodeReference<MapSyncedCanvasLayer<MapCanvasLayerProps<any>>>;
    protected readonly defaultRoleId: number;
    protected readonly planModule: MapFlightPlanModule;
    protected readonly legWaypoints: Map<LegDefinition, [Waypoint, number]>;
    protected waypointsUpdating: boolean;
    protected readonly facLoader: FacilityLoader;
    protected readonly facWaypointCache: FacilityWaypointCache;
    protected readonly clipBounds: VecNSubject;
    protected readonly clippedPathStream: ClippedPathStream;
    protected readonly pathStreamStack: GeoProjectionPathStreamStack;
    protected updateScheduled: boolean;
    /** @inheritdoc */
    onAttached(): void;
    /**
     * Initializes the waypoint renderer for this layer.
     */
    protected initWaypointRenderer(): void;
    /** @inheritdoc */
    onUpdated(time: number, elapsed: number): void;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /** @inheritdoc */
    setVisible(val: boolean): void;
    /**
     * Updates waypoints for the flight plan.
     * @throws An error if the waypoints are already updating.
     */
    protected updateWaypoints(): Promise<void>;
    /**
     * Builds or refreshes a flight plan waypoint.
     * @param leg The leg to build the waypoint for.
     * @param roleId The role ID to assign to the waypoint.
     */
    protected buildPlanWaypoint(leg: LegDefinition, roleId: number): Promise<void>;
    /**
     * Builds a flight path terminator based waypoint.
     * @param leg The leg to build the waypoint for.
     * @param roleId The role ID to assign to the waypoint.
     */
    protected buildTerminatorWaypoint(leg: LegDefinition, roleId: number): Promise<void>;
    /**
     * Builds a standard facility fix waypoint for flight plan waypoint display.
     * @param leg The leg to build the waypoint for.
     * @param roleId The role ID to assign to the waypoint.
     */
    protected buildFixWaypoint(leg: LegDefinition, roleId: number): Promise<void>;
    /** @inheritdoc */
    render(): VNode;
}

/**
 * ADS-B operating modes.
 */
declare enum AdsbOperatingMode {
    Standby = "Standby",
    Surface = "Surface",
    Airborne = "Airborne"
}
/**
 * ADS-B events.
 */
interface AdsbEvents {
    /** The ADS-B operating mode. */
    adsb_operating_mode: AdsbOperatingMode;
}
/**
 * An ADS-B system.
 */
declare class Adsb {
    protected readonly bus: EventBus;
    protected readonly operatingMode: Subject<AdsbOperatingMode>;
    protected readonly eventSubscriber: EventSubscriber<AdsbEvents>;
    /**
     * Constructor.
     * @param bus The event bus.
     */
    constructor(bus: EventBus);
    /**
     * Gets this system's operating mode.
     * @returns This system's operating mode.
     */
    getOperatingMode(): AdsbOperatingMode;
    /**
     * Sets this system's operating mode.
     * @param mode The new operating mode.
     */
    setOperatingMode(mode: AdsbOperatingMode): void;
    /**
     * Gets an event bus subscriber for TCAS events.
     * @returns an event bus subscriber for TCAS events..
     */
    getEventSubscriber(): EventSubscriber<AdsbEvents>;
    /**
     * Initializes this ADS-B system.
     */
    init(): void;
}

/**
 * TCAS operating modes.
 */
declare enum TcasOperatingMode {
    Standby = 0,
    TAOnly = 1,
    TA_RA = 2
}
/**
 * TCAS alert level.
 */
declare enum TcasAlertLevel {
    None = 0,
    ProximityAdvisory = 1,
    TrafficAdvisory = 2,
    ResolutionAdvisory = 3
}
/**
 * A time-of-closest-approach prediction made by TCAS.
 */
interface TcasTcaPrediction {
    /** Whether this prediction is valid. */
    readonly isValid: boolean;
    /** The time at which this prediction was most recently updated, as a UNIX timestamp in milliseconds. */
    readonly time: number;
    /** The predicted time-to-closest-approach at the time of the most recent update. */
    readonly tca: NumberUnitReadOnly<UnitFamily.Duration>;
    /**
     * The predicted 3D displacement vector from own airplane to this prediction's intruder at time of closest approach.
     * Each component is expressed in units of meters.
     */
    readonly tcaDisplacement: ReadonlyFloat64Array;
    /**
     * The cylindrical norm of the predicted displacement vector between this prediction's intruder and own airplane at
     * time of closest approach. A value less than or equal to 1 indicates the intruder will be inside the protected
     * zone. Larger values correspond to greater separation.
     */
    readonly tcaNorm: number;
    /** The predicted horizontal separation between this prediction's intruder and own airplane at time of closest approach. */
    readonly tcaHorizontalSep: NumberUnitReadOnly<UnitFamily.Distance>;
    /** The predicted vertical separation between this prediction's intruder and own airplane at time of closest approach. */
    readonly tcaVerticalSep: NumberUnitReadOnly<UnitFamily.Distance>;
}
/**
 * An intruder tracked by TCAS.
 */
interface TcasIntruder {
    /** The traffic contact associated with this intruder. */
    readonly contact: TrafficContact;
    /** A subscribable which provides the alert level assigned to this intruder. */
    readonly alertLevel: Subscribable<TcasAlertLevel>;
    /** The position of this intruder at the time of the most recent update. */
    readonly position: GeoPointReadOnly;
    /** The altitude of this intruder at the time of the most recent update. */
    readonly altitude: NumberUnitReadOnly<UnitFamily.Distance>;
    /** The true ground track of this intruder at the time of the most recent update. */
    readonly groundTrack: number;
    /** The ground speed of this intruder at the time of the most recent update. */
    readonly groundSpeed: NumberUnitReadOnly<UnitFamily.Speed>;
    /** The vertical speed of this intruder at the time of the most recent update. */
    readonly verticalSpeed: NumberUnitReadOnly<UnitFamily.Speed>;
    /**
     * The 3D position vector of this intruder at the time of the last update. Each component is expressed in units of
     * meters. The coordinate system is an Euclidean approximation of the geodetic space around the own airplane such
     * that the z-coordinate represents orthometric height and the x- and y-coordinates represent an east-
     * counterclockwise equirectangular projection of latitude and longitude, with the origin at the location of the own
     * airplane.
     */
    readonly positionVec: ReadonlyFloat64Array;
    /**
     * The 3D velocity vector of this intruder at the time of the last update. Each component is expressed in units of
     * meters per second. The coordinate system is defined the same as for position vectors.
     */
    readonly velocityVec: ReadonlyFloat64Array;
    /** The 3D position vector of this intruder relative to own airplane. */
    readonly relativePositionVec: ReadonlyFloat64Array;
    /** The 3D velocity vector of this intruder relative to own airplane. */
    readonly relativeVelocityVec: ReadonlyFloat64Array;
    /** Whether there is a valid prediction for this intruder's position and velocity. */
    readonly isPredictionValid: boolean;
    /** A time-of-closest-approach prediction for this intruder using sensitivity settings for traffic advisories. */
    readonly tcaTA: TcasTcaPrediction;
    /** A time-of-closest-approach prediction for this intruder using sensitivity settings for resolution advisories. */
    readonly tcaRA: TcasTcaPrediction;
    /**
     * Calculates the predicted 3D displacement vector from own airplane to this intruder at a specified time based on
     * the most recent available data. If insufficient data is available to calculate the prediction, NaN will be written
     * to the result.
     * @param simTime The sim time at which to calculate the separation, as a UNIX timestamp in milliseconds.
     * @param out A Float64Array object to which to write the result.
     * @returns The predicted displacement vector from own airplane to this intruder at the specified time.
     */
    predictDisplacement(simTime: number, out: Float64Array): Float64Array;
    /**
     * Calculates the predicted separation between this intruder and own airplane at a specified time based on the most
     * recent available data and stores the results in the supplied WT_NumberUnit objects. If insufficient data is
     * available to calculate the prediction, NaN will be written to the results.
     * @param simTime The sim time at which to calculate the separation, as a UNIX timestamp in milliseconds.
     * @param horizontalOut A NumberUnit object to which to write the horizontal separation.
     * @param verticalOut A NumberUnit object to which to write the vertical separation.
     */
    predictSeparation(simTime: number, horizontalOut: NumberUnit<UnitFamily.Distance>, verticalOut: NumberUnit<UnitFamily.Distance>): void;
}
/**
 * TCAS parameters for advisories defining the protected zone around the own airplane.
 */
interface TcasAdvisoryParameters {
    /** A subscribable which provides the radius of the own airplane's protected zone. */
    readonly protectedRadius: NumberUnitInterface<UnitFamily.Distance>;
    /** A subscribable which provides the half-height of the own airplane's protected zone. */
    readonly protectedHeight: NumberUnitInterface<UnitFamily.Distance>;
}
/**
 * TCAS parameters for time-of-closest-approach calculations.
 */
interface TcasTcaParameters extends TcasAdvisoryParameters {
    /** A subscribable which provides the lookahead time for TCA calculations. */
    readonly lookaheadTime: NumberUnitInterface<UnitFamily.Duration>;
}
/**
 * A full set of TCAS sensitivity parameters.
 */
declare type TcasSensitivityParameters = {
    /**
     * Protected zone parameters for proximity advisories. If any parameters have a value of `NaN`, proximity advisories
     * will not be issued.
     */
    readonly parametersPA: TcasAdvisoryParameters;
    /**
     * Parameters for time-of-closest-approach calculations for traffic advisories. If any parameters have a value of
     * `NaN`, traffic advisories will not be issued.
     */
    readonly parametersTA: TcasTcaParameters;
    /**
     * Parameters for time-of-closest-approach calculations for resolution advisories. If any parameters have a value of
     * `NaN`, resolution advisories will not be issued.
     */
    readonly parametersRA: TcasTcaParameters;
};
/**
 * Sensitivity settings for TCAS.
 */
interface TcasSensitivity<I extends TcasIntruder = TcasIntruder> {
    /**
     * Selects sensitivity parameters for an intruder.
     * @param intruder An intruder.
     * @returns Sensitivity parameters for the specified intruder.
     */
    selectParameters(intruder: I): TcasSensitivityParameters;
    /**
     * Selects an ALIM for a resolution advisory.
     * @param intruders The intruders involved in the resolution advisory.
     * @returns An ALIM for a resolution advisory involving the specified intruders.
     */
    selectRAAlim(intruders: ReadonlySet<I>): NumberUnitInterface<UnitFamily.Distance>;
}
/**
 * Bit flags describing TCAS resolution advisories.
 */
declare enum TcasResolutionAdvisoryFlags {
    /** An initial resolution advisory. */
    Initial = 1,
    /** A corrective resolution advisory. Requires a change in the own airplane's vertical speed. */
    Corrective = 2,
    /** An upward sense resolution advisory. Commands a vertical speed above a certain value. */
    UpSense = 4,
    /** A downward sense resolution advisory. Commands a vertical speed below a certain value. */
    DownSense = 8,
    /** A resolution advisory which crosses an intruder's altitude. */
    Crossing = 16,
    /** A CLIMB resolution advisory. Commands a positive vertical speed above 1500 FPM. */
    Climb = 32,
    /** A DESCEND resolution advisory. Commands a negative vertical speed below -1500 FPM. */
    Descend = 64,
    /** An INCREASE CLIMB or INCREASE DESCENT resolution advisory. Commands a vertical speed above 2500 FPM or below -2500 FPM. */
    Increase = 128,
    /** A corrective REDUCE CLIMB resolution advisory. Commands a vertical speed of 0 FPM or less. */
    ReduceClimb = 256,
    /** A corrective REDUCE DESCENT resolution advisory. Commands a vertical speed of 0 FPM or more. */
    ReduceDescent = 512,
    /** A preventative DO NOT CLIMB resolution advisory. Commands a non-positive vertical speed. */
    DoNotClimb = 1024,
    /** A preventative DO NOT DESCEND resolution advisory. Commands a non-negative vertical speed. */
    DoNotDescend = 2048
}
/**
 * A TCAS resolution advisory.
 */
interface TcasResolutionAdvisory {
    /** This resolution advisory's active intruders, sorted in order of increasing time to closest approach. */
    readonly intruders: readonly TcasIntruder[];
    /** The upper vertical speed limit placed by this resolution advisory. A value of `NaN` indicates no limit. */
    readonly maxVerticalSpeed: NumberUnitReadOnly<UnitFamily.Speed>;
    /** The lower vertical speed limit placed by this resolution advisory. A value of `NaN` indicates no limit. */
    readonly minVerticalSpeed: NumberUnitReadOnly<UnitFamily.Speed>;
    /** A combination of {@link TcasResolutionAdvisoryFlags} entries describing this resolution advisory. */
    readonly flags: number;
}
/**
 * TCAS events.
 */
interface TcasEvents {
    /** The TCAS operating mode changed. */
    tcas_operating_mode: TcasOperatingMode;
    /** A new intruder was created. */
    tcas_intruder_added: TcasIntruder;
    /** The alert level of an intruder was changed. */
    tcas_intruder_alert_changed: TcasIntruder;
    /** An intruder was removed. */
    tcas_intruder_removed: TcasIntruder;
    /** The number of intruders associated with active traffic advisories. */
    tcas_ta_intruder_count: number;
    /** The number of intruders associated with an active resolution advisory. */
    tcas_ra_intruder_count: number;
    /** An initial resolution advisory has been issued. */
    tcas_ra_issued: TcasResolutionAdvisory;
    /** An active resolution advisory has been updated. */
    tcas_ra_updated: TcasResolutionAdvisory;
    /** A resolution advisory has been canceled. */
    tcas_ra_canceled: void;
}
/**
 * Options to adjust how resolution advisories are calculated by TCAS.
 */
declare type TcasResolutionAdvisoryOptions = {
    /** The assumed response time of the own airplane following an initial resolution advisory. */
    readonly initialResponseTime: NumberUnitInterface<UnitFamily.Duration>;
    /** The assumed acceleration of the own airplane following an initial resolution advisory. */
    readonly initialAcceleration: NumberUnitInterface<UnitFamily.Acceleration>;
    /** The assumed response time of the own airplane following an updated resolution advisory. */
    readonly subsequentResponseTime: NumberUnitInterface<UnitFamily.Duration>;
    /** The assumed acceleration of the own airplane following an updated resolution advisory. */
    readonly subsequentAcceleration: NumberUnitInterface<UnitFamily.Acceleration>;
    /** A function which determines whether to allow a CLIMB resolution advisory. */
    allowClimb: (simTime: number) => boolean;
    /** A function which determines whether to allow an INCREASE CLIMB resolution advisory. */
    allowIncreaseClimb: (simTime: number) => boolean;
    /** A function which determines whether to allow a DESCEND resolution advisory. */
    allowDescend: (simTime: number) => boolean;
    /** A function which determines whether to allow an INCREASE DESCENT resolution advisory. */
    allowIncreaseDescent: (simTime: number) => boolean;
};
/**
 * A TCAS-II-like system.
 */
declare abstract class Tcas<I extends AbstractTcasIntruder = AbstractTcasIntruder, S extends TcasSensitivity = TcasSensitivity> {
    protected readonly bus: EventBus;
    protected readonly tfcInstrument: TrafficInstrument;
    protected readonly maxIntruderCount: number;
    protected readonly realTimeUpdateFreq: number;
    protected readonly simTimeUpdateFreq: number;
    private static readonly DEFAULT_RA_OPTIONS;
    protected readonly operatingModeSub: Subject<TcasOperatingMode>;
    protected readonly sensitivity: S;
    protected readonly ownAirplane: OwnAirplane;
    protected readonly intrudersSorted: I[];
    protected intrudersFiltered: I[];
    protected readonly intrudersRA: Set<I>;
    protected readonly resolutionAdvisory: TcasResolutionAdvisoryClass;
    private contactCreatedConsumer;
    private contactRemovedConsumer;
    private readonly contactCreatedHandler;
    private readonly contactRemovedHandler;
    protected readonly ownAirplaneSubs: {
        position: GeoPointSubject;
        altitude: NumberUnitSubject<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
        groundTrack: ConsumerSubject<number>;
        groundSpeed: NumberUnitSubject<UnitFamily.Speed, CompoundUnit<UnitFamily.Speed>>;
        verticalSpeed: NumberUnitSubject<UnitFamily.Speed, CompoundUnit<UnitFamily.Speed>>;
        radarAltitude: NumberUnitSubject<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
        isOnGround: ConsumerSubject<boolean>;
    };
    protected readonly simTime: ConsumerSubject<number>;
    protected lastUpdateSimTime: number;
    protected lastUpdateRealTime: number;
    private readonly alertLevelSubs;
    private readonly eventPublisher;
    private readonly eventSubscriber;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param tfcInstrument The traffic instrument which provides traffic contacts for this TCAS.
     * @param maxIntruderCount The maximum number of intruders tracked at any one time by this TCAS.
     * @param realTimeUpdateFreq The maximum update frequency (Hz) in real time.
     * @param simTimeUpdateFreq The maximum update frequency (Hz) in sim time.
     * @param raOptions Options to adjust how resolution advisories are calculated.
     */
    constructor(bus: EventBus, tfcInstrument: TrafficInstrument, maxIntruderCount: number, realTimeUpdateFreq: number, simTimeUpdateFreq: number, raOptions?: Partial<TcasResolutionAdvisoryOptions>);
    /**
     * Creates a TCAS sensitivity object.
     * @returns A TCAS sensitivity object.
     */
    protected abstract createSensitivity(): S;
    /**
     * Gets this system's operating mode.
     * @returns This system's operating mode.
     */
    getOperatingMode(): TcasOperatingMode;
    /**
     * Sets this system's operating mode.
     * @param mode The new operating mode.
     */
    setOperatingMode(mode: TcasOperatingMode): void;
    /**
     * Gets an array of all currently tracked intruders. The intruders are sorted in order of decreasing threat.
     * @returns an array of all currently tracked intruders.
     */
    getIntruders(): readonly TcasIntruder[];
    /**
     * Gets an event bus subscriber for TCAS events.
     * @returns an event bus subscriber for TCAS events..
     */
    getEventSubscriber(): EventSubscriber<TcasEvents>;
    /**
     * Initializes this system.
     */
    init(): void;
    /**
     * Responds to changes in this TCAS's operating mode.
     * @param mode The current operating mode.
     */
    protected onOperatingModeChanged(mode: TcasOperatingMode): void;
    /**
     * Sorts two intruders.
     * @param a The first intruder.
     * @param b The second intruder.
     * @returns A negative number if `a` is to be sorted before `b`, a positive number if `b` is to be sorted before `a`,
     * and zero if the two are equal.
     */
    protected intruderComparator(a: I, b: I): number;
    /**
     * Creates a TCAS intruder entry from a traffic contact.
     * @param contact A traffic contact.
     */
    protected abstract createIntruderEntry(contact: TrafficContact): I;
    /**
     * A callback which is called when a new traffic contact is added by this system's traffic instrument.
     * @param uid The ID number of the new contact.
     */
    private onContactAdded;
    /**
     * A callback which is called when a traffic contact is removed by this system's traffic instrument.
     * @param uid The ID number of the removed contact.
     */
    private onContactRemoved;
    /**
     * A callback which is called when the sim time changes.
     * @param simTime The current sim time.
     */
    private onSimTimeChanged;
    /**
     * Executes an update.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    protected doUpdate(simTime: number): void;
    protected abstract updateSensitivity(): void;
    /**
     * Updates the TCA predictions for all intruders tracked by this system.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    protected updateIntruderPredictions(simTime: number): void;
    /**
     * Updates the arrays of intruders tracked by this system.
     */
    protected updateIntruderArrays(): void;
    /**
     * Filters an intruder.
     * @param intruder An intruder.
     * @returns Whether the intruder should be tracked by this TCAS.
     */
    protected filterIntruder(intruder: I): boolean;
    /**
     * Updates the alert levels for all intruders tracked by this system that have not been filtered out.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    protected updateFilteredIntruderAlertLevels(simTime: number): void;
    protected readonly paSeparationCache: {
        horizontal: NumberUnit<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
        vertical: NumberUnit<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
    };
    /**
     * Updates an intruder's alert level.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     */
    protected updateIntruderAlertLevel(simTime: number, intruder: I): void;
    /**
     * Checks whether a resolution advisory can be issued for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a resolution advisory can be issued for the intruder.
     */
    protected canIssueResolutionAdvisory(simTime: number, intruder: I): boolean;
    /**
     * Checks whether a resolution advisory can be canceled for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a resolution advisory can be issued for the intruder.
     */
    protected canCancelResolutionAdvisory(simTime: number, intruder: I): boolean;
    /**
     * Checks whether a traffic advisory can be issued for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a traffic advisory can be issued for the intruder.
     */
    protected canIssueTrafficAdvisory(simTime: number, intruder: I): boolean;
    /**
     * Checks whether a traffic advisory can be canceled for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a traffic advisory can be canceled for the intruder.
     */
    protected canCancelTrafficAdvisory(simTime: number, intruder: I): boolean;
    /**
     * Checks whether a proximity advisory can be issued for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a proximity advisory can be issued for the intruder.
     */
    protected canIssueProximityAdvisory(simTime: number, intruder: I): boolean;
    /**
     * Checks whether a proximity advisory can be canceled for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a proximity advisory can be canceled for the intruder.
     */
    protected canCancelProximityAdvisory(simTime: number, intruder: I): boolean;
    /**
     * Updates this TCAS's resolution advisory.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    protected updateResolutionAdvisory(simTime: number): void;
    /**
     * Executes initialization code when an intruder is added.
     * @param intruder The newly added intruder.
     */
    private initIntruder;
    /**
     * Executes cleanup code when an intruder is removed.
     * @param intruder The intruder that was removed.
     */
    private cleanUpIntruder;
    /**
     * A callback which is called when an intruder's alert level changes.
     * @param intruder The intruder whose alert level changed.
     */
    private onAlertLevelChanged;
}
/**
 * Subscribables which provide data related to the own airplane.
 */
declare type TcasOwnAirplaneSubs = {
    /** A subscribable which provides the own airplane's position. */
    position: Subscribable<GeoPointInterface>;
    /** A subscribable which provides the own airplane's altitude. */
    altitude: Subscribable<NumberUnitInterface<UnitFamily.Distance>>;
    /** A subscribable which provides the own airplane's ground track. */
    groundTrack: Subscribable<number>;
    /** A subscribable which provides the own airplane's ground speed. */
    groundSpeed: Subscribable<NumberUnitInterface<UnitFamily.Speed>>;
    /** A subscribable which provides the own airplane's vertical speed. */
    verticalSpeed: Subscribable<NumberUnitInterface<UnitFamily.Speed>>;
    /** A subscribable which provides the own airplane's radar altitude. */
    radarAltitude: Subscribable<NumberUnitInterface<UnitFamily.Distance>>;
    /** A subscribable which provides whether the own airplane is on the ground. */
    isOnGround: Subscribable<boolean>;
};
/**
 * An airplane managed by TCAS.
 */
declare abstract class TcasAirplane {
    protected readonly _position: GeoPoint;
    /** The position of this airplane at the time of the most recent update. */
    readonly position: GeoPointReadOnly;
    /** The altitude of this airplane at the time of the most recent update. */
    protected readonly _altitude: NumberUnit<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
    readonly altitude: NumberUnitReadOnly<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
    protected _groundTrack: number;
    /** The true ground track of this airplane at the time of the most recent update. */
    get groundTrack(): number;
    /** The ground speed of this airplane at the time of the most recent update. */
    protected readonly _groundSpeed: NumberUnit<UnitFamily.Speed, CompoundUnit<UnitFamily.Speed>>;
    readonly groundSpeed: NumberUnitReadOnly<UnitFamily.Speed, CompoundUnit<UnitFamily.Speed>>;
    /** The vertical speed of this airplane at the time of the most recent update. */
    protected readonly _verticalSpeed: NumberUnit<UnitFamily.Speed, CompoundUnit<UnitFamily.Speed>>;
    readonly verticalSpeed: NumberUnitReadOnly<UnitFamily.Speed, CompoundUnit<UnitFamily.Speed>>;
    /**
     * The 3D position vector of this airplane at the time of the last update. Each component is expressed in units of
     * meters. The coordinate system is an Euclidean approximation of the geodetic space around the own airplane such
     * that the z-coordinate represents orthometric height and the x- and y-coordinates represent an east-
     * counterclockwise equirectangular projection of latitude and longitude, with the origin at the location of the own
     * airplane.
     */
    readonly positionVec: Float64Array;
    /**
     * The 3D velocity vector of this airplane at the time of the last update. Each component is expressed in units of
     * meters per second. The coordinate system is defined the same as for position vectors.
     */
    readonly velocityVec: Float64Array;
    protected lastUpdateTime: number;
}
/**
 * The own airplane managed by TCAS.
 */
declare class OwnAirplane extends TcasAirplane {
    private readonly subs;
    /** The radar altitude of this airplane at the time of the most recent update. */
    protected readonly _radarAltitude: NumberUnit<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
    readonly radarAltitude: NumberUnitReadOnly<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
    private _isOnGround;
    /** Whether this airplane is on the ground. */
    get isOnGround(): boolean;
    /**
     * Constructor.
     * @param subs Subscribables which provide data related to this airplane.
     */
    constructor(subs: TcasOwnAirplaneSubs);
    /**
     * Calculates the predicted 3D position vector of this airplane at a specified time based on the most recent
     * available data. Each component of the vector is expressed in units of meters, and the origin lies at the most
     * recent updated position of this airplane.
     * @param simTime The sim time at which to calculate the position, as a UNIX timestamp in milliseconds.
     * @param out A Float64Array object to which to write the result.
     * @returns The predicted position vector of this airplane at the specified time.
     */
    predictPosition(simTime: number, out: Float64Array): Float64Array;
    /**
     * Updates this airplane's position and velocity data.
     * @param simTime The current sim time, as a UNIX millisecond timestamp.
     */
    update(simTime: number): void;
    /**
     * Updates this airplane's position, altitude, ground track, ground speed, vertical speed, and whether it is on the ground.
     */
    private updateParameters;
    /**
     * Updates this airplane's position and velocity vectors.
     */
    private updateVectors;
}
/**
 * An abstract implementation of {@link TcasIntruder}.
 */
declare abstract class AbstractTcasIntruder extends TcasAirplane implements TcasIntruder {
    readonly contact: TrafficContact;
    private static readonly MIN_GROUND_SPEED;
    private static readonly vec3Cache;
    readonly alertLevel: Subject<TcasAlertLevel>;
    /** The 3D position vector of this intruder relative to own airplane. */
    readonly relativePositionVec: Float64Array;
    /** The 3D velocity vector of this intruder relative to own airplane. */
    readonly relativeVelocityVec: Float64Array;
    private _isPredictionValid;
    /** Whether there is a valid prediction for time of closest approach between this intruder and own airplane. */
    get isPredictionValid(): boolean;
    /** @inheritdoc */
    readonly tcaTA: TcasTcaPredictionClass;
    /** @inheritdoc */
    readonly tcaRA: TcasTcaPredictionClass;
    /**
     * Constructor.
     * @param contact The traffic contact associated with this intruder.
     */
    constructor(contact: TrafficContact);
    /** @inheritdoc */
    predictDisplacement(simTime: number, out: Float64Array): Float64Array;
    /** @inheritdoc */
    predictSeparation(simTime: number, horizontalOut: NumberUnit<UnitFamily.Distance>, verticalOut: NumberUnit<UnitFamily.Distance>): void;
    /**
     * Updates this intruder's predicted TCA and related data.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplane Own airplane.
     * @param sensitivity The TCAS sensitivity parameters to use when calculating predictions.
     */
    updatePrediction(simTime: number, ownAirplane: OwnAirplane, sensitivity: TcasSensitivityParameters): void;
    /**
     * Updates this intruder's position and velocity data.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplane The own airplane.
     */
    private updateParameters;
    /**
     * Updates this intruder's position.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplane The own airplane.
     */
    private updatePosition;
    /**
     * Updates this intruder's velocity.
     * @param ownAirplane The own airplane.
     */
    private updateVelocity;
    /**
     * Invalidates this intruder's predicted TCA and related data.
     */
    private invalidatePredictions;
    /**
     * Converts a 3D displacement vector to a horizontal separation distance.
     * @param displacement A displacement vector, in meters.
     * @param out A NumberUnit object to which to write the result.
     * @returns The horizontal separation distance corresponding to the displacement vector.
     */
    static displacementToHorizontalSeparation(displacement: Float64Array, out: NumberUnit<UnitFamily.Distance>): NumberUnit<UnitFamily.Distance>;
    /**
     * Converts a 3D displacement vector to a vertical separation distance.
     * @param displacement A displacement vector, in meters.
     * @param out A NumberUnit object to which to write the result.
     * @returns The vertical separation distance corresponding to the displacement vector.
     */
    static displacementToVerticalSeparation(displacement: Float64Array, out: NumberUnit<UnitFamily.Distance>): NumberUnit<UnitFamily.Distance>;
}
/**
 * An default implementation of {@link TcasIntruder}.
 */
declare class DefaultTcasIntruder extends AbstractTcasIntruder {
}
/**
 * A time-of-closest-approach prediction made by TCAS.
 */
declare class TcasTcaPredictionClass implements TcasTcaPrediction {
    private readonly intruder;
    private static readonly vec2Cache;
    private static readonly solutionCache;
    private _isValid;
    /** @inheritdoc */
    get isValid(): boolean;
    private _time;
    /** @inheritdoc */
    get time(): number;
    private readonly _tca;
    /** @inheritdoc */
    readonly tca: NumberUnitReadOnly<UnitFamily.Duration, SimpleUnit<UnitFamily.Duration>>;
    private _tcaNorm;
    /** @inheritdoc */
    get tcaNorm(): number;
    /** @inheritdoc */
    readonly tcaDisplacement: Float64Array;
    private readonly _tcaHorizontalSep;
    /** @inheritdoc */
    readonly tcaHorizontalSep: NumberUnitReadOnly<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
    private readonly _tcaVerticalSep;
    /** @inheritdoc */
    readonly tcaVerticalSep: NumberUnitReadOnly<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
    /**
     * Constructor.
     * @param intruder The intruder associated with this prediction.
     */
    constructor(intruder: TcasIntruder);
    /**
     * Updates the time-to-closest-approach (TCA) and related data of this intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param lookaheadTime The maximum lookahead time.
     * @param protectedRadius The radius of the own airplane's protected zone.
     * @param protectedHeight The half-height of the own airplane's protected zone.
     */
    update(simTime: number, lookaheadTime: NumberUnitInterface<UnitFamily.Duration>, protectedRadius: NumberUnitInterface<UnitFamily.Distance>, protectedHeight: NumberUnitInterface<UnitFamily.Distance>): void;
    /**
     * Invalidates this intruder's predicted TCA and related data.
     */
    invalidate(): void;
    /**
     * Evaluates a TCA candidate against the best existing solution, and if the candidate produces a smaller cylindrical
     * norm, replaces the best existing solution with the candidate.
     * @param t The candidate TCA time, in seconds.
     * @param s The relative position vector of the intruder, in meters.
     * @param v The relative velocity vector of the intruder, in meters per second.
     * @param r The radius of the own airplane's protected zone, in meters.
     * @param h The half-height of the own airplane's protected zone, in meters.
     * @param best The best existing solution.
     * @param candidate A TcaSolution object to which to temporarily write the candidate solution.
     */
    private static evaluateCandidate;
    /**
     * Calculates a TCA solution.
     * @param t The candidate TCA time, in seconds.
     * @param s The relative position vector of the intruder, in meters.
     * @param v The relative velocity vector of the intruder, in meters per second.
     * @param r The radius of the own airplane's protected zone, in meters.
     * @param h The half-height of the own airplane's protected zone, in meters.
     * @param out A TcaSolution object to which to write the result.
     * @returns A TCA solution.
     */
    private static calculateSolution;
    /**
     * Copies a TCA solution.
     * @param from The solution from which to copy.
     * @param to The solution to which to copy.
     */
    private static copySolution;
    /**
     * Calculates a time-offset displacement vector given an initial displacement, a velocity vector, and elapsed time.
     * @param initial The initial displacement vector.
     * @param velocity A velocity vector.
     * @param elapsedTime The elapsed time.
     * @param out A Float64Array object to which to write the result.
     * @returns The time-offset displacement vector.
     */
    private static calculateDisplacementVector;
    /**
     * Calculates a cylindrical norm.
     * @param vector A displacement vector.
     * @param radius The radius of the protected zone.
     * @param halfHeight The half-height of the protected zone.
     * @returns A cylindrical norm.
     */
    private static calculateCylindricalNorm;
}
/**
 * A TCAS resolution advisory.
 */
declare class TcasResolutionAdvisoryClass implements TcasResolutionAdvisory {
    private readonly options;
    private readonly ownAirplane;
    private static readonly CLIMB_DESC_VS_MPS;
    private static readonly INC_CLIMB_DESC_VS_MPS;
    private static readonly VSL_MAX_VS_MPS;
    private static readonly VSL_VS_STEP_MPS;
    private static readonly INTRUDER_SORT_FUNC;
    private static readonly vec3Cache;
    private static readonly senseCandidateCache;
    readonly intruders: TcasIntruder[];
    private readonly _maxVerticalSpeed;
    /** @inheritdoc */
    readonly maxVerticalSpeed: NumberUnitReadOnly<UnitFamily.Speed, CompoundUnit<UnitFamily.Speed>>;
    private readonly _minVerticalSpeed;
    /** @inheritdoc */
    readonly minVerticalSpeed: NumberUnitReadOnly<UnitFamily.Speed, CompoundUnit<UnitFamily.Speed>>;
    private _flags;
    /** @inheritdoc */
    get flags(): number;
    private isActive;
    private timeUpdated;
    private canReverseSense;
    private readonly publisher;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param options Options to adjust how this resolution advisory should be calculated.
     * @param ownAirplane The own airplane of this resolution advisory.
     */
    constructor(bus: EventBus, options: TcasResolutionAdvisoryOptions, ownAirplane: OwnAirplane);
    /**
     * Updates this resolution advisory.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param alim The required vertical separation between own airplane and intruders.
     * @param intruders The set of active intruders to be tracked by this resolution advisory.
     */
    update(simTime: number, alim: NumberUnitInterface<UnitFamily.Distance>, intruders: ReadonlySet<TcasIntruder>): void;
    /**
     * Activates this resolution advisory.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param alim The required vertical separation between own airplane and intruders.
     * @param intruders The set of active intruders to be tracked by this resolution advisory.
     */
    private activate;
    /**
     * Updates this resolution advisory while it is active.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param alim The required vertical separation between own airplane and intruders.
     * @param intruders The set of active intruders to be tracked by this resolution advisory.
     */
    private updateActive;
    /**
     * Updates this resolution advisory's array of active intruders.
     * @param intruders The set of active intruders to be tracked by this resolution advisory.
     */
    private updateIntrudersArray;
    /**
     * Applies a vertical speed target to this resolution advisory.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param sense The sense of the vertical speed target.
     * @param targetVS The vertical speed target, in meters per second.
     * @param ownAirplaneVS The current vertical speed of the own airplane, in meters per second.
     * @param isCrossing Whether the applied sense crosses an intruder's altitude.
     */
    private apply;
    /**
     * Cancels this resolution advisory.
     */
    private cancel;
    /**
     * Selects the best sense and vertical speed target for a resolution advisory. If the non-crossing sense is able to
     * achieve the target vertical separation, it will be selected. Otherwise, the sense that achieves the greatest
     * vertical separation at time of closest approach will be selected.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param tca The time to closest approach, in seconds.
     * @param alim The minimum target vertical separation, in meters, between the own airplane and intruders at the time
     * of closest approach.
     * @param responseTime The response time of the own airplane, in seconds.
     * @param accel The acceleration of the own airplane, in meters per second squared.
     * @param ownAirplaneAlt The current altitude of the own airplane, in meters.
     * @param ownAirplaneVS The current vertical speed of the own airplane, in meters per second.
     * @param ownAirplaneAltTca The predicted altitude of the own airplane at the time of closest approach, in meters.
     * @param intruderAltTca The predicted altitude of the intruder at the time of closest approach, in meters.
     * @param out The object to which to write the results.
     * @returns Information on the selected sense and vertical speed target.
     */
    private selectSense;
    /**
     * Calculates the vertical speed required to achieve a desired altitude target at time of closest approach.
     * @param tca The time to closest approach from the present, in seconds.
     * @param currentAlt The current altitude of the own airplane, in meters.
     * @param vs The current vertical speed of the own airplane, in meters per second.
     * @param responseTime The response time of the own airplane, in seconds.
     * @param accel The acceleration of the own airplane, in meters per second squared.
     * @param targetAlt The target altitude of the own airplane at time of closest approach, in meters.
     * @returns The vertical speed, in meters per second, required to achieve a desired altitude target at time of
     * closest approach. A value of `NaN` indicates the altitude target cannot be reached with the specified parameters.
     */
    private static calculateVSToTargetAlt;
}

/**
 * Standard TCAS-II sensitivity parameters.
 */
declare class TcasIISensitivityParameters {
    private static readonly PA;
    private static readonly TA_LEVELS;
    private static readonly RA_LEVELS;
    /**
     * Selects a sensitivity level for a specified environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns The sensitivity level for the specified environment.
     */
    selectLevel(altitude: NumberUnitInterface<UnitFamily.Distance>, radarAltitude: NumberUnitInterface<UnitFamily.Distance>): number;
    /**
     * Selects Proximity Advisory sensitivity parameters.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns Proximity Advisory sensitivity parameters.
     */
    selectPA(altitude: NumberUnitInterface<UnitFamily.Distance>, radarAltitude: NumberUnitInterface<UnitFamily.Distance>): TcasAdvisoryParameters;
    /**
     * Selects Traffic Advisory sensitivity parameters for a specified environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns Traffic Advisory sensitivity parameters for the specified environment.
     */
    selectTA(altitude: NumberUnitInterface<UnitFamily.Distance>, radarAltitude: NumberUnitInterface<UnitFamily.Distance>): TcasTcaParameters;
    /**
     * Selects Resolution Advisory sensitivity parameters for a specified environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns Resolution Advisory sensitivity parameters for the specified environment.
     */
    selectRA(altitude: NumberUnitInterface<UnitFamily.Distance>, radarAltitude: NumberUnitInterface<UnitFamily.Distance>): TcasTcaParameters;
    /**
     * Selects a Resolution Advisory ALIM for a specified environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns A Resolution Advisory ALIM for the specified environment.
     */
    selectRAAlim(altitude: NumberUnitInterface<UnitFamily.Distance>, radarAltitude: NumberUnitInterface<UnitFamily.Distance>): NumberUnitInterface<UnitFamily.Distance>;
    /**
     * Gets Proximity Advisory sensitivity parameters for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns Proximity Advisory sensitivity parameters for the given sensitivity level.
     */
    getPA(level: number): TcasAdvisoryParameters;
    /**
     * Gets Traffic Advisory sensitivity parameters for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns Traffic Advisory sensitivity parameters for the given sensitivity level.
     */
    getTA(level: number): TcasTcaParameters;
    /**
     * Gets Resolution Advisory sensitivity parameters for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns Resolution Advisory sensitivity parameters for the given sensitivity level.
     */
    getRA(level: number): TcasTcaParameters;
    /**
     * Gets a Resolution Advisory ALIM for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns A Resolution Advisory ALIM for the given sensitivity level.
     */
    getRAAlim(level: number): NumberUnitInterface<UnitFamily.Distance>;
}
/**
 * An implementation of {@link TCASSensitivity} which provides sensitivity parameters as defined in the official
 * TCAS II specification.
 */
declare class TcasIISensitivity implements TcasSensitivity {
    private readonly sensitivity;
    private level;
    private readonly params;
    /** @inheritdoc */
    selectParameters(): TcasSensitivityParameters;
    /** @inheritdoc */
    selectRAAlim(): NumberUnitInterface<UnitFamily.Distance>;
    /**
     * Updates sensitivity level based on the current environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     */
    updateLevel(altitude: NumberUnitInterface<UnitFamily.Distance>, radarAltitude: NumberUnitInterface<UnitFamily.Distance>): void;
}

/**
 * Traffic alert level modes.
 */
declare enum MapTrafficAlertLevelVisibility {
    Other = 1,
    ProximityAdvisory = 2,
    TrafficAdvisory = 4,
    ResolutionAdvisory = 8,
    All = 15
}
/**
 * A module describing the display of traffic.
 */
declare class MapTrafficModule {
    readonly tcas: Tcas;
    /** Whether to show traffic information. */
    readonly show: Subject<boolean>;
    /** The TCAS operating mode. */
    readonly operatingMode: Subscribable<TcasOperatingMode>;
    /**
     * The distance from the own airplane beyond which intruders are considered off-scale. If the value is `NaN`,
     * intruders are never considered off-scale.
     */
    readonly offScaleRange: NumberUnitSubject<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
    /** Alert level visibility flags. */
    readonly alertLevelVisibility: Subject<number>;
    /** The difference in altitude above the own airplane above which intruders will not be displayed. */
    readonly altitudeRestrictionAbove: NumberUnitSubject<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
    /** The difference in altitude below the own airplane below which intruders will not be displayed. */
    readonly altitudeRestrictionBelow: NumberUnitSubject<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
    /** Whether displayed intruder altitude is relative. */
    readonly isAltitudeRelative: Subject<boolean>;
    /**
     * Creates an instance of a MapTrafficModule.
     * @param tcas This module's associated TCAS.
     */
    constructor(tcas: Tcas);
}

/**
 * Modules required by MapSystemTrafficLayer.
 */
interface MapSystemTrafficLayerModules {
    /** Traffic module. */
    [MapSystemKeys.Traffic]: MapTrafficModule;
}
/**
 * A map icon for a TCAS intruder.
 */
interface MapTrafficIntruderIcon {
    /** This icon's associated intruder. */
    readonly intruder: TcasIntruder;
    /** The projected position of this icon's intruder, in pixel coordinates, at the time it was last drawn. */
    readonly projectedPos: ReadonlyFloat64Array;
    /** Whether this icon's intruder is off-scale at the time it was last drawn. */
    readonly isOffScale: boolean;
    /**
     * Draws this icon.
     * @param projection The map projection.
     * @param context The canvas rendering context to which to draw.
     * @param offScaleRange The distance from the own airplane to this icon's intruder beyond which the intruder is
     * considered off-scale. If the value is `NaN`, the intruder is never considered off-scale.
     */
    draw(projection: MapProjection, context: CanvasRenderingContext2D, offScaleRange: NumberUnitInterface<UnitFamily.Distance>): void;
}
/**
 * A function which creates map icons for TCAS intruders.
 * @param intruder The intruder for which to create an icon.
 * @param context The context of the icon's parent map.
 */
declare type MapTrafficIntruderIconFactory<Modules = any, Layers extends LayerRecord = any, Controllers extends ControllerRecord = any, Context = any> = (intruder: TcasIntruder, context: MapSystemContext<Modules, Layers, Controllers, Context>) => MapTrafficIntruderIcon;
/**
 * Component props for MapSystemTrafficLayer.
 */
interface MapSystemTrafficLayerProps extends MapLayerProps<MapSystemTrafficLayerModules> {
    /** The context of the layer's parent map. */
    context: MapSystemContext<any, any, any, any>;
    /** A function which creates icons for intruders. */
    iconFactory: MapTrafficIntruderIconFactory;
    /**
     * A function which initializes global canvas styles for the layer.
     * @param context The canvas rendering context for which to initialize styles.
     */
    initCanvasStyles?: (context: CanvasRenderingContext2D) => void;
    /** A subscribable set to update with off-scale intruders. */
    offScaleIntruders?: MutableSubscribableSet<TcasIntruder>;
    /**
     * A subscribable set to update with intruders that are not off-scale but whose projected positions are considered
     * out-of-bounds.
     */
    oobIntruders?: MutableSubscribableSet<TcasIntruder>;
    /**
     * A subscribable which provides the offset of the intruder out-of-bounds boundaries relative to the boundaries of
     * the map's projected window, as `[left, top, right, bottom]` in pixels. Positive offsets are directed toward the
     * center of the map. Defaults to `[0, 0, 0, 0]`.
     */
    oobOffset?: Subscribable<ReadonlyFloat64Array>;
}
/**
 * A map layer which displays traffic intruders.
 */
declare class MapSystemTrafficLayer extends MapLayer<MapSystemTrafficLayerProps> {
    private static readonly DRAW_GROUPS;
    private readonly iconLayerRef;
    private readonly trafficModule;
    private readonly intruderIcons;
    private readonly needHandleOffscaleOob;
    private readonly oobOffset;
    private readonly oobBounds;
    private isInit;
    /** @inheritdoc */
    onVisibilityChanged(isVisible: boolean): void;
    /** @inheritdoc */
    onAttached(): void;
    /**
     * Initializes canvas styles.
     */
    private initCanvasStyles;
    /**
     * Initializes all currently existing TCAS intruders.
     */
    private initIntruders;
    /**
     * Initializes handlers to respond to TCAS events.
     */
    private initTCASHandlers;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /**
     * Updates the boundaries of the intruder out-of-bounds area.
     */
    private updateOobBounds;
    /** @inheritdoc */
    onUpdated(time: number, elapsed: number): void;
    /**
     * Redraws all tracked intruders.
     */
    private redrawIntruders;
    /**
     * Updates this layer's visibility.
     */
    private updateVisibility;
    /**
     * A callback which is called when a TCAS intruder is added.
     * @param intruder The new intruder.
     */
    private onIntruderAdded;
    /**
     * A callback which is called when a TCAS intruder is removed.
     * @param intruder The removed intruder.
     */
    private onIntruderRemoved;
    /**
     * A callback which is called when the alert level of a TCAS intruder is changed.
     * @param intruder The intruder.
     */
    private onIntruderAlertLevelChanged;
    /** @inheritdoc */
    render(): VNode;
}
/**
 * An abstract implementation of {@link MapTrafficIntruderIcon} which handles the projection of the intruder's position
 * and off-scale calculations.
 */
declare abstract class AbstractMapTrafficIntruderIcon implements MapTrafficIntruderIcon {
    readonly intruder: TcasIntruder;
    protected readonly trafficModule: MapTrafficModule;
    protected readonly ownshipModule: MapOwnAirplanePropsModule;
    private static readonly geoPointCache;
    readonly projectedPos: Float64Array;
    isOffScale: boolean;
    /**
     * Constructor.
     * @param intruder This icon's associated intruder.
     * @param trafficModule The traffic module for this icon's parent map.
     * @param ownshipModule The ownship module for this icon's parent map.
     */
    constructor(intruder: TcasIntruder, trafficModule: MapTrafficModule, ownshipModule: MapOwnAirplanePropsModule);
    /**
     * Draws this icon.
     * @param projection The map projection.
     * @param context The canvas rendering context to which to draw this icon.
     * @param offScaleRange The distance from the own airplane to this icon's intruder beyond which the intruder is
     * considered off-scale. If the value is `NaN`, the intruder is never considered off-scale.
     */
    draw(projection: MapProjection, context: CanvasRenderingContext2D, offScaleRange: NumberUnitInterface<UnitFamily.Distance>): void;
    /**
     * Updates this icon's intruder's projected position and off-scale status.
     * @param projection The map projection.
     * @param offScaleRange The distance from the own airplane to this icon's intruder beyond which the intruder is
     * considered off-scale. If the value is `NaN`, the intruder is never considered off-scale.
     */
    protected updatePosition(projection: MapProjection, offScaleRange: NumberUnitInterface<UnitFamily.Distance>): void;
    /**
     * Updates this icon's intruder's projected position and off-scale status using a specific range from the own
     * airplane to define off-scale.
     * @param projection The map projection.
     * @param ownAirplanePos The position of the own airplane.
     * @param offScaleRange The distance from the own airplane to this icon's intruder beyond which the intruder is
     * considered off-scale.
     */
    protected handleOffScaleRange(projection: MapProjection, ownAirplanePos: GeoPointInterface, offScaleRange: NumberUnitInterface<UnitFamily.Distance>): void;
    /**
     * Draws this icon.
     * @param projection The map projection.
     * @param context The canvas rendering context to which to draw this icon.
     * @param projectedPos The projected position of this icon's intruder.
     * @param isOffScale Whether this icon's intruder is off-scale.
     */
    protected abstract drawIcon(projection: MapProjection, context: CanvasRenderingContext2D, projectedPos: ReadonlyFloat64Array, isOffScale: boolean): void;
}

/**
 * A handler to determine waypoint visibility.
 */
declare type WaypointVisibilityHandler<T extends Facility> = (w: FacilityWaypoint<T>) => boolean;
/**
 * Filters for the nearest intersections.
 */
interface IntersectionFilters {
    /** A bitmask of allowable intersection types. */
    typeMask: number;
    /** Whether or not to show terminal waypoints. */
    showTerminalWaypoints: boolean;
}
/**
 * Filters for the nearest VORs.
 */
interface VorFilters {
    /** A bitmask of allowable VOR types. */
    typeMask: number;
    /** A bitmask of allowable VOR classes. */
    classMask: number;
}
/**
 * Filters for the nearest airports.
 */
interface AirportFilters {
    /** A bitmask of allowable airport classes. */
    classMask: number;
    /** Whether or not to show closed airports. */
    showClosed: boolean;
}
/**
 * Extended filters for the nearest airports.
 */
interface ExtendedAirportFilters {
    /** A bitmask of allowable runway surface types. */
    runwaySurfaceTypeMask: number;
    /** A bitmask of allowable approach types. */
    approachTypeMask: number;
    /** A bitmask of whether or not to show towered or untowered airports. */
    toweredMask: number;
    /** The minimum runway length to allow. */
    minimumRunwayLength: number;
}
/**
 * A map data module that controls waypoint display options.
 */
declare class MapWaypointDisplayModule {
    /** A handler that dictates airport waypoint visibility. */
    showAirports: Subject<WaypointVisibilityHandler<AirportFacility>>;
    /** A handler that dictates intersection waypoint visibility. */
    showIntersections: Subject<WaypointVisibilityHandler<IntersectionFacility>>;
    /** A handler that dictates NDB waypoint visibility. */
    showNdbs: Subject<WaypointVisibilityHandler<NdbFacility>>;
    /** A handler that dictates VOR waypoint visibility. */
    showVors: Subject<WaypointVisibilityHandler<VorFacility>>;
    /** The maximum range at which airport waypoints should be searched for. */
    airportsRange: NumberUnitSubject<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
    /** The maximum range at which intersection waypoints should be searched for. */
    intersectionsRange: NumberUnitSubject<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
    /** The maximum range at which NDB waypoints should be searched for. */
    ndbsRange: NumberUnitSubject<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
    /** The maximum range at which VOR waypoints should be searched for. */
    vorsRange: NumberUnitSubject<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
    /** The maximum number of airports that should be displayed. */
    numAirports: Subject<number>;
    /** The maximum number of intersections that should be displayed. */
    numIntersections: Subject<number>;
    /** The maximum number of NDBs that should be displayed. */
    numNdbs: Subject<number>;
    /** The maximum number of VORs that should be displayed. */
    numVors: Subject<number>;
    /** The filter to apply to the intersection search. */
    intersectionsFilter: Subject<IntersectionFilters>;
    /** The filter to apply to the VOR search. */
    vorsFilter: Subject<VorFilters>;
    /** The filter to apply to the airport search. */
    airportsFilter: Subject<AirportFilters>;
    /** The extended airport filter to apply to the airport search. */
    extendedAirportsFilter: Subject<ExtendedAirportFilters>;
}

/**
 * Modules required by MapSystemWaypointsLayer.
 */
interface MapSystemWaypointsLayerModules {
    /** Waypoints display module. */
    [MapSystemKeys.NearestWaypoints]: MapWaypointDisplayModule;
}
/**
 * Props on the MapSystemWaypointsLayer component.
 */
interface MapSystemWaypointsLayerProps extends MapLayerProps<MapSystemWaypointsLayerModules> {
    /** The event bus. */
    bus: EventBus;
    /** The waypoint renderer to use. */
    waypointRenderer: MapSystemWaypointsRenderer;
    /** The icon factory to use with this component. */
    iconFactory: MapSystemIconFactory;
    /** The label factory to use with this component. */
    labelFactory: MapSystemLabelFactory;
    /**
     * Whether to use the map's projection target as the center for facility searches instead of the map's center.
     * Defaults to `false`.
     */
    useMapTargetAsSearchCenter?: boolean;
}
/**
 * A class that renders waypoints into a layer.
 */
declare class MapSystemWaypointsLayer extends MapLayer<MapSystemWaypointsLayerProps> {
    private readonly waypointsLayer;
    private readonly displayModule;
    private readonly waypointCache;
    private readonly searchItemLimits;
    private readonly searchRadiusLimits;
    private renderRole;
    /** @inheritdoc */
    onAttached(): void;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /** @inheritdoc */
    onUpdated(time: number, elapsed: number): void;
    /** @inheritdoc */
    private initEventHandlers;
    /**
     * A callback called when the nearest facility search sessions have been started.
     * @param airportSession The airport search session.
     * @param vorSession The VOR search session.
     * @param ndbSession The NDB search session.
     * @param intSession The intersection search session.
     */
    private onSessionsStarted;
    /**
     * Initializes this layer's waypoint renderer.
     * @param renderer This layer's waypoint renderer.
     * @param canvasLayer The canvas layer to which to draw the waypoints.
     */
    private initWaypointRenderer;
    /**
     * Defines the render role for this layer's waypoints.
     * @param renderer This layer's waypoint renderer.
     * @param canvasLayer The canvas layer to which to draw the waypoints.
     */
    private defineRenderRole;
    /** @inheritdoc */
    setVisible(val: boolean): void;
    /**
     * Checks to see if a waypoint should be visible.
     * @param waypoint The waypoint to check.
     * @returns True if visible, false otherwise.
     */
    private isWaypointVisible;
    /** @inheritdoc */
    render(): VNode;
}

/**
 * A map data module that controls the terrain color reference point.
 */
declare class MapTerrainColorsModule {
    /** The terrain colors reference point. */
    readonly reference: Subject<EBingReference>;
    /** Whether or not to show the map terrain isolines. */
    readonly showIsoLines: Subject<boolean>;
    /** The terrain colors array. */
    readonly colors: ArraySubject<number>;
}

/**
 * A module that describes the display of weather on a Bing Map instance.
 */
declare class MapWxrModule {
    /** Whether the weather radar is enabled. */
    readonly isEnabled: Subject<boolean>;
    /** The current map weather radar arc sweep angle in degrees. */
    readonly weatherRadarArc: NumberUnitSubject<UnitFamily.Angle, SimpleUnit<UnitFamily.Angle>>;
    /** The current weather radar mode. */
    readonly weatherRadarMode: Subject<EWeatherRadar.TOPVIEW | EWeatherRadar.HORIZONTAL | EWeatherRadar.VERTICAL>;
    private readonly _wxrMode;
    /**
     * A subscribable containing the combined WxrMode from the mode and arc subjects,
     * suitable for consumption in a MapBingLayer.
     * @returns The WxrMode subscribable.
     */
    get wxrMode(): Subscribable<WxrMode>;
    /**
     * Constructor.
     */
    constructor();
}

/**
 * A class that builds a configuration for the waypoint display.
 */
declare class WaypointDisplayBuilder {
    protected readonly iconFactory: MapSystemIconFactory;
    protected readonly labelFactory: MapSystemLabelFactory;
    protected readonly waypointRenderer: MapSystemWaypointsRenderer;
    protected roleGroup: string;
    protected isCenterTarget: boolean;
    /**
     * Creates an instance of the WaypointDisplayBuilder.
     * @param iconFactory The icon factory to use with this builder.
     * @param labelFactory The label factory to use with this builder.
     * @param waypointRenderer The waypoint renderer to use with this builder.
     */
    constructor(iconFactory: MapSystemIconFactory, labelFactory: MapSystemLabelFactory, waypointRenderer: MapSystemWaypointsRenderer);
    /**
     * Adds a icon configuration to the waypoint display system.
     * @param role The role to add this waypoint display config for.
     * @param type The type of waypoint to add an icon for.
     * @param config The waypoint icon factory to add as a configuration.
     * @returns The modified builder.
     */
    addIcon<T extends Waypoint>(role: number | string, type: string, config: (waypoint: T) => MapWaypointIcon<T>): this;
    /**
     * Adds a default icon configuration to the waypoint display system, if no other configuration is found.
     * @param role The role to add this waypoint display config for.
     * @param config The waypoint icon factory to add as a configuration.
     * @returns The modified builder.
     */
    addDefaultIcon<T extends Waypoint>(role: number | string, config: (waypoint: T) => MapWaypointIcon<T>): this;
    /**
     * Adds a label configuration to the waypoint display system.
     * @param role The role to add this waypoint display config for.
     * @param type The type of waypoint to add an label for.
     * @param config The waypoint label factory to add as a configuration.
     * @returns The modified builder.
     */
    addLabel<T extends Waypoint>(role: number | string, type: string, config: (waypoint: T) => MapCullableLocationTextLabel): this;
    /**
     * Adds a label configuration to the waypoint display system.
     * @param role The role to add this waypoint display config for.
     * @param config The waypoint label factory to add as a configuration.
     * @returns The modified builder.
     */
    addDefaultLabel<T extends Waypoint>(role: number | string, config: (waypoint: T) => MapCullableLocationTextLabel): this;
    /**
     * Determines the role ID given either a numeric or string based role.
     * @param role The role to determine.
     * @returns The numeric role ID.
     */
    private determineRoleId;
    /**
     * Registers a waypoint display role for use with the flight plan rendering
     * system.
     * @param name The name of the role to register.
     * @returns The modified builder.
     */
    registerRole(name: string): this;
    /**
     * Gets the ID of a role in the waypoint display system.
     * @param role The name of the role to get the ID for.
     * @returns The ID of the role.
     * @throws An error if an invalid role name is supplied.
     */
    getRoleId(role: string): number;
    /**
     * Configures the center for waypoint searches for this display.
     * @param center If center, then waypoint searches will use the map center. If target,
     * waypoint searches will use the map target with offset.
     * @returns The modified builder.
     */
    withSearchCenter(center: 'center' | 'target'): this;
    /**
     * Gets if the waypoint search is using the map target with offset as the search center.
     * @returns True if the search center is the map target, false if it is the map center.
     */
    getIsCenterTarget(): boolean;
}

/**
 * A class that builds the configuration for the flight plan display.
 */
declare class FlightPlanDisplayBuilder extends WaypointDisplayBuilder {
    private readonly flightPlanRenderer;
    private readonly planIndex;
    protected roleGroup: string;
    /**
     * Creates an instance of the WaypointDisplayBuilder.
     * @param iconFactory The icon factory to use with this builder.
     * @param labelFactory The label factory to use with this builder.
     * @param waypointRenderer The waypoint renderer to use with this builder.
     * @param flightPlanRenderer The flight plan renderer to use with this builder.
     * @param planIndex The flight plan index to be displayed by this system.
     */
    constructor(iconFactory: MapSystemIconFactory, labelFactory: MapSystemLabelFactory, waypointRenderer: MapSystemWaypointsRenderer, flightPlanRenderer: MapSystemPlanRenderer, planIndex: number);
    /**
     * Registers a waypoint display role for use with the flight plan rendering
     * system.
     * @param name The name of the role to register.
     * @returns The modified builder.
     */
    registerRole(name: string): this;
    /**
     * Configures the flight path display to use styles returned by the provided function.
     * @param handler The handler to use to return the required path rendering styles.
     * @returns The modified builder.
     */
    withLegPathStyles(handler: LegStyleHandler): this;
    /**
     * Configures the flight plan waypoint display to use the roles returned by the
     * provided function.
     * @param handler The handler to use to return the required waypoint display roles.
     * @returns The modified builder.
     */
    withLegWaypointRoles(handler: LegWaypointHandler): this;
    /**
     * Configures the flight plan flight path display to set visibility of leg-to-leg
     * turn anticipation transitions.
     * @param visible Whether or not the leg-to-leg turn anticipation transitions will be visible.
     * @returns The modified builder.
     */
    withAnticipationTurns(visible: boolean | Subscribable<boolean>): this;
}

/**
 * A key for a property in {@link MapAutopilotPropsModule}.
 */
declare type MapAutopilotPropsKey = Extract<keyof MapAutopilotPropsModule, string>;

/**
 * A function which defines a custom build step.
 */
declare type MapSystemCustomBuilder<Args extends any[] = any[], RequiredModules extends ModuleRecord = any, RequiredLayers extends LayerRecord = any, RequiredContext extends ContextRecord = any> = (mapBuilder: MapSystemBuilder<RequiredModules, RequiredLayers, any, RequiredContext>, ...args: Args) => MapSystemBuilder<any, any, any, any>;
/**
 * Retrieves the extra arguments, after the map builder, of a custom builder.
 */
declare type CustomBuilderArgs<Builder> = Builder extends MapSystemCustomBuilder<infer Args> ? Args : never;
/**
 * Retrieves a custom map builder's required modules.
 */
declare type RequiredCustomBuilderModules<Builder> = Builder extends MapSystemCustomBuilder<any, infer M> ? M : never;
/**
 * Retrieves a custom map builder's required layers.
 */
declare type RequiredCustomBuilderLayers<Builder> = Builder extends MapSystemCustomBuilder<any, any, infer L> ? L : never;
/**
 * Retrieves a custom map builder's required context.
 */
declare type RequiredCustomBuilderContext<Builder> = Builder extends MapSystemCustomBuilder<any, any, any, infer Context> ? Context : never;
/**
 * A map model module factory.
 */
declare type ModuleFactory = {
    /** The key of the module to create. */
    key: string;
    /** The constructor of the module to create. */
    factory: () => any;
};
/**
 * A map layer factory.
 */
declare type LayerFactory = {
    /** The key of the layer to create. */
    key: string;
    /** A function which renders the layer to create. */
    factory: (context: MapSystemContext<any, any, any, any>) => VNode;
    /** The order value of the layer to create. */
    order: number;
};
/**
 * A map controller factory.
 */
declare type ControllerFactory = {
    /** A function which creates the controller. */
    factory: (context: MapSystemContext<any, any, any, any>) => MapSystemController<any, any, any>;
};
/**
 * A map context property factory.
 */
declare type ContextFactory = {
    /** The key of the property to create. */
    key: string;
    /** A function which creates the context property. */
    factory: (context: MapSystemContext<any, any, any, any>) => any;
    /** The value determining in which order to create the property.  */
    order: number;
};
/**
 * Checks if a set of module, layer, and context records meet certain requirements. If the requirements are met, the
 * specified type is returned. If the requirements are not met, `never` is returned.
 */
declare type ConditionalReturn<Modules, RequiredModules, Layers, RequiredLayers, Context, RequiredContext, ReturnType> = Modules extends RequiredModules ? Layers extends RequiredLayers ? Context extends RequiredContext ? ReturnType : never : never : never;
/** Checks if a type is exactly the `any` type. */
declare type IsAny<T> = boolean extends (T extends never ? true : false) ? true : false;
/** Returns a type if it is not `any`, otherwise returns a default type. */
declare type DefaultIfAny<T, Default> = IsAny<T> extends true ? Default : T;
/**
 * Options for handling off-scale and out-of-bounds traffic intruders on a traffic layer.
 */
declare type TrafficOffScaleOobOptions = {
    /** A subscribable set to update with off-scale intruders. */
    offScaleIntruders?: MutableSubscribableSet<TcasIntruder>;
    /**
     * A subscribable set to update with intruders that are not off-scale but whose projected positions are considered
     * out-of-bounds.
     */
    oobIntruders?: MutableSubscribableSet<TcasIntruder>;
    /**
     * A subscribable which provides the offset of the intruder out-of-bounds boundaries relative to the boundaries of
     * the map's projected window, as `[left, top, right, bottom]` in pixels. Positive offsets are directed toward the
     * center of the map. Defaults to `[0, 0, 0, 0]`.
     */
    oobOffset?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
};
/**
 * Builds maps. Each builder is configured with a series of build steps which collectively define how the builder
 * compiles finished maps. In addition to defining basic map properties such as size and range, build steps can also
 * customize map behavior and appearance through adding map model modules, layers, and controllers.
 *
 * Each map compiled by the builder is associated with a {@link MapSystemContext}, which holds references to the map
 * projection, map model, all layers and controllers, and other data associated with the map. Layers and controllers
 * have access to the context when they are created during compilation, and a reference to the context is stored with
 * the compiled map.
 *
 * A single builder can compile multiple maps. Each compiled map is a separate entity, with its own model, layers,
 * controllers, and context.
 */
declare class MapSystemBuilder<Modules extends ModuleRecord = any, Layers extends LayerRecord = any, Controllers extends ControllerRecord = any, Context extends ContextRecord = any> {
    readonly bus: EventBus;
    protected static readonly RESTRICTED_CONTEXT_KEYS: Set<string>;
    protected readonly moduleFactories: Map<string, ModuleFactory>;
    protected readonly layerFactories: Map<string, LayerFactory>;
    protected readonly controllerFactories: Map<string, ControllerFactory>;
    protected readonly contextFactories: Map<string, ContextFactory>;
    protected readonly initCallbacks: Map<string, (context: MapSystemContext<any, any, any, any>) => void>;
    protected projectedSize: Subscribable<ReadonlyFloat64Array>;
    protected deadZone?: Subscribable<ReadonlyFloat64Array>;
    protected targetOffset?: ReadonlyFloat64Array;
    protected nominalRangeEndpoints?: ReadonlyFloat64Array;
    protected range?: number;
    /** The number of map model modules added to this builder. */
    get moduleCount(): number;
    /** The number of map layers added to this builder. */
    get layerCount(): number;
    /** The number of map controllers added to this builder. */
    get controllerCount(): number;
    /**
     * Creates an instance of a map system builder.
     * @param bus This builder's event bus.
     */
    protected constructor(bus: EventBus);
    /**
     * Creates a new Garmin map builder. The builder is initialized with a default projected size of `[100, 100]` pixels.
     * @param bus The event bus.
     * @returns A new Garmin map builder.
     */
    static create(bus: EventBus): MapSystemBuilder;
    /**
     * Configures this builder to generate a map with a given projected window size.
     * @param size The size of the projected window, as `[width, height]` in pixels, or a subscribable which provides it.
     * @returns This builder, after it has been configured.
     */
    withProjectedSize(size: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>): this;
    /**
     * Configures this builder to generate a map with a given dead zone.
     * @param deadZone The dead zone, as `[left, top, right, bottom]` in pixels, or a subscribable which provides it.
     * @returns This builder, after it has been configured.
     */
    withDeadZone(deadZone: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>): this;
    /**
     * Configures this builder to generate a map with an initial projected target offset.
     * @param offset The initial projected target offset, as `[x, y]` in pixels.
     * @returns This builder, after it has been configured.
     */
    withTargetOffset(offset: ReadonlyFloat64Array): this;
    /**
     * Configures this builder to generate a map with specific initial range endpoints. The endpoints are defined
     * relative to the width and height of the map's projected window, *excluding* the dead zone.
     * @param endpoints The initial range endpoints, as `[x1, y1, x2, y2]`.
     * @returns This builder, after it has been configured.
     */
    withRangeEndpoints(endpoints: ReadonlyFloat64Array): this;
    /**
     * Configures this build to generate a map with a specific initial range.
     * @param range The initial range.
     * @returns This builder, after it has been configured.
     */
    withRange(range: NumberUnitInterface<UnitFamily.Distance>): this;
    /**
     * Adds a map module to this builder. When this builder compiles its map, all added modules will be created and added
     * to the map's model. If an existing module has been added to this builder with the same key, it will be replaced.
     * @param key The key (name) of the module.
     * @param factory A function which creates the module.
     * @returns This builder, after the map module has been added.
     */
    withModule(key: string, factory: () => any): this;
    /**
     * Adds a map layer to this builder. When this builder compiles its map, all added layers will be created and
     * attached to the map. Layers with a lower assigned order will be attached before and appear below layers with
     * greater assigned order values. If an existing layer has been added to this builder with the same key, it will be
     * replaced.
     * @param key The key of the layer.
     * @param factory A function which renders the layer as a VNode.
     * @param order The order assigned to the layer. Layers with lower assigned order will be attached to the map before
     * and appear below layers with greater assigned order values. Defaults to the number of layers already added to this
     * builder.
     * @returns This builder, after the map layer has been added, or `never` if this builder does not have all the
     * modules required by the layer.
     */
    withLayer<L extends MapLayer = any, UseModules = any, UseContext = any>(key: string, factory: (context: MapSystemContext<DefaultIfAny<UseModules, Modules>, EmptyRecord, EmptyRecord, DefaultIfAny<UseContext, Context>>) => VNode, order?: number): ConditionalReturn<DefaultIfAny<UseModules, Modules>, RequiredLayerModules<L>, any, any, any, any, this>;
    /**
     * Adds a controller to this builder. When this builder compiles its map, all added controllers will be created and
     * hooked up to the map's lifecycle callbacks. If an existing controller has been added to this builder with the same
     * key, it will be replaced.
     * @param key The key of the controller.
     * @param factory A function which creates the controller.
     * @returns This builder, after the map layer has been added, or `never` if this builder does not have all the
     * modules required by the controller.
     */
    withController<Controller extends MapSystemController<any, any, any, any>, UseModules = any, UseLayers extends LayerRecord = any, UseControllers extends ControllerRecord = any, UseContext = any>(key: string, factory: (context: MapSystemContext<DefaultIfAny<UseModules, Modules>, DefaultIfAny<UseLayers, Layers>, DefaultIfAny<UseControllers, Controllers>, DefaultIfAny<UseContext, Context>>) => Controller): ConditionalReturn<DefaultIfAny<UseModules, Modules>, RequiredControllerModules<Controller>, DefaultIfAny<UseLayers, Layers>, RequiredControllerLayers<Controller>, DefaultIfAny<UseContext, Context>, RequiredControllerContext<Controller>, this>;
    /**
     * Adds a context property to this builder. When the builder compiles its map, all added properties will be available
     * on the context. Properties are created on the context in the order they were added to the builder, and property
     * factories have access to previously created properties on the context. If an existing property has been added to
     * this builder with the same key, it will be replaced.
     * @param key The key of the property to add.
     * @param factory A function which creates the value of the property.
     * @returns This builder, after the context property has been added.
     */
    withContext<UseContext = any>(key: Exclude<string, keyof MapSystemContext>, factory: (context: MapSystemContext<Record<never, never>, Record<never, never>, Record<never, never>, DefaultIfAny<UseContext, Context>>) => any): this;
    /**
     * Configures this builder to execute a callback function immediately after it is finished compiling a map. If an
     * existing callback has been added to this builder with the same key, it will be replaced.
     * @param key The key of the callback.
     * @param callback The callback function to add.
     * @returns This builder, after the callback has been added.
     */
    withInit<UseModules = any, UseLayers extends LayerRecord = any, UseControllers extends ControllerRecord = any, UseContext = any>(key: string, callback: (context: MapSystemContext<DefaultIfAny<UseModules, Modules>, DefaultIfAny<UseLayers, Layers>, DefaultIfAny<UseControllers, Controllers>, DefaultIfAny<UseContext, Context>>) => void): this;
    /**
     * Assigns an order value to a layer. Layers with a lower assigned order will be attached before and appear below
     * layers with greater assigned order values.
     * @param key The key of the layer to which to assign the order value.
     * @param order The order value to assign.
     * @returns This builder, after the order value has been assigned.
     */
    withLayerOrder(key: keyof Layers & string, order: number): this;
    /**
     * Configures this builder to add a controller which maintains a list of bindings from source to target
     * subscribables.
     * @param key The key of the controller.
     * @param bindings The bindings to maintain.
     * @returns This builder, after it has been configured.
     */
    withBindings<UseModules = any, UseLayers extends LayerRecord = any, UseContext = any>(key: string, bindings: (context: MapSystemContext<DefaultIfAny<UseModules, Modules>, DefaultIfAny<UseLayers, Layers>, EmptyRecord, DefaultIfAny<UseContext, Context>>) => Iterable<MapBinding<any> | MapTransformedBinding<any, any>>): this;
    /**
     * Configures this builder to generate a map which is updated at a regular frequency based on event bus clock events.
     *
     * Adds the following...
     *
     * Context properties:
     * * `'updateFreq': Subscribable<number>`
     *
     * Controllers:
     * * `[MapSystemKeys.ClockUpdate]: MapClockUpdateController`.
     * @param updateFreq The map's update frequency, in hertz, or a subscribable which provides it.
     * @returns This builder, after it has been configured.
     */
    withClockUpdate(updateFreq: number | Subscribable<number>): this;
    /**
     * Configures this builder to add a resource moderator for control of the map's projection target.
     *
     * Adds the context property `[MapSystemKeys.TargetControl]: ResourceModerator<void>`.
     * @returns This builder, after the resource moderator has been added.
     */
    withTargetControlModerator(): this;
    /**
     * Configures this builder to add a resource moderator for control of the map's rotation.
     *
     * Adds the context property `[MapSystemKeys.RotationControl]: ResourceModerator<void>`.
     * @returns This builder, after the resource moderator has been added.
     */
    withRotationControlModerator(): this;
    /**
     * Configures this builder to add a resource moderator for control of the map's range.
     *
     * Adds the context property `[MapSystemKeys.RangeControl]: ResourceModerator<void>`.
     * @returns This builder, after the resource moderator has been added.
     */
    withRangeControlModerator(): this;
    /**
     * Configures this builder to generate a map whose projection target follows the player airplane. The follow airplane
     * behavior will be active if and only if the controller owns the projection target control resource. The
     * controller's priority for the resource is `0`.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.TargetControl]: ResourceModerator<void>`
     *
     * Modules:
     * * `[MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule`
     * * `[MapSystemKeys.FollowAirplane]: MapFollowAirplaneModule`
     *
     * Controllers:
     * * `[MapSystemKeys.FollowAirplane]: MapFollowAirplaneController`
     * @returns This builder, after it has been configured.
     */
    withFollowAirplane(): this;
    /**
     * Configures this builder to generate a map which supports common rotation behavior. The rotation behavior will be
     * active if and only if the controller owns the rotation control resource. The controller's priority for the
     * resource is `0`.
     *
     * Requires the module `'ownAirplaneProps': MapOwnAirplanePropsModule` to support player airplane-derived rotation
     * behavior, such as Heading Up and Track Up.
     *
     * Adds the following...
     *
     * Context properties:
     * * `'[MapSystemKeys.RotationControl]': ResourceModerator<void>`
     *
     * Modules:
     * * `[MapSystemKeys.Rotation]: MapRotationModule`
     *
     * Controllers:
     * * `[MapSystemKeys.Rotation]: MapRotationController`
     * @returns This builder, after it has been configured.
     */
    withRotation(): this;
    /**
     * Configures this builder to generate a map which displays an icon depicting the position of the player airplane.
     *
     * Adds the following...
     *
     * Modules:
     * * `[MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule`
     * * `[MapSystemKeys.OwnAirplaneIcon]: MapOwnAirplaneIconModule`
     *
     * Layers:
     * * `[MapSystemKeys.OwnAirplaneIcon]: MapOwnAirplaneLayer`
     * @param iconSize The size of the icon, in pixels.
     * @param iconFilePath The path to the icon's image asset, or a subscribable which provides it.
     * @param iconAnchor The point on the icon that is anchored to the airplane's position, or a subscribable which
     * provides it. The point is expressed as a 2-tuple relative to the icon's width and height, with `[0, 0]` at the
     * top left and `[1, 1]` at the bottom right.
     * @param cssClass The CSS class(es) to apply to the root of the airplane icon layer.
     * @param order The order assigned to the icon layer. Layers with lower assigned order will be attached to the map
     * before and appear below layers with greater assigned order values. Defaults to the number of layers already added
     * to this builder.
     * @returns This builder, after it has been configured.
     */
    withOwnAirplaneIcon(iconSize: number, iconFilePath: string | Subscribable<string>, iconAnchor: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>, cssClass?: string | SubscribableSet<string>, order?: number): this;
    /**
     * Configures this builder to bind properties in an added {@link MapOwnAirplanePropsModule} to data derived from
     * event bus events.
     *
     * Requires the module `[MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule`.
     *
     * Adds the controller `[MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsController`.
     * @param properties The properties to bind.
     * @param updateFreq The update frequency, in hertz, or a subscribable which provides it.
     * @returns This builder, after it has been configured.
     */
    withOwnAirplanePropBindings<UseModules = any>(properties: Iterable<MapOwnAirplanePropsKey>, updateFreq: number | Subscribable<number>): ConditionalReturn<DefaultIfAny<UseModules, Modules>, MapOwnAirplanePropsControllerModules, any, any, any, any, this>;
    /**
     * Configures this builder to add a module describing the player airplane's autopilot properties, and optionally
     * binds the module's properties to data received over the event bus.
     *
     * Adds the following...
     *
     * Modules:
     * * `[MapSystemKeys.AutopilotProps]: MapAutopilotPropsModule`
     *
     * Controllers:
     * * `[MapSystemKeys.AutopilotProps]: MapAutopilotPropsController` (optional)
     * @param propertiesToBind Properties on the autopilot module to bind to data received over the event bus.
     * @param updateFreq The update frequency, in hertz, of the data bindings, or a subscribable which provides it. If
     * not defined, the data bindings will update every frame. Ignored if `propertiesToBind` is undefined.
     * @returns This builder, after it has been configured.
     */
    withAutopilotProps(propertiesToBind?: Iterable<MapAutopilotPropsKey>, updateFreq?: number | Subscribable<number>): this;
    /**
     * Configures this builder to generate a map which includes a layer displaying text.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.TextManager]: MapCullableTextLabelManager`
     *
     * Layers:
     * * `[MapSystemKeys.TextLayer]: MapCullableTextLayer`
     * @param enableCulling Whether to enable text culling. Defaults to `false`.
     * @param order The order value to assign to the text layer. Layers with lower assigned order will be attached to
     * the map before and appear below layers with greater assigned order values. Defaults to the number of layers
     * already added to this builder.
     * @returns This builder, after it has been configured.
     */
    withTextLayer(enableCulling: boolean, order?: number): this;
    /**
     * Configures this builder to generate a map which displays Bing Map terrain and weather.
     *
     * Adds the following...
     *
     * Modules:
     * * `[MapSystemKeys.TerrainColors]: MapTerrainColorsModule`
     * * `[MapSystemKeys.Weather]: MapWxrModule`
     *
     * Layers:
     * * `[MapSystemKeys.Bing]: MapBingLayer`
     * @param bingId The ID to assign to the Bing Map instance bound to the layer.
     * @param delay The delay, in milliseconds, to wait after the Bing layer has been rendered before attempting to bind
     * a Bing Map instance.
     * @param mode The mode of the map, optional. If omitted, will be EBingMode.PLANE.
     * @param order The order value to assign to the Bing layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to the map builder.
     * @returns This builder, after it has been configured.
     */
    withBing(bingId: string, delay?: number, mode?: EBingMode, order?: number): this;
    /**
     * Configures this builder to generate a map which uses a {@link MapSystemWaypointsRenderer} to render waypoints.
     *
     * Requires the `[MapSystemKeys.TextManager]: MapCullableTextLabelManager` context property.
     *
     * Adds the `[MapSystemKeys.WaypointRenderer]: MapSystemWaypointsRenderer` context property.
     * @returns This builder, after it has been configured.
     */
    withWaypoints<UseContext = any>(): ConditionalReturn<any, any, any, any, DefaultIfAny<UseContext, Context>, {
        [MapSystemKeys.TextManager]: MapCullableTextLabelManager;
    }, this>;
    /**
     * Configures this builder to generate a map which displays waypoints near the map center or target. Waypoints
     * displayed in this manner are rendered by a {@link MapSystemWaypointsRenderer}.
     *
     * If a text layer has already been added to the builder, its order will be changed so that it is rendered above the
     * waypoint layer. Otherwise, a text layer will be added to the builder after the waypoint layer.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.TextManager]: MapCullableTextLabelManager`
     * * `[MapSystemKeys.IconFactory]: MapSystemIconFactory`
     * * `[MapSystemKeys.LabelFactory]: MapSystemLabelFactory`
     *
     * Modules:
     * * `[MapSystemKeys.NearestWaypoints]: MapWaypointDisplayModule`
     *
     * Layers:
     * * `[MapSystemKeys.NearestWaypoints]: MapSystemWaypointsLayer`
     * * `[MapSystemKeys.TextLayer]: MapCullableTextLayer`
     * @param configure A function to configure the waypoint display.
     * @param enableTextCulling Whether to enable text culling on the text manager.
     * @param order The order to assign to the waypoint layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to this builder.
     * @returns This builder, after it has been configured.
     */
    withNearestWaypoints(configure: (builder: WaypointDisplayBuilder) => void, enableTextCulling?: boolean, order?: number): this;
    /**
     * Configures this builder to generate a map which displays a flight plan. Waypoints displayed as part of the flight
     * plan are rendered by a {@link MapSystemWaypointsRenderer}.
     *
     * If a text layer has already been added to the builder, its order will be changed so that it is rendered above the
     * waypoint layer. Otherwise, a text layer will be added to the builder after the waypoint layer.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.FlightPlanner]: FlightPlanner`
     * * `[MapSystemKeys.TextManager]: MapCullableTextLabelManager`
     * * `[MapSystemKeys.IconFactory]: MapSystemIconFactory`
     * * `[MapSystemKeys.LabelFactory]: MapSystemLabelFactory`
     * * `[MapSystemKeys.FlightPathRenderer]: MapSystemPlanRenderer`
     *
     * Modules:
     * * `[MapSystemKeys.FlightPlan]: MapFlightPlanModule`
     *
     * Layers:
     * * `` `${[MapSystemKeys.FlightPlan]}${planIndex}`: MapSystemFlightPlanLayer ``
     * * `[MapSystemKeys.TextLayer]: MapCullableTextLayer`
     *
     * Controllers:
     * * `[MapSystemKeys.FlightPlan]: MapFlightPlanController`
     * @param configure A function to configure the waypoint display.
     * @param flightPlanner The flight planner.
     * @param planIndex The index of the flight plan to display.
     * @param enableTextCulling Whether to enable text culling on the text manager.
     * @param order The order to assign to the plan layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to this builder.
     * @returns This builder, after it has been configured.
     */
    withFlightPlan(configure: (builder: FlightPlanDisplayBuilder) => void, flightPlanner: FlightPlanner, planIndex: number, enableTextCulling?: boolean, order?: number): this;
    /**
     * Configures this builder to generate a map which displays airspaces.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.AirspaceManager]: GenericAirspaceRenderManager`
     *
     * Modules:
     * * `[MapSystemKeys.Airspace]: MapAirspaceModule`
     *
     * Layers:
     * * `[MapSystemKeys.Airspace]: MapAirspaceLayer`
     * @param cache The airspace cache to use to store airspaces retrieved for rendering.
     * @param showTypes The airspace show types to define in the airspace module. Each show type will be assigned a
     * {@link Subject} in the `show` property of the module. The Subject controls the visibility of airspace types
     * included in its show type. Airspace types that are not included in any defined show type will never be displayed.
     * @param selectRenderer A function which selects a {@link MapAirspaceRenderer}
     * @param renderOrder A function which determines the rendering order of airspaces. The function should return a
     * negative number when airspace `a` should be rendered before (below) airspace `b`, a positive number when airspace
     * `a` should be rendered after (above) airspace `b`, and `0` when the relative render order of the two airspaces
     * does not matter. If not defined, there will be no guarantee on the order in which airspaces are rendered.
     * @param options Options for the airspace layer. Option defaults are as follows:
     * * `maxSearchRadius`: 10 nautical miles
     * * `maxSearchItemCount`: 100
     * * `searchDebounceDelay`: 500 (milliseconds)
     * * `renderTimeBudget`: 0.2 (milliseconds)
     * @param order The order to assign to the airspace layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to this builder.
     * @returns This builder, after it has been configured.
     */
    withAirspaces(cache: LodBoundaryCache, showTypes: MapAirspaceShowTypes, selectRenderer: (airspace: LodBoundary) => MapAirspaceRenderer, renderOrder?: (a: LodBoundary, b: LodBoundary) => number, options?: Partial<Pick<MapAirspaceLayerProps, 'maxSearchRadius' | 'maxSearchItemCount' | 'searchDebounceDelay' | 'renderTimeBudget'>>, order?: number): this;
    /**
     * Configures this builder to generate a map which displays TCAS intruders.
     *
     * Adds the following...
     *
     * Modules:
     * * `[MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule`
     * * `[MapSystemKeys.Traffic]: MapTrafficModule`
     *
     * Layers:
     * * `[MapSystemKeys.Traffic]: MapSystemTrafficLayer`
     * @param tcas The TCAS used by the traffic display.
     * @param iconFactory A function which creates intruder icons for the traffic display.
     * @param initCanvasStyles A function which initializes global canvas styles for the traffic display.
     * @param offScaleOobOptions A function which generates options for handling off-scale and out-of-bounds intruders.
     * @param order The order to assign to the traffic layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to this builder.
     * @returns This builder, after it has been configured.
     */
    withTraffic<UseModules = any, UseLayers extends LayerRecord = any, UserControllers extends ControllerRecord = any, UseContext = any>(tcas: Tcas, iconFactory: MapTrafficIntruderIconFactory<DefaultIfAny<UseModules, Modules>, DefaultIfAny<UseLayers, Layers>, DefaultIfAny<UserControllers, Controllers>, DefaultIfAny<UseContext, Context>>, initCanvasStyles?: (context: CanvasRenderingContext2D) => void, offScaleOobOptions?: (context: MapSystemContext<DefaultIfAny<UseModules, Modules>, DefaultIfAny<UseLayers, Layers>, DefaultIfAny<UserControllers, Controllers>, DefaultIfAny<UseContext, Context>>) => TrafficOffScaleOobOptions, order?: number): this;
    /**
     * Configures this builder using a custom build step.
     * @param builder A function which defines a custom build step.
     * @param args Arguments to pass to the custom build function.
     * @returns This builder, after it has been configured.
     */
    with<Builder extends MapSystemCustomBuilder<any[], any, any>, UseModules = any, UseLayers extends LayerRecord = any, UseContext = any>(builder: Builder, ...args: CustomBuilderArgs<Builder>): ConditionalReturn<DefaultIfAny<UseModules, Modules>, RequiredCustomBuilderModules<Builder>, DefaultIfAny<UseLayers, Layers>, RequiredCustomBuilderLayers<Builder>, DefaultIfAny<UseContext, Context>, RequiredCustomBuilderContext<Builder>, this>;
    /**
     * Compiles a map. The compiled map consists of a map context, a rendered map (as a VNode), and a node reference to
     * the rendered map component.
     *
     * The compiled map will be bound to a model (accessible through the map context) which contains all the modules
     * added to this builder.
     *
     * The map will also contain all layers added to this builder, with layers assigned lower order values appearing
     * below layers assigned greater order values. The layers can be retrieved by their keys from the map context.
     *
     * All controllers added to this builder will be created with the map and hooked up to the map's lifecycle callbacks.
     * The controllers can be retrieved by their keys from the map context.
     * @param cssClass The CSS class(es) to apply to the root of the rendered map component.
     * @returns A compiled map.
     */
    build<UseModules = any, UseLayers extends LayerRecord = any, UseControllers extends ControllerRecord = any, UseContext = any>(cssClass?: string | SubscribableSet<string>): CompiledMapSystem<DefaultIfAny<UseModules, Modules>, DefaultIfAny<UseLayers, Layers>, DefaultIfAny<UseControllers, Controllers>, DefaultIfAny<UseContext, Context>>;
    /**
     * Builds a new map context. The map context will be initialized with all context properties and modules added to
     * this builder.
     * @returns The new map context.
     */
    protected buildContext(): MutableMapContext<MapSystemContext<any, any, any, any>>;
}

/**
 * Callbacks supported by MapSystemGenericController.
 */
declare type MapSystemGenericControllerCallbacks<Context extends MapSystemContext<any, any, any, any>> = {
    /** */
    onAfterMapRender?: (context: Context) => void;
    /** */
    onDeadZoneChanged?: (context: Context, deadZone: ReadonlyFloat64Array) => void;
    /** */
    onMapProjectionChanged?: (context: Context, mapProjection: MapProjection, changeFlags: number) => void;
    /** */
    onBeforeUpdated?: (context: Context, time: number, elapsed: number) => void;
    /** */
    onAfterUpdated?: (context: Context, time: number, elapsed: number) => void;
    /** */
    onWake?: (context: Context) => void;
    /** */
    onSleep?: (context: Context) => void;
    /** */
    onMapDestroyed?: (context: Context) => void;
    /** */
    onDestroyed?: (context: Context) => void;
};
/**
 * A map controller which delegates its behavior to injected callback functions.
 */
declare class MapSystemGenericController<Modules extends ModuleRecord = any, Layers extends LayerRecord = any, Controllers extends ControllerRecord = any, Context extends ContextRecord = any> extends MapSystemController<Modules, Layers, Controllers, Context> {
    private readonly callbacks;
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param callbacks The callback functions to which this controller delegates its behavior.
     */
    constructor(context: MapSystemContext<Modules, Layers, any, Context>, callbacks: MapSystemGenericControllerCallbacks<MapSystemContext<Modules, Layers, Controllers, Context>>);
    /** @inheritdoc */
    onAfterMapRender(): void;
    /** @inheritdoc */
    onDeadZoneChanged(deadZone: ReadonlyFloat64Array): void;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /** @inheritdoc */
    onBeforeUpdated(time: number, elapsed: number): void;
    /** @inheritdoc */
    onAfterUpdated(time: number, elapsed: number): void;
    /** @inheritdoc */
    onWake(): void;
    /** @inheritdoc */
    onSleep(): void;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Utility methods related to MapSystem.
 */
declare class MapSystemUtils {
    /**
     * Converts a nominal relative projected x coordinate to a true relative projected x coordinate. Nominal relative
     * coordinates are expressed relative to the map's projected width and height, *excluding* dead zones. True relative
     * coordinates are expressed relative to the map's projected width and height, *including* dead zones.
     * @param nominalRelX A nominal relative projected x coordinate.
     * @param width The width of the map's projected window, in pixels.
     * @param deadZone The map's dead zone, as `[left, top, right, bottom]` in pixels.
     * @returns The true relative projected x coordinate that is equivalent to the specified nominal coordinate.
     */
    static nominalToTrueRelativeX(nominalRelX: number, width: number, deadZone: ReadonlyFloat64Array): number;
    /**
     * Converts a nominal relative projected y coordinate to a true relative projected y coordinate. Nominal relative
     * coordinates are expressed relative to the map's projected width and height, *excluding* dead zones. True relative
     * coordinates are expressed relative to the map's projected width and height, *including* dead zones.
     * @param nominalRelY A nominal relative projected y coordinate.
     * @param height The height of the map's projected window, in pixels.
     * @param deadZone The map's dead zone, as `[left, top, right, bottom]` in pixels.
     * @returns The true relative projected y coordinate that is equivalent to the specified nominal coordinate.
     */
    static nominalToTrueRelativeY(nominalRelY: number, height: number, deadZone: ReadonlyFloat64Array): number;
    /**
     * Converts nominal relative projected coordinates to a true relative projected coordinates. Nominal relative
     * coordinates are expressed relative to the map's projected width and height, *excluding* dead zones. True relative
     * coordinates are expressed relative to the map's projected width and height, *including* dead zones.
     * @param nominal Nominal relative projected coordinates.
     * @param size The size of the map's projected window, in pixels.
     * @param deadZone The map's dead zone, as `[left, top, right, bottom]` in pixels.
     * @param out The vector to which to write the result.
     * @returns The true relative projected coordinates that are equivalent to the specified nominal coordinates.
     */
    static nominalToTrueRelativeXY(nominal: ReadonlyFloat64Array, size: ReadonlyFloat64Array, deadZone: ReadonlyFloat64Array, out: Float64Array): Float64Array;
}

/**
 * Waypoint roles used by the map system waypoint display system.
 */
declare enum MapSystemWaypointRoles {
    /** The normal waypoint display role. */
    Normal = "Normal",
    /** The waypoint role for displaying waypoints along the flight plan. */
    FlightPlan = "FlightPlan"
}

/**
 * Component props for the MapComponent.
 */
interface SynVisProps extends ComponentProps {
    /** The unique ID to assign to this Bing map. */
    bingId: string;
    /**
     * A subscribable which provides the internal resolution for the Bing component.
     */
    resolution: Subscribable<ReadonlyFloat64Array>;
    /**
     * A subscribable array which provides the earth colors. The array should have a length of exactly 61, with index 0
     * defining the water color and indexes 1 through 60 defining terrain colors from 0 to 60000 feet.
     */
    earthColors?: SubscribableArray<number>;
    /**
     * A subscribable which provides the sky color.
     */
    skyColor: Subscribable<number>;
    /** CSS class(es) to add to the root of the component. */
    class?: string | SubscribableSet<string>;
}
/**
 * A FSComponent that display the MSFS Bing Map, weather radar, and 3D terrain.
 */
declare class SynVisComponent extends DisplayComponent<SynVisProps> {
    protected readonly bingRef: NodeReference<HTMLImageElement>;
    /**
     * A callback which is called when the Bing component is bound.
     */
    protected onBingBound: () => void;
    /**
     * Renders the syn vis component.
     * @returns A component VNode.
     */
    render(): VNode;
}

/** The acceptable priority types for a given warning. */
declare enum WarningType {
    Warning = 0,
    Caution = 1,
    Test = 2,
    SoundOnly = 3
}
/** The main logic for a system warning. */
declare class Warning {
    /** The category of the warnining. */
    readonly type: WarningType;
    /** The short-form text. */
    readonly shortText?: string;
    /** The long-form text. */
    readonly longText?: string;
    /** The name of a sound to play along with the visual warning. */
    readonly soundId?: string;
    /** The XML logic element triggering this warning if true. */
    readonly condition: CompositeLogicXMLElement;
    /** Does this only fire once? */
    readonly once?: boolean;
    /** If a one-shot, has this been triggered already? */
    private _triggered;
    /** The event ID for this sound. */
    private _soundEventId?;
    /**
     * Creates an instance of a Warning.
     * @param type The type of warning this is.
     * @param condition An XML logic element with the trigger logic.
     * @param shortText The warning message in short form.
     * @param longText The warning message in long form.
     * @param soundId The sound name to use with this warning.
     * @param once True if this warning only fires once
     */
    constructor(type: WarningType, condition: CompositeLogicXMLElement, shortText?: string, longText?: string, soundId?: string, once?: boolean);
    /**
     * Whether or not we have any text at all.
     * @returns True if any non-empty text strings are set.
     */
    get hasText(): boolean;
    /**
     * The alert is being fired, take action.
     */
    trigger(): void;
    /**
     * A text description for the warning, for debugging purposes.
     * @returns A string
     */
    get description(): string;
    /**
     * Whether or not the warning has been triggered in this session.
     * @returns True if the warning has been triggered.
     */
    get triggered(): boolean;
    /**
     * Can this alert fire?
     * @returns True if the current configuration allows the alert to fire.
     */
    get canTrigger(): boolean;
    /**
     * The event ID Coherent returns when this sound has been played.
     * @returns A Name_Z based on the sound ID.
     */
    get eventId(): Name_Z | undefined;
}
/** The basic component for handling warning logic. */
declare class WarningManager {
    private warnings;
    private warnActiveStates;
    private logicHost;
    private textCb;
    private soundCb?;
    private curSndIdx;
    private curTxtIdx;
    /**
     * Create a WarningManager.
     * @param warnings An array of warnings to manage.
     * @param logicHost An event bus.
     * @param textCb A callback to display new warning text.
     * @param soundCb A callback to play an instrument sound from a sound ID.
     */
    constructor(warnings: Array<Warning>, logicHost: CompositeLogicXMLHost, textCb: (warning: Warning | undefined) => void, soundCb?: (warning: Warning, active: boolean) => void);
    /**
     * Handle a warning firing.  This is rather complex, but it basically keeps
     * track of every warning that is active, both for text and for sound, and
     * makes sure that the highest priority version of each is played or
     * displayed, masking and restoring lower priority warnings as needed.
     * @param warnIndex The index of our warnings array that's firing.
     * @param active 1 if the warning is active, 0 otherwise.
     */
    private handleWarning;
}

/** Create a list of system warnings. */
declare class XMLWarningFactory {
    private instrument;
    /**
     * Create an XMLWarningFactory.
     * @param instrument The instrument that the warnings run in.
     */
    constructor(instrument: BaseInstrument);
    /**
     * Parse a panel.xml configuration to create a list of warnings.  The warning
     * priority is defined by their order in panel.xml, with higher priority
     * warnings coming sooner in the file.
     * @param document The configuration as an XML document.
     * @returns An array of Warnings
     */
    parseConfig(document: Document): Array<Warning>;
}

/**
 * FADEC-related events.
 */
declare type FadecEvents = {
    /** Whether FADEC is active. */
    fadec_active: boolean;
    /** The name of the currently active FADEC mode. */
    [fadec_mode: IndexedEventType<'fadec_mode'>]: string;
};

/**
 * A control mode used by a jet FADEC.
 */
interface JetFadecMode {
    /** The name of this mode. */
    readonly name: string;
    /**
     * Checks whether the FADEC should enter this mode for a specified engine.
     * @param index The index of the engine.
     * @param throttleLeverPos The virtual position of the throttle lever, in the range of 0 - 1.
     * @param throttle The current engine throttle setting, in the range of 0 - 1.
     * @param thrust The current net thrust delivered by the engine, in pounds.
     * @param n1 The current N1 value of the engine, in percent.
     * @param n1Corrected The current corrected N1 value of the engine, in percent.
     * @returns Whether the FADEC should enter this mode for the specified engine.
     */
    accept(index: number, throttleLeverPos: number, throttle: number, thrust: number, n1: number, n1Corrected: number): boolean;
    /**
     * Computes the desired engine throttle setting.
     * @param index The index of the engine.
     * @param throttleLeverPos The virtual position of the throttle lever, in the range of 0 - 1.
     * @param throttle The current engine throttle setting, in the range of 0 - 1.
     * @param thrust The current net thrust delivered by the engine, in pounds.
     * @param n1 The current N1 value of the engine, in percent.
     * @param n1Corrected The current corrected N1 value of the engine, in percent.
     * @param dt The elapsed time since the last FADEC update, in milliseconds.
     * @returns The desired engine throttle setting, in the range of 0 - 1.
     */
    computeDesiredThrottle(index: number, throttleLeverPos: number, throttle: number, thrust: number, n1: number, n1Corrected: number, dt: number): number;
    /**
     * Gets the visible position of the throttle lever for a specified engine.
     * @param index The index of the engine.
     * @param throttleLeverPos The virtual position of the throttle lever, in the range of 0 - 1.
     * @returns The visible position of the throttle lever, in the range of 0 - 1.
     */
    getVisibleThrottlePos(index: number, throttleLeverPos: number): number;
}
/**
 * Information for a throttle controlled by a jet FADEC.
 */
declare type JetFadecThrottleInfo = {
    /** The index of the engine controlled by the throttle. */
    index: number;
    /** The event bus topic that emits the throttle's virtual lever position. */
    leverPosTopic: string;
    /** The name of the SimVar controlling the throttle's visible lever position. */
    visiblePosSimVar: string;
};
/**
 * A FADEC for turbojets. Controls engine throttle based on throttle lever position and other inputs.
 */
declare class JetFadec {
    protected readonly bus: EventBus;
    protected readonly modes: readonly JetFadecMode[];
    protected readonly throttleInfos: readonly JetFadecThrottleInfo[];
    protected readonly throttleLeverPositionSubs: readonly ConsumerSubject<number>[];
    private readonly updateHandler;
    private readonly realTimeSub;
    private updateTimer;
    private lastUpdateTime;
    protected readonly lastModes: (JetFadecMode | null)[];
    /**
     * Constructor.
     * @param bus The event bus.
     * @param modes The modes supported by this FADEC, ordered from highest to lowest priority.
     * @param throttleInfos An array containing information pertaining to the throttles controlled by this FADEC. The
     * order of modes in the array determines their priority during mode selection. On every update cycle, the FADEC
     * iterates through the modes array in order, calling `accept()` on each mode until a value of `true` is returned.
     * Therefore, modes positioned earlier in the array have a higher priority for selection.
     */
    constructor(bus: EventBus, modes: readonly JetFadecMode[], throttleInfos: readonly JetFadecThrottleInfo[]);
    /**
     * Turns this FADEC on. If this FADEC is already running, then it will be turned off before turning on again with
     * the specified frequency.
     * @param frequency The frequency, in hertz, at which this FADEC will update.
     */
    start(frequency: number): void;
    /**
     * Turns this FADEC off.
     */
    stop(): void;
    /**
     * Updates this FADEC.
     */
    private update;
    /**
     * This method.
     * @param dt The elapsed time, in milliseconds, since the last update.
     */
    protected onUpdate(dt: number): void;
    /**
     * Updates a throttle.
     * @param index The index of the throttle in this FADEC's throttle list.
     * @param dt The elapsed time, in milliseconds, since the last update.
     */
    protected updateThrottle(index: number, dt: number): void;
    /**
     * Sets a FADEC mode for a throttle.
     * @param index The index of the throttle in this FADEC's throttle list.
     * @param mode The mode to set.
     */
    protected setMode(index: number, mode: JetFadecMode | null): void;
}

/**
 * Virtual throttle lever events.
 */
interface VirtualThrottleLeverEvents {
    /** The position of an indexed virtual throttle lever. Ranges from 0 to 1. */
    [v_throttle_lever_pos: IndexedEventType<'v_throttle_lever_pos'>]: number;
}
/**
 * A manager for virtual throttle levers. Intercepts key events that control engine throttle settings and uses them
 * to move virtual throttle levers instead. The positions of the virtual throttle levers are published on the event
 * bus.
 */
declare class ThrottleLeverManager {
    private readonly bus;
    private static readonly THROTTLE_COUNT;
    private static readonly RAW_MIN;
    private static readonly RAW_MAX;
    private static readonly RAW_RANGE;
    private static readonly RAW_STEP;
    private keyInterceptManager?;
    private readonly throttleLeverRawPositions;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param onInitCallback A callback function to be executed once this manager is initialized.
     */
    constructor(bus: EventBus, onInitCallback?: () => void);
    /**
     * Responds to key intercept events.
     * @param data The event data.
     * @param data.key The key that was intercepted.
     * @param data.value The value of the intercepted key event.
     */
    private onKeyIntercepted;
    /**
     * Sets the raw throttle lever position.
     * @param rawPosition The raw position to set.
     * @param index The index of the throttle lever to set. If undefined, the positions of all throttle levers will be
     * set.
     */
    private setRawThrottleLeverPosition;
    /**
     * Publishes a virtual throttle lever position.
     * @param position The position to publish.
     * @param index The index of the throttle lever for which to publish. If undefined, positions will be published for
     * all throttle levers.
     */
    private publishThrottleLeverPosition;
}

/**
 * A class for caching images.
 * Do your own instrument specific implementation with an init() method
 * that will add images to cache on instrument load to prefill the cache.
 * @class ImageCache
 */
declare abstract class ImageCache {
    private static cache;
    /**
     * Loads the image from the url and adds it to the cache.
     * @static
     * @param key The image key to access it later.
     * @param url The url to load the image from.
     */
    static addToCache(key: string, url: string): void;
    /**
     * Gets a cached image element.
     * @static
     * @param key The key of the cached image.
     * @returns The cached image element.
     */
    static get(key: string): HTMLImageElement;
}

/** Scroll utils */
declare class ScrollUtils {
    /**
     * Scrolls the container to make sure an element is in view.
     * @param el The element to scroll into view in the container.
     * @param container The container to scroll.
     */
    static ensureInView(el: HTMLElement, container: HTMLElement): void;
    /**
     * Finds the offsetTop of an element relative to one of its ancestors.
     * @param element An element.
     * @param ancestor An ancestor of `element`.
     * @returns the offsetTop of the element relative to the ancestor.
     * @throws Error if the offsetTop could not be calculated.
     */
    private static findOffsetTopRelativeToAncestor;
    /**
     * Checks if an element is visible.
     * @param cTop The top coordinate of the scroll container.
     * @param cBottom The bottom coordinate of the scroll container.
     * @param eTop The top coordinate of the element.
     * @param eBottom The bottom coordinate of the element.
     * @returns A boolean.
     */
    private static isElementInViewport;
}

/**
 * A path stream which builds SVG path strings from its input path commands.
 */
declare class SvgPathStream implements PathStream {
    private static readonly vec2Cache;
    private svgPath;
    private precision;
    private formatter;
    private readonly firstPoint;
    private readonly prevPoint;
    /**
     * Constructor.
     * @param precision The precision of this stream. All coordinates will be rounded to this stream's precision when
     * building the SVG path string. A value of `0` indicates infinite precision. Defaults to `0`.
     */
    constructor(precision?: number);
    /**
     * Gets the SVG path string describing all path commands consumed by this stream since the last call to
     * `beginPath()`.
     * @returns The SVG path string describing all path commands consumed by this stream since the last call to
     * `beginPath()`.
     */
    getSvgPath(): string;
    /**
     * Gets the precision of this stream. All coordinates will be rounded to this stream's precision when building the
     * SVG path string. A value of `0` indicates infinite precision.
     * @returns The precision of this stream.
     */
    getPrecision(): number;
    /**
     * Sets the precision of this stream. All coordinates will be rounded to this stream's precision when building the
     * SVG path string. A value of `0` indicates infinite precision.
     * @param precision The precision of this stream. Negative numbers will be converted to their absolute values.
     */
    setPrecision(precision: number): void;
    /** @inheritdoc */
    beginPath(): void;
    /** @inheritdoc */
    moveTo(x: number, y: number): void;
    /** @inheritdoc */
    lineTo(x: number, y: number): void;
    /** @inheritdoc */
    bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;
    /** @inheritdoc */
    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;
    /** @inheritdoc */
    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterClockwise?: boolean): void;
    /** @inheritdoc */
    closePath(): void;
    /**
     * Resets the state of this stream.
     */
    private reset;
}

/** A collection of handy SVG functions. */
declare class SVGUtils {
    /**
     * Creates an arc using an SVG path.
     * From https://stackoverflow.com/questions/5736398/how-to-calculate-the-svg-path-for-an-arc-of-a-circle
     * @param x Arc center x position.
     * @param y Arc center y position.
     * @param radius Arc radius.
     * @param startAngle Arc start angle.
     * @param endAngle Arc end angle.
     * @returns The d value for and SVG path element.
     */
    static describeArc(x: number, y: number, radius: number, startAngle: number, endAngle: number): string;
}

declare enum DmsDirection {
    NORTH = "N",
    SOUTH = "S",
    WEST = "W",
    EAST = "E"
}
/** Holds the parts  */
declare type DmsValues = {
    /** The direction N/S/E/W */
    direction: DmsDirection;
    /** The degrees component */
    degrees: number;
    /** The minutes component */
    minutes: number;
    /** The seconds component */
    seconds: number;
};
/**
 * A class to format latitude/longitude to DMS.
 * @class DmsFormatter
 */
declare class DmsFormatter {
    private readonly coordsParts;
    /**
     * Builds a DMS string out of the given latitude.
     * @param value The latitude.
     * @param spaceAfterDirection Whether to insert a space after the direction letter.
     * @returns The DMS string.
     */
    getLatDmsStr(value: number, spaceAfterDirection?: boolean): string;
    /**
     * Builds a DMS string out of the given longitude.
     * @param value The longitude.
     * @returns The DMS string.
     */
    getLonDmsStr(value: number): string;
    /**
     * Parses a latitude in to the dms parts.
     * @param value The latitude in degrees.
     * @returns The DMS parts.
     */
    parseLat(value: number): DmsValues;
    /**
     * Parses a longitude in to the dms parts.
     * @param value The longitude in degrees.
     * @returns The DMS parts.
     */
    parseLon(value: number): DmsValues;
    /**
     * Parses the latitude/longitude.
     * @private
     * @param value The value to parse.
     * @returns The DMS parts.
     */
    private parse;
}

/**
 * Options for creating a number formatter.
 */
declare type NumberFormatterOptions = {
    /** The precision to which to round the number. A value of 0 denotes no rounding. */
    precision: number;
    /** Rounding behavior. Always round down = `-1`. Always round up = `+1`. Normal rounding = `0`. */
    round: -1 | 0 | 1;
    /**
     * The maximum number of digits to enforce. Digits to the _right_ of the decimal point will be omitted (with proper
     * rounding behavior) as necessary until the total number of digits in the output is less than or equal to the value
     * of this option or until there are no more digits to omit. Digits to the _left_ of the decimal point are always
     * preserved, even if it means the number of digits in the output will exceed the value of this option.
     */
    maxDigits: number;
    /**
     * Whether to force trailing zeroes to the right of the decimal point. The number of trailing zeroes is determined
     * by the `precision` option. Specifically, trailing zeroes are added to the least significant decimal place required
     * to represent the value of `precision` (and therefore, any possible output rounded to `precision`) with no
     * rounding.
     */
    forceDecimalZeroes: boolean;
    /** The number of digits to which to pad with zeroes to the left of the decimal point. */
    pad: number;
    /** Whether to show commas. */
    showCommas: boolean;
    /** Whether to force the display of a positive sign. */
    forceSign: boolean;
    /** The string to output for an input of NaN. */
    nanString: string;
};
/**
 * A utility class for creating number formatters.
 *
 * Each number formatter is a function which generates output strings from input numeric values. The formatting
 * behavior of a formatter is defined by its options. Please refer to the {@link NumberFormatterOptions} type
 * documentation for more information on each individual option.
 */
declare class NumberFormatter {
    static readonly DEFAULT_OPTIONS: Readonly<NumberFormatterOptions>;
    private static readonly roundFuncs;
    /**
     * Formats a number to a string.
     * @param precision The precision to which to round the number. A value of 0 denotes no rounding.
     * @param roundFunc The rounding function to use.
     * @param maxDigits The maximum number of digits to enforce.
     * @param forceDecimalZeroes Whether to force trailing zeroes after the decimal point.
     * @param pad The number of digits to which to pad with zeroes in front of the decimal point.
     * @param showCommas Whether to show commas.
     * @param forceSign Whether to force the display of a positive sign.
     * @param nanString The string to use for NaN.
     * @param number The number to format.
     * @returns A formatted string.
     */
    private static formatNumber;
    /**
     * Creates a function which formats numeric values to strings. The formatting behavior of the function can be
     * customized using a number of options. Please refer to the {@link NumberFormatterOptions} type documentation for
     * more information on each individual option.
     * @param options Options to customize the formatter. Options not explicitly defined will be set to the following
     * default values:
     * * `precision = 0`
     * * `round = 0`
     * * `maxDigits = Infinity`
     * * `forceDecimalZeroes = true`
     * * `pad = 1`
     * * `showCommas = false`
     * * `forceSign = false`
     * * `nanString = 'NaN'`
     * @returns A function which formats numeric values to strings.
     */
    static create(options: Partial<NumberFormatterOptions>): (number: number) => string;
}

/**
 * A utility class for creating duration formatters.
 *
 * Each duration formatter is a function which generates output strings from input duration values. The formatting
 * behavior of a formatter is defined by its format template.
 *
 * Format templates are strings which contain zero or more fragments enclosed by curly braces (`{}`); For a given
 * format template, an output string is generated from an input duration by replacing each fragment in the template
 * with a string generated from the input. The parts of the template string that are not contained in any fragment are
 * passed to the output unchanged. Each fragment defines how its replacement string is generated. There are two types
 * of fragments:
 * * Sign fragment. In EBNF notation, these take the form `['+'], ('-' | '')`. Each sign fragment is replaced with
 * a character representing the sign of the input. The negative sign character is defined by the last character of
 * the fragment definition. The positive sign character (`+`) is included in the replacement if and only if it
 * appears in the fragment definition.
 * * Numeric fragment. In EBNF notation, these take the form
 * `{x}, ['?'], ['.', [{x}], ['(', {x}, ')']]`
 * where `x = 'H' | 'M' | 'S' | 'h' | 'm' | 's'`. Each numeric fragment is replaced with the numeric value of the
 * duration in hours, minutes, or seconds, depending on which character is used for `x`. With uppercase letters, the
 * entire portion of the input value is used. With lowercase letters, only the portion of the input value that does not
 * divide evenly into the next smallest unit is used (for hours, which is the largest unit, there is no difference
 * between using `'H'` and `'h'`).
 *   * The number of `x` characters to the left of the decimal point (including all characters if no decimal point is
 * present) in the definition controls the number of leading zeroes with which the output will be padded.
 *   * If the optional `'?'` character is present, the output will drop all digits to the left of the decimal point if
 * all such digits are equal to 0.
 *   * The total number of `x` characters to the right of the decimal point in the definition controls the decimal
 * precision of the output. Trailing zeroes to the right of the decimal point will be added to the output to a number
 * of decimal places equal to the number of non-parenthetical `x` characters to the right of the decimal point in the
 * definition. If there are no `x` characters to the right of the decimal point in the definition, then the output will
 * have infinite decimal precision with no extraneous trailing zeroes.
 *   * Rounding behavior is always round down.
 *
 * @example <caption>Formatting to hours-minutes-seconds</caption>
 * const formatter = DurationFormatter.create('{h}:{mm}:{ss}');
 * console.log(formatter(3616000));  // 1:00:16
 * console.log(formatter(36016900)); // 10:00:16
 *
 * @example <caption>Formatting to hours-minutes-seconds with decimal precision</caption>
 * const formatter = DurationFormatter.create('{h}:{mm}:{ss.s(s)}');
 * console.log(formatter(3600000)); // 1:00:00.0
 * console.log(formatter(3600550)); // 1:00:00.55
 *
 * @example <caption>Formatting to minutes-seconds</caption>
 * const formatter = DurationFormatter.create('{MM}:{ss}');
 * console.log(formatter(600000));  // 10:00
 * console.log(formatter(4200000)); // 70:00.
 *
 * @example <caption>Formatting with signs</caption>
 * const formatter = DurationFormatter.create('{-}{h}:{mm}');
 * console.log(formatter(3600000));  // 1:00
 * console.log(formatter(-3600000)); // -1:00
 *
 * const formatterWithPositiveSign = DurationFormatter.create('{+-}{h}:{mm}');
 * console.log(formatterWithPositiveSign(3600000));  // +1:00
 */
declare class DurationFormatter {
    private static readonly FORMAT_REGEXP;
    private static readonly SIGN_FRAGMENT_REGEX;
    private static readonly NUM_FRAGMENT_REGEXP;
    private static readonly NUM_FRAGMENT_UNIT_INFO;
    private static readonly NUM_FRAGMENT_ROUND_FUNCS;
    /**
     * Creates a function which formats durations, expressed as numeric values, to strings. The formatting behavior of
     * the function is defined by a specified format template. For more information on format templates and their syntax,
     * please refer to the {@link DurationFormatter} class documentation.
     * @param format A template defining how the function formats durations.
     * @param unit The unit type in which the input duration values are expressed.
     * @param nanString The string to output when the input duration is `NaN`. Defaults to `'NaN'`.
     * @returns A function which formats durations, expressed as numeric values, to strings.
     */
    static create(format: string, unit: Unit<UnitFamily.Duration>, nanString?: string): (duration: number) => string;
    /**
     * Creates a function which formats durations, expressed as {@link NumberUnitInterface} objects, to strings. The
     * formatting behavior of the function is defined by a specified format template. For more information on format
     * templates and their syntax, please refer to the {@link DurationFormatter} class documentation.
     * @param format A template defining how the function formats durations.
     * @param nanString The string to output when the input duration is `NaN`. Defaults to `'NaN'`.
     * @returns A function which formats durations, expressed as {@link NumberUnitInterface} objects, to strings.
     */
    static createForNumberUnit(format: string, nanString?: string): (duration: NumberUnitInterface<UnitFamily.Duration>) => string;
    /**
     * Creates an output string builder from a format template.
     * @param format A format template.
     * @returns An output string builder which conforms to the specified format template.
     */
    private static createBuilder;
    /**
     * Parses a format template fragment and returns a function which generates a string from an input duration according
     * to the rules defined by the fragment. If the fragment is malformed, this method returns a function which always
     * generates an empty string.
     * @param fragment A format template fragment definition.
     * @returns A function which generates a string from an input duration in milliseconds according to the rules defined
     * by the template fragment.
     */
    private static parseFragment;
}

/**
 * Options for creating a time formatter.
 */
declare type DateTimeFormatterOptions = {
    /** Names for months, starting with January. */
    monthNames: [string, string, string, string, string, string, string, string, string, string, string, string];
    /** Abbreviated names for months, starting with January. */
    monthNamesShort: [string, string, string, string, string, string, string, string, string, string, string, string];
    /** Names for days of the week, starting with Sunday. */
    dayNames: [string, string, string, string, string, string, string];
    /** Abbreviated names for days of the week, starting with Sunday. */
    dayNamesShort: [string, string, string, string, string, string, string];
    /** The string to output for an input of NaN. */
    nanString: string;
};
/**
 * A utility class for creating time formatters.
 *
 * Each time formatter is a function which generates output strings from input time values, expressed as UNIX
 * timestamps in milliseconds. The formatting behavior of a formatter is defined by its format template and options.
 *
 * Please refer to the {@link DateTimeFormatterOptions} type documentation for more information on individual
 * formatting options.
 *
 * Format templates are strings which contain zero or more fragments enclosed by curly braces (`{}`); For a given
 * format template, an output string is generated from an input duration by replacing each fragment in the template
 * with a string generated from the input. The parts of the template string that are not contained in any fragment are
 * passed to the output unchanged. Each fragment defines how its replacement string is generated. There are two types
 * of fragments:
 * * Numeric fragment. In EBNF notation, these take the form `{x}` where `x = 'M' | 'd' | 'w' | 'H' | 'h' | 'm' | 's'`.
 * Each numeric fragment is replaced with a numeric representation of the month (`M`), day of month (`d`), day of week
 * (`w`), hour-24 (`H`), hour-12 (`h`), minute (`m`), or second (`s`) part of the input time. The number of `x`
 * characters in the definition controls the number of leading zeroes with which the output will be padded.
 * * Year fragment. In EBNF notation, these take the form `'YY' | 'YYYY'`. Each year fragment is replaced with either
 * the two-digit (`YY`) or unlimited-digit (`YYYY`) year of the input time.
 * * Month fragment. In EBNF notation, these take the form `('mon', ['.']) | ('MON', ['.']) | 'month' | 'MONTH'`. Each
 * month fragment is replaced with the name of the month of the input time. The case of the definition determines the
 * case of the output. `mon` will use abbreviated names. The presence of the optional `'.'` character will add a period
 * to the end of the abbreviated names.
 * * Day-of-week fragment. In EBNF notation, these take the form `('dy', ['.']) | ('DY', ['.']) | 'day' | 'DAY'`. Each
 * day-of-week fragment is replaced with the name of the day-of-week of the input time. The case of the definition
 * determines the case of the output. `dy` will use abbreviated names. The presence of the optional `'.'` character
 * will add a period to the end of the abbreviated names.
 * * AM/PM fragment. In EBNF notation, these take the form `'am' | 'a.m.' | 'AM' | 'A.M.'`. Each AM/PM fragment is
 * replaced with an AM/PM string depending on the time of day of the input. The case of the definition determines the
 * case of the output. Use of periods in the definition will add periods to the output.
 */
declare class DateTimeFormatter {
    private static readonly FORMAT_REGEXP;
    private static readonly FRAGMENT_REGEXP;
    private static readonly NUM_GETTERS;
    static readonly DEFAULT_OPTIONS: Readonly<DateTimeFormatterOptions>;
    /**
     * Creates a function which formats times, expressed as UNIX timestamps in milliseconds, to strings. The formatting
     * behavior of the function is defined by a specified format template and options. For more information on format
     * templates and their syntax, please refer to the {@link DateTimeFormatter} class documentation. For more
     * information on individual formatting options, please refer to the {@link DateTimeFormatterOptions} type
     * documentation.
     * @param format A template defining how the function formats durations.
     * @param options Options to customize the formatter. Options not explicitly defined will be set to the following
     * default values:
     * * `monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']`
     * * `monthNamesShort = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']`
     * * `dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']`
     * * `dayNamesShort = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']`
     * * `nanString = 'NaN'`
     * @returns A function which formats times, expressed as UNIX timestamps in milliseconds, to strings.
     */
    static create(format: string, options?: Partial<DateTimeFormatterOptions>): (time: number) => string;
    /**
     * Creates an output string builder from a format template and options.
     * @param format A format template.
     * @param options Formatting options.
     * @returns An output string builder which conforms to the specified format template and options.
     */
    private static createBuilder;
    /**
     * Parses a format template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment. If the fragment is malformed, this method returns a function which always
     * generates an empty string.
     * @param fragment A format template fragment definition.
     * @param options Formatting options.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the template fragment.
     */
    private static parseFragment;
    /**
     * Parses a numeric template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment.
     * @param match A numeric template fragment, as a regular expression match.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the numeric template fragment.
     */
    private static parseNumFragment;
    /**
     * Parses a year template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment.
     * @param match A year template fragment, as a regular expression match.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the year template fragment.
     */
    private static parseYearFragment;
    /**
     * Parses a month template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment.
     * @param match A month template fragment, as a regular expression match.
     * @param options Formatting options.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the month template fragment.
     */
    private static parseMonthFragment;
    /**
     * Parses a day-of-week template fragment and returns a function which generates a string from an input time
     * according to the rules defined by the fragment.
     * @param match A day-of-week template fragment, as a regular expression match.
     * @param options Formatting options.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the day-of-week template fragment.
     */
    private static parseDayFragment;
    /**
     * Parses an am/pm template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment.
     * @param match An am/pm template fragment, as a regular expression match.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the am/pm template fragment.
     */
    private static parseAMPMFragment;
}

/**
 * The state of an avionics system.
 */
declare enum AvionicsSystemState {
    Off = "Off",
    Initializing = "Initializing",
    On = "On",
    Failed = "Failed"
}
/**
 * An event that contains an avionics system state change.
 */
interface AvionicsSystemStateEvent {
    /** The previous system state. */
    previous: AvionicsSystemState | undefined;
    /** The state that the system was changed to. */
    current: AvionicsSystemState;
}
/**
 * An interface that describes a basic avionics system.
 */
interface AvionicsSystem {
    /** The state of the avionics system. */
    readonly state: AvionicsSystemState | undefined;
    /** A callback to call to update the state of the avionics system. */
    onUpdate(): void;
    /** The index of the system, for multiply redundant systems. */
    readonly index: number;
}

/**
 * A simple timer for handling debounce.
 */
declare class DebounceTimer {
    private timer;
    /**
     * Checks whether an action is pending on this timer.
     * @returns Whether an action is pending on this timer.
     */
    isPending(): boolean;
    /**
     * Schedules an action. Waits for a specified amount of time, and executes the action only if no other action is
     * scheduled on this timer during the delay.
     * @param action The action to schedule.
     * @param delay The debounce delay, in milliseconds.
     */
    schedule(action: () => void, delay: number): void;
    /**
     * Clears this timer of any pending actions. Actions that are cleared will not be executed.
     */
    clear(): void;
}

/** A type that pulls keys that have avionics state events from a supplied generic type. */
declare type StateEventsOnly<T> = {
    [K in keyof T as T[K] extends AvionicsSystemStateEvent ? K : never]: T[K];
};
/** The subset of electrical events that have boolean values.  */
declare type ElectricalBools = {
    [K in keyof ElectricalEvents]: ElectricalEvents[K] extends boolean ? ElectricalEvents[K] : never;
};
/**
 * An electrical system key to which system power can be connected.
 */
declare type SystemPowerKey = keyof ElectricalBools;
/**
 * A basic avionics system with a fixed initialization time and logic.
 */
declare abstract class BasicAvionicsSystem<T extends Record<string, any>> implements AvionicsSystem {
    readonly index: number;
    protected readonly bus: EventBus;
    protected readonly stateEvent: keyof StateEventsOnly<T> & string;
    protected _state: AvionicsSystemState | undefined;
    /** @inheritdoc */
    get state(): AvionicsSystemState | undefined;
    /** The time it takes in milliseconds for the system to initialize. */
    protected initializationTime: number;
    /** A timeout after which initialization will be complete. */
    protected readonly initializationTimer: DebounceTimer;
    /** Whether or not the system is powered. */
    protected isPowered: boolean | undefined;
    protected electricalPowerSub?: Subscription;
    protected electricalPowerLogic?: CompositeLogicXMLElement;
    /**
     * Creates an instance of a BasicAvionicsSystem.
     * @param index The index of the system.
     * @param bus The instance of the event bus for the system to use.
     * @param stateEvent The key of the state update event to send on state update.
     */
    constructor(index: number, bus: EventBus, stateEvent: keyof StateEventsOnly<T> & string);
    /**
     * Connects this system's power state to an {@link ElectricalEvents} topic or electricity logic element.
     * @param source The source to which to connect this system's power state.
     */
    protected connectToPower(source: SystemPowerKey | CompositeLogicXMLElement): void;
    /**
     * Sets the state of the avionics system and publishes the change.
     * @param state The new state to change to.
     */
    protected setState(state: AvionicsSystemState): void;
    /**
     * Responds to changes in this system's state.
     * @param previousState The previous state.
     * @param currentState The current state.
     */
    protected onStateChanged(previousState: AvionicsSystemState | undefined, currentState: AvionicsSystemState): void;
    /**
     * A callback called when the connected power state of the avionics system changes.
     * @param isPowered Whether or not the system is powered.
     */
    protected onPowerChanged(isPowered: boolean): void;
    /** @inheritdoc */
    onUpdate(): void;
    /**
     * Updates this system's power state from an electricity logic element.
     */
    protected updatePowerFromLogic(): void;
}

/** A class that linearly drives a SimVar value towards a given set point. */
declare class LinearServo {
    private rate;
    /** The current time. */
    private currentTime?;
    /**
     * Creates an instance of a LinearServo.
     * @param rate The rate, in units per second, to drive the servo.
     */
    constructor(rate: number);
    /**
     * Drives the servo towards the set point.
     * @param currentValue The current value.
     * @param setValue The value to drive towards.
     * @returns The output value.
     */
    drive(currentValue: number, setValue: number): number;
}

/** A PID controller. */
declare class PidController {
    private kP;
    private kI;
    private kD;
    private maxOut;
    private minOut;
    private maxI;
    private minI;
    /** The previously sampled error. */
    private previousError;
    /** The previously generated output. */
    private previousOutput;
    /** The currently accumulated integral. */
    private integral;
    /**
     * Creates a new PidController.
     * @param kP The proportional gain of the controller.
     * @param kI The integral gain of the controller.
     * @param kD The differential gain of the controller.
     * @param maxOut The maximum output of the controller.
     * @param minOut The minumum output of the controller.
     * @param maxI The maximum integral gain.
     * @param minI The minimum integral gain.
     */
    constructor(kP: number, kI: number, kD: number, maxOut: number, minOut: number, maxI?: number, minI?: number);
    /**
     * Gets the output of the PID controller at a given time.
     * @param deltaTime The difference in time between the previous sample and this sample.
     * @param error The amount of error seen between the desired output and the current output.
     * @returns The PID output.
     */
    getOutput(deltaTime: number, error: number): number;
    /** Resets the controller. */
    reset(): void;
    /**
     * Clamps a number to maximum and minimum values.
     * @param value The value to clamp.
     * @param max The maximum value.
     * @param min The minumum value.
     * @returns The clamped value.
     */
    static clamp(value: number, max: number, min: number): number;
}

/**
 * Configuration object for flight plan predictor
 */
interface FlightPlanPredictorConfiguration {
    /**
     * Whether to generate predictions for missed approach legs
     */
    predictMissedApproachLegs: boolean;
    /**
     * Minimum ground speed to be considered for predictions
     */
    minimumPredictionsGroundSpeed: number;
    /**
     * NOOP - whether the start of the turn is considered to be the end of the leg
     */
    considerTurnAsLegTermination: boolean;
}

/**
 * Base information for leg predictions
 */
interface BaseLegPredictions {
    /**
     * Kind of predictions ('activeOrUpcoming' or 'passed')
     */
    kind: string;
    /**
     * Ident of the associated leg
     */
    ident: string;
    /**
     * Distance to the termination of the leg from PPOS
     */
    distance: number;
    /**
     * Estimated Time of Arrival of the leg, in UTC seconds from midnight
     */
    estimatedTimeOfArrival: number;
    /**
     * Estimated time Enroute of the leg, in seconds duration
     */
    estimatedTimeEnroute: number;
    /**
     * Fuel on board at leg termination, in pounds
     */
    fob: number | null;
}
/**
 * Contains predicted and achieved data for a passed flight plan leg
 */
interface PassedLegPredictions extends BaseLegPredictions {
    /** @inheritDoc */
    kind: 'passed';
    /**
     * Actual Time of Arrival of the leg, in UTC seconds from midnight
     */
    actualTimeOfArrival: number;
    /**
     * Actual time Enroute of the leg, in seconds duration
     */
    actualTimeEnroute: number;
    /**
     Actual fuel on board at leg termination, in metric tonnes
     */
    actualFob: number | null;
}
/**
 * Contains data predicted for an active or upcoming flight plan leg
 */
interface ActiveOrUpcomingLegPredictions extends BaseLegPredictions {
    /** @inheritDoc */
    kind: 'activeOrUpcoming';
}
/**
 * Leg predictions data, either passed or active/upcoming
 */
declare type LegPredictions = PassedLegPredictions | ActiveOrUpcomingLegPredictions;

/**
 * Creates leg-by-leg predictions for a flight plan, both in the future by estimating performance and in the past by
 * recording predicted data and actual achieved performance.
 */
declare class FlightPlanPredictor {
    private readonly bus;
    private readonly flightPlanner;
    private readonly planIndexSub;
    private readonly activeLegIndexSub;
    private readonly config;
    private readonly predictions;
    private readonly store;
    /**
     * Ctor
     *
     * @param bus               the event bus
     * @param flightPlanner     a flight planner
     * @param planIndexSub      a subscribable regarding the index of the flight plan we want to predict for
     * @param activeLegIndexSub a subscribable regarding the index of the displayed active leg, specific to the avionics suite
     * @param config            configuration object
     */
    constructor(bus: EventBus, flightPlanner: FlightPlanner, planIndexSub: Subscribable<number>, activeLegIndexSub: Subscribable<number>, config: FlightPlanPredictorConfiguration);
    /**
     * Whether the flight plan exists and has an active lateral leg index >= 1
     *
     * @returns boolean
     */
    get planAndPredictionsValid(): boolean;
    /**
     * Obtains the flight plan to predict
     *
     * @returns a flight plan
     */
    private get plan();
    /**
     * Returns the active leg index to be used
     *
     * @returns the index
     */
    private get activeLegIndex();
    /**
     * Checks if all legs in the plan are calculated
     * @returns true if all legs are calculated, false otherwise
     */
    private isAllLegsCalculated;
    /**
     * Updates the predictor
     */
    update(): void;
    /**
     * Clears out values from predictions
     *
     * @private
     */
    private clearOutValues;
    /**
     * Clears out entries that have become discontinuities
     */
    private clearOutDirtyValues;
    /**
     * Finds the index of the destination leg, in other words, the last non-missed-approach leg.
     *
     * @returns the index
     */
    private findDestinationLegIndex;
    /**
     * Returns predictions for the destination airport.
     *
     * If the dest leg (defined as the last leg that is not part of the missed approach) is not a runway,
     * then the direct distance between the termination of that leg and the provided airport facility.
     *
     * @param destinationFacility the airport facility to use in case a direct distance needs to be calculated
     *
     * @returns predictions for the destination airport
     */
    getDestinationPrediction(destinationFacility: AirportFacility): ActiveOrUpcomingLegPredictions;
    /**
     * Returns active or upcoming predictions for a given leg index
     *
     * @param index the leg index
     *
     * @returns the predictions object
     *
     * @throws if no predictions are available
     */
    predictionsForLegIndex(index: number): LegPredictions;
    /**
     * Returns active or upcoming predictions for a given leg definition
     *
     * @param leg the leg
     *
     * @returns the predictions object
     *
     * @throws if the leg is not in the flight plan used by the predictor or if no predictions are available
     */
    predictionsForLeg(leg: LegDefinition): LegPredictions;
    /**
     * Whether the leg is predicted
     *
     * @param leg the target leg
     *
     * @returns boolean
     */
    isLegPredicted(leg: LegDefinition): boolean;
    /**
     * Applies a reducer function to the predictions of active and upcoming legs
     *
     * @param initialValue initial accumulator value
     * @param reducer      reducer function
     * @param upTo         index to reduce to
     *
     * @returns reduced value
     */
    reducePredictions(initialValue: number, reducer: (accumulator: number, predictions: ActiveOrUpcomingLegPredictions) => number, upTo?: number): number;
    /**
     * Generator of all predictable legs in the plan
     *
     * The yielded tuple contains the following:
     * - 0: leg index in flight plan
     * - 1: leg definition object
     * - 2: previous leg definition object, including a previous discontinuity
     *
     * @param onlyAfterActive whether to start at the active leg
     *
     * @returns generator that skips appropriate legs
     *
     * @yields legs including and after the active leg that are not discontinuities (and not in missed approach, if config asks so)
     */
    private predictableLegs;
    /**
     * Stamps the actual values from the last estimated values
     *
     * @param targetObject the object to stamp the actual values on
     *
     * @private
     */
    private stampPassedLegValues;
    /**
     * Creates predictions for a passed leg
     *
     * @param targetObject the object to apply the predictions to
     * @param leg          the leg
     *
     * @throws if calculated is undefined
     */
    private updatePassedLeg;
    /**
     * Computes predictions for the active leg
     *
     * @param targetObject the object to apply the predictions to
     *
     * @throws if no active leg in flight plan
     */
    private updateActiveLeg;
    /**
     * Creates predictions for an upcoming leg
     *
     * @param targetObject        the object to apply the predictions to
     * @param leg                 the leg
     * @param accumulatedDistance accumulated distance in previous predictions before this leg
     *
     * @throws if calculated is undefined
     */
    private updateUpcomingLeg;
    /**
     * Predicts performance over a distance
     *
     * @param targetObject        the object to apply the predictions to
     * @param distance            the distance flown
     */
    private predictForDistance;
    /**
     * Obtains current GS with a minimum of 150
     *
     * @returns knots
     */
    private currentGs;
    /**
     * Obtains current fuel weight
     *
     * @returns pounds
     */
    private currentFuelWeight;
}

/** A collection of helper functions dealing with radios and frequencies. */
declare class RadioUtils {
    /** Checks if frequency is a localizer frequency based on the number.
     * @param freq The frequency to check
     * @returns True if frequency is between 108.1 and 111.95 MHz (inclusive) and the tenths place is odd. */
    static isLocalizerFrequency(freq: number): boolean;
}

/** Events related to sound playback. */
interface SoundEvents {
    /** Request to play a sound once. */
    play_sound: string;
    /** Start playing a sound repeatedly. */
    start_sound: string;
    /** Stop playing a repeated sound.*/
    stop_sound: string;
    /** Notification that sound playback has been triggered..  */
    sound_queued: string;
    /** Notification that sound playback has ended. */
    sound_played: string;
}
/** A publisher for sound events. */
declare class SoundPublisher extends BasePublisher<SoundEvents> {
    /**
     * Create a SoundPublisher.
     * @param bus An event bus.
     * @param pacer An optional pacer to controle the rate of publishing.
     */
    constructor(bus: EventBus, pacer?: PublishPacer<SoundEvents>);
    /**
     * Request that a sound be played.
     * @param soundId The id of the sound to play.
     */
    playSound(soundId: string): void;
    /**
     * Request that a continuous sound be started.
     * @param soundId The id of the sound to play.
     */
    startSound(soundId: string): void;
    /**
     * Request that a continuous sound be stopped.
     * @param soundId The id of the sound to play.
     */
    stopSound(soundId: string): void;
    /**
     * Send a notification that play has been requested.
     * @param soundId The id of the sound requested.
     */
    soundQueued(soundId: string): void;
    /**
     * Send a notification that play has completed.
     * @param soundId The id of the sound played.
     */
    soundPlayed(soundId: string): void;
}
/**
 * A event-drive sound server that manages both one-shot and continuous sound playback.
 */
declare class SoundServer {
    private instrument;
    private playing;
    private subscriber;
    private publisher;
    /**
     * Create a sound server.
     * @param bus An event bus.
     * @param publisher A sound publisher.
     * @param instrument The hosting instance of BaseInstrument.
     */
    constructor(bus: EventBus, publisher: SoundPublisher, instrument: BaseInstrument);
    /**
     * Play a requested sound once or continuously.
     * @param soundId The id of the sound to play.
     * @param continuous Whether to play it continuously.
     */
    protected playSound(soundId: string, continuous?: boolean): void;
    /**
     * Stop a continuously played sound.
     * @param soundId The id of the sound to stop.
     */
    protected stopSound(soundId: string): void;
    /**
     * Handle a sound end event.  This needs to be called by the parent device,
     * and it takes a Name_Z, as sent from VCockpit.js in the master onSoundEnd call.
     * @param soundEventId The id of the sound event.
     */
    onSoundEnd(soundEventId: Name_Z): void;
}

declare namespace Wait {
    /**
     * Waits for a set amount of time.
     * @param delay The amount of time to wait in milliseconds.
     * @returns a Promise which is fulfilled after the delay.
     */
    function awaitDelay(delay: number): Promise<void>;
    /**
     * Waits for a condition to be satisfied.
     * @param predicate A function which evaluates whether the condition is satisfied.
     * @param interval The interval, in milliseconds, at which to evaluate the condition. A zero or negative value
     * causes the condition to be evaluated every frame. Defaults to 0.
     * @param timeout The amount of time, in milliseconds, before the returned Promise is rejected if the condition is
     * not satisfied. A zero or negative value causes the Promise to never be rejected and the condition to be
     * continually evaluated until it is satisfied. Defaults to 0.
     * @returns a Promise which is fulfilled when the condition is satisfied.
     */
    function awaitCondition(predicate: () => boolean, interval?: number, timeout?: number): Promise<void>;
}

/** The value retured when we add a item to the collection. */
declare type CollectionComponentItemRef = string;
/**
 * The props for a CollectionComponent.
 */
interface CollectionComponentProps extends ComponentProps {
    /** The element ID to use. */
    id: string;
}
/**
 * A component that lets you add and remove children.
 */
declare class CollectionComponent<P extends CollectionComponentProps> extends DisplayComponent<P> {
    private items;
    private itemCounter;
    /**
     * Add a new child element.
     * @param node A VNode to add to the container.
     * @returns An identifier for the added element.
     */
    addItem(node: VNode): CollectionComponentItemRef;
    /**
     * Remove a child element.
     * @param id The ID of the child to remove.
     */
    removeItem(id: CollectionComponentItemRef): void;
    /**
     * Insert a child before an element.
     * @param node The node to insert
     * @param before The element to insert before.
     * @returns An identifier for the added element.
     */
    insertBefore(node: VNode, before: CollectionComponentItemRef): CollectionComponentItemRef;
    /**
     * Insert a child after an element.
     * @param node The node to insert
     * @param after The element to insert after.
     * @returns An identifier for the added element.
     */
    insertAfter(node: VNode, after: CollectionComponentItemRef): CollectionComponentItemRef;
    /**
     * Render the element.
     * @returns A VNode.
     */
    render(): VNode;
}

/**
 * An interface to be implemented by instrument classes.
 */
interface FsInstrument {
    /**
     * A reference to the BaseInstrument loaded by the sim
     */
    readonly instrument: BaseInstrument;
    Update(): void;
    onInteractionEvent(_args: Array<string>): void;
    onFlightStart(): void;
    onGameStateChanged(oldState: GameState, newState: GameState): void;
}
/**
 * A class that wraps the actual instrumenet implementation and handles the sim's vcockpit lifecycle.
 */
declare abstract class FsBaseInstrument<T extends FsInstrument> extends BaseInstrument {
    protected fsInstrument: T;
    /**
     * The instrument template ID.
     * @returns The instrument template ID.
     */
    abstract get templateID(): string;
    /**
     * Called during connectedCallback to construct the actual instrument class.
     */
    abstract constructInstrument(): T;
    /**
     * A callback called when the element is attached to the DOM.
     */
    connectedCallback(): void;
    /**
     * Update method called by BaseInstrument
     */
    protected Update(): void;
    /** @inheritdoc */
    onInteractionEvent(_args: Array<string>): void;
    /** @inheritdoc */
    protected onGameStateChanged(oldState: GameState, newState: GameState): void;
    /** @inheritdoc */
    onFlightStart(): void;
    /**
     * Whether or not the instrument is interactive (a touchscreen instrument).
     * @returns True
     */
    get isInteractive(): boolean;
}

export { APAltCapDirector, APAltDirector, APAltitudeModes, APBackCourseDirector, APConfig, APDirectors, APEvents, APFLCDirector, APGPDirector, APGSDirector, APHdgDirector, APLateralModes, APLockType, APLvlDirector, APModePressEvent, APModeType, APNavDirector, APNavDirectorInterceptFunc, APPitchDirector, APRadioNavInstrument, APRollDirector, APStateManager, APStates, APVNavPathDirector, APVSDirector, APValues, APVerticalModes, AbstractFlightPathLegCalculator, AbstractFlightPathLegRenderer, AbstractFlightPathPlanRenderer, AbstractMapTextLabel, AbstractMapTextLabelOptions, AbstractMapTrafficIntruderIcon, AbstractMapWaypointIcon, AbstractMapWaypointIconOptions, AbstractNearestSubscription, AbstractNumberUnitDisplay, AbstractNumberUnitDisplayProps, AbstractSubscribable, AbstractSubscribableArray, AbstractSubscribableSet, AbstractTcasIntruder, AbstractTransformingPathStream, AbstractUnit, AbstractWaypoint, ActiveLegType, ActiveOrUpcomingLegPredictions, AdaptiveNearestSubscription, AdcEvents, AdcPublisher, AdditionalApproachType, Adsb, AdsbEvents, AdsbOperatingMode, AffineTransformPathStream, AhrsEvents, AhrsPublisher, AirportClass, AirportClassMask, AirportFacility, AirportPrivateType, AirportRunway, AirportUtils, Airspace, AirspaceSearcher, AirspaceType, Airway, AirwayBuilder, AirwayObject, AirwaySegment, AirwayStatus, AirwayType, AliasedUserSettingManager, AltitudeRestrictionType, AltitudeSelectEvents, AltitudeSelectManager, AltitudeSelectManagerOptions, Annunciation, AnnunciationType, ApproachGuidanceMode, ApproachProcedure, ApproachTransition, ArcToFixLegCalculator, ArcTurnController, ArraySubject, ArrayTaskQueue, ArrayUtils, ArrivalProcedure, Autopilot, AutopilotInstrument, AvionicsPlugin, AvionicsSystem, AvionicsSystemState, AvionicsSystemStateEvent, BaseAdcEvents, BaseAhrsEvents, BaseFlightPathVector, BaseInstrumentPublisher, BaseLegPredictions, BasePublisher, BasicAvionicsSystem, BasicConsumer, BearingDirection, BearingDistance, BearingIdent, BearingIsLoc, BearingSource, BearingValidity, BinaryHeap, BingComponent, BingComponentProps, BinomialHeap, BitFlags, BlurReconciliation, BottomTargetPathCalculator, BoundaryAltitudeType, BoundaryFacility, BoundaryType, BoundaryVector, BoundaryVectorType, CdiDeviation, CircleInterceptBuilder, CircleInterceptLegCalculator, CircleInterceptPathInfo, CircleIntersection, CircleVector, CircleVectorBuilder, ClippedPathStream, Clock, ClockEvents, ClockPublisher, CollectionComponent, CollectionComponentItemRef, CollectionComponentProps, ComSpacing, ComSpacingChangeEvent, CombinedSubject, CombinedSubscribableInputs, CompiledMapSystem, ComponentProps, CompositeLogicXMLHost, CompositeLogicXMLValueType, CompoundUnit, CompoundableUnit, ComputedSubject, ConnectCirclesBuilder, Consumer, ConsumerSubject, Context, ContextRecord, ContextSubcriptions, ContextTypes, ContextUnion, ControlEvents, ControlPublisher, ControlSurfacesEvents, ControlSurfacesPublisher, ControllerRecord, ControllerUnion, CourseToAltitudeLegCalculator, CourseToDmeLegCalculator, CourseToFixLegCalculator, CourseToInterceptLegCalculator, CourseToManualLegCalculator, CourseToRadialLegCalculator, CustomFlightPathLegRenderer, CustomWaypoint, DataStore, DateTimeFormatter, DateTimeFormatterOptions, DebounceTimer, DefaultFacilityWaypointCache, DefaultLodBoundaryCache, DefaultMapSystemContext, DefaultTcasIntruder, DefaultUserSettingManager, DeltaPacer, DepartureProcedure, DigitScroller, DigitScrollerProps, DirectToData, DirectToFixLegCalculator, DirectToPointBuilder, DirectorState, DiscontinuityLegCalculator, DisplayComponent, DisplayComponentFactory, DmeState, DmsFormatter, DurationDisplay, DurationDisplayDelim, DurationDisplayFormat, DurationDisplayOptions, DurationDisplayProps, DurationFormatter, EISPublisher, ElectricalEvents, ElectricalPublisher, EmptyDirector, EmptyRecord, EngineEvents, EnrouteTransition, EventBus, EventBusMetaEvents, EventSubscriber, EventTypes, ExpSmoother, ExtendedApproachType, ExtractSubjectType, ExtractSubjectTypes, FSComponent, Facility, FacilityFrequency, FacilityFrequencyType, FacilityILSFrequency, FacilityLoader, FacilityRepository, FacilityRepositoryEvents, FacilitySearchType, FacilitySearchTypeLatLon, FacilityType, FacilityTypeMap, FacilityTypeSearchType, FacilityWaypoint, FacilityWaypointCache, FadecEvents, FamilyOfUnit, FilteredMappedSubscribableArray, FixToDmeLegCalculator, FixTypeFlags, FlightPathCalculator, FlightPathCalculatorControlEvents, FlightPathCalculatorOptions, FlightPathLegCalculator, FlightPathLegLineRenderer, FlightPathLegLineStyle, FlightPathLegLineStyleSelector, FlightPathLegPatternRenderer, FlightPathLegPatternStyle, FlightPathLegPatternStyleSelector, FlightPathLegRenderPart, FlightPathPlanRenderOrder, FlightPathRenderStyle, FlightPathState, FlightPathTurnCalculator, FlightPathUtils, FlightPathVector, FlightPathVectorFlags, FlightPathVectorLineRenderer, FlightPathVectorPatternRenderer, FlightPathWaypoint, FlightPlan, FlightPlanActiveLegEvent, FlightPlanCalculatedEvent, FlightPlanCopiedEvent, FlightPlanDirectToDataEvent, FlightPlanDisplayBuilder, FlightPlanIndicationEvent, FlightPlanLeg, FlightPlanLegEvent, FlightPlanLegIterator, FlightPlanOriginDestEvent, FlightPlanPredictor, FlightPlanPredictorConfiguration, FlightPlanProcedureDetailsEvent, FlightPlanRequestEvent, FlightPlanResponseEvent, FlightPlanSegment, FlightPlanSegmentEvent, FlightPlanSegmentType, FlightPlanUserDataEvent, FlightPlanner, FlightPlannerEvents, FocusPosition, Fragment, FragmentFactory, FrequencyBank, FrequencyChangeEvent, FsBaseInstrument, FsInstrument, GNSSEvents, GNSSPublisher, GameStateProvider, GaugeColumnGroupProps, GaugeColumnProps, GeoCircle, GeoCircleLineRenderer, GeoCirclePathRenderer, GeoCirclePatternRenderer, GeoCircleResampler, GeoCircleResamplerArcVector, GeoCircleResamplerHandler, GeoCircleResamplerLineVector, GeoCircleResamplerStartVector, GeoCircleResamplerVector, GeoKdTree, GeoKdTreeSearchFilter, GeoKdTreeSearchVisitor, GeoPoint, GeoPointInterface, GeoPointReadOnly, GeoPointSubject, GeoProjection, GeoProjectionPathStream, GeoProjectionPathStreamStack, GeodesicResampler, GeodesicResamplerHandler, GlidePathCalculator, Glideslope, GpsBoolean, GpsSynchronizer, GreatCircleBuilder, HEvent, HEventPublisher, Handler, HandlerSubscription, HardwareControlListProps, HardwareUiControl, HardwareUiControlList, HardwareUiControlProps, HoldEntryType, HoldLegCalculator, HoldMaxSpeedRule, HoldUtils, HorizonCanvasLayer, HorizonCanvasLayerCanvasInstance, HorizonCanvasLayerCanvasInstanceClass, HorizonCanvasLayerProps, HorizonComponent, HorizonComponentProps, HorizonLayer, HorizonLayerProps, HorizonProjection, HorizonProjectionChangeListener, HorizonProjectionChangeType, HorizonProjectionParameters, HorizonSyncedCanvasLayer, ICAO, IcaoSearch, IcaoSearchFilter, IdentChangeEvent, ImageCache, IndexedEventType, IndexedNavSourceSetting, Instrument, InstrumentBackplane, InstrumentEvents, InterceptGreatCircleToPointBuilder, IntersectionFacility, IntersectionType, IntervalPacer, IteratorCursor, JetFadec, JetFadecMode, JetFadecThrottleInfo, JoinGreatCircleToPointBuilder, KdTree, KdTreeSearchFilter, KdTreeSearchVisitor, KeyEventData, KeyEvents, KeyInterceptManager, LNavDataEvents, LNavDataSimVarEvents, LNavDataSimVarPublisher, LNavDataVars, LNavDirector, LNavDirectorInterceptFunc, LNavEvents, LNavSimVarPublisher, LNavTransitionMode, LNavVars, LatLonDisplay, LatLonDisplayProps, LatLonInterface, LatLongInterface, LayerRecord, LayerUnion, LegCalculations, LegDefinition, LegDefinitionFlags, LegPredictions, LegStyleHandler, LegTurnDirection, LegType, LegWaypointHandler, LerpLookupTable, LinearServo, Localizer, LocalizerFrequency, LodBoundary, LodBoundaryCache, LodBoundaryShape, LodBoundaryVector, LogicHandler, MSFSAPStates, MagVar, MapAbstractAirspaceRenderer, MapAbstractNearestWaypointsLayerProps, MapAirspaceLayer, MapAirspaceLayerModules, MapAirspaceLayerProps, MapAirspaceModule, MapAirspaceRenderManager, MapAirspaceRenderer, MapAirspaceShowTypes, MapAutopilotPropsModule, MapBinding, MapBindingsController, MapBingLayer, MapBingLayerProps, MapBlankWaypointIcon, MapCachedCanvasLayer, MapCachedCanvasLayerCanvasInstance, MapCachedCanvasLayerCanvasInstanceClass, MapCachedCanvasLayerProps, MapCachedCanvasLayerReference, MapCachedCanvasLayerTransform, MapCanvasLayer, MapCanvasLayerCanvasInstance, MapCanvasLayerCanvasInstanceClass, MapCanvasLayerProps, MapClockUpdateController, MapClockUpdateControllerContext, MapComponent, MapComponentProps, MapCullableLocationTextLabel, MapCullableTextLabel, MapCullableTextLabelManager, MapCullableTextLayer, MapDataIntegrityModule, MapFlightPlanController, MapFlightPlanControllerContext, MapFlightPlanControllerModules, MapFlightPlanModule, MapFollowAirplaneController, MapFollowAirplaneControllerContext, MapFollowAirplaneControllerModules, MapFollowAirplaneModule, MapGenericLayer, MapGenericLayerProps, MapIndexedRangeModule, MapLabeledRingLabel, MapLabeledRingLayer, MapLayer, MapLayerProps, MapLineLayer, MapLineLayerProps, MapLocationTextLabel, MapLocationTextLabelOptions, MapModel, MapMultiLineAirspaceRenderer, MapMultiLineAirspaceShape, MapNearestWaypointsLayer, MapNearestWaypointsLayerSearch, MapNearestWaypointsLayerSearchTypes, MapOwnAirplaneIconModule, MapOwnAirplaneLayer, MapOwnAirplaneLayerModules, MapOwnAirplaneLayerProps, MapOwnAirplanePropsController, MapOwnAirplanePropsControllerModules, MapOwnAirplanePropsKey, MapOwnAirplanePropsModule, MapProjection, MapProjectionChangeListener, MapProjectionChangeType, MapProjectionParameters, MapRangeModule, MapRotation, MapRotationController, MapRotationControllerContext, MapRotationControllerModules, MapRotationModule, MapSingleLineAirspaceRenderer, MapSyncedCanvasLayer, MapSystemBuilder, MapSystemComponent, MapSystemComponentProps, MapSystemContext, MapSystemController, MapSystemCustomBuilder, MapSystemFlightPlanLayer, MapSystemFlightPlanLayerModules, MapSystemFlightPlanLayerProps, MapSystemGenericController, MapSystemGenericControllerCallbacks, MapSystemIconFactory, MapSystemKeys, MapSystemLabelFactory, MapSystemLegRenderer, MapSystemPlanRenderer, MapSystemTrafficLayer, MapSystemTrafficLayerModules, MapSystemTrafficLayerProps, MapSystemUtils, MapSystemWaypointRoles, MapSystemWaypointsLayer, MapSystemWaypointsLayerModules, MapSystemWaypointsLayerProps, MapSystemWaypointsRenderer, MapTerrainColorsModule, MapTextLabel, MapTextLayerProps, MapTrafficAlertLevelVisibility, MapTrafficIntruderIcon, MapTrafficIntruderIconFactory, MapTrafficModule, MapTransformedBinding, MapWaypoint, MapWaypointDisplayModule, MapWaypointIcon, MapWaypointImageIcon, MapWaypointRenderRoleDef, MapWaypointRenderRoleSelector, MapWaypointRenderer, MapWaypointRendererEntry, MapWaypointRendererIconFactory, MapWaypointRendererLabelFactory, MapWaypointRendererType, MapWaypointSpriteIcon, MapWxrModule, MappedSubject, MappedSubscribable, MappedUserSettingManager, MarkerBeaconState, MathUtils, MercatorProjection, Metar, MetarCloudLayer, MetarCloudLayerCoverage, MetarCloudLayerType, MetarPhenomenon, MetarPhenomenonIntensity, MetarPhenomenonType, MetarVisibilityUnits, MetarWindSpeedUnits, MetricAltitudeSelectSetting, MetricAltitudeSettingsManager, MinimumsControlEvents, MinimumsEvents, MinimumsManager, MinimumsMode, MinimumsSimVarEvents, MinimumsSimVarPublisher, MockEventTypes, ModuleRecord, ModuleUnion, MutableGeoProjection, MutableMapContext, MutableSubscribable, MutableSubscribableSet, NavAngleSubject, NavAngleUnit, NavAngleUnitReferenceNorth, NavComConfig, NavComInstrument, NavComSimVarPublisher, NavComSimVars, NavEvents, NavMagneticVariation, NavMath, NavProcSimVarPublisher, NavProcSimVars, NavProcessor, NavProcessorConfig, NavRadioEvents, NavSource, NavSourceId, NavSourceType, NavToNavManager, NdbFacility, NdbType, NearestAirportSearchSession, NearestAirportSubscription, NearestBoundarySearchSession, NearestIntersectionSearchSession, NearestIntersectionSubscription, NearestLodBoundarySearchResults, NearestLodBoundarySearchSession, NearestNdbSubscription, NearestSearchResults, NearestSearchSession, NearestSubscription, NearestUserFacilitySearchSession, NearestVorSearchSession, NearestVorSubscription, NodeInstance, NodeReference, NullAirspaceRenderer, NullPathStream, NumberFormatter, NumberFormatterOptions, NumberUnit, NumberUnitInterface, NumberUnitReadOnly, NumberUnitSubject, ObjectSubject, ObjectSubjectHandler, ObsDirector, ObsSetting, OneWayRunway, OriginDestChangeType, OrthographicProjection, PassThroughPathStream, PassedLegPredictions, PathPattern, PathStream, PatternPathStream, PidController, PlanChangeType, PlanEvents, PlanSubjects, PlaneDirector, PluginSystem, PressurizationEvents, PressurizationPublisher, Procedure, ProcedureDetails, ProcedureTurnBuilder, ProcedureTurnLegCalculator, PublishPacer, Publisher, Radio, RadioEvents, RadioType, RadioUtils, RadiusToFixLegCalculator, RandomNumberPublisher, ReadonlyFloat64Array, ReadonlySubEvent, ReadonlyTransform2D, ReadonlyTransform3D, ReadonlyTransformPerspective, RenderPosition, RequiredControllerContext, RequiredControllerLayers, RequiredControllerModules, RequiredCustomBuilderContext, RequiredCustomBuilderLayers, RequiredCustomBuilderModules, RequiredLayerModules, ResourceConsumer, ResourceHeap, ResourceModerator, RnavTypeFlags, RollDirectorOptions, RunwayFacility, RunwayLightingType, RunwaySurfaceCategory, RunwaySurfaceType, RunwayTransition, RunwayUtils, SVGUtils, ScreenStateEvent, ScrollDirection, ScrollUtils, SearchTypeMap, SearchableFacilityTypes, SessionTypeMap, SetSubject, SimVarDefinition, SimVarPublisher, SimVarPublisherEntry, SimVarValueType, SimpleMovingAverage, SimpleUnit, SmoothingPathCalculator, SortedArray, SortedMappedSubscribableArray, SoundEvents, SoundPublisher, SoundServer, SpeedType, SubEvent, Subject, Subscribable, SubscribableArray, SubscribableArrayEventType, SubscribableArrayHandler, SubscribableMapFunctions, SubscribableSet, SubscribableSetEventType, SubscribableSetHandler, SubscribableType, SubscribableUtils, Subscription, SvgPathStream, SynVisComponent, SynVisProps, SystemPowerKey, Table3D, TacanUtils, Task, TaskQueue, Tcas, TcasAdvisoryParameters, TcasAlertLevel, TcasEvents, TcasIISensitivity, TcasIISensitivityParameters, TcasIntruder, TcasOperatingMode, TcasResolutionAdvisory, TcasResolutionAdvisoryFlags, TcasResolutionAdvisoryOptions, TcasSensitivity, TcasSensitivityParameters, TcasTcaParameters, TcasTcaPrediction, ThrottleLeverManager, ThrottledTaskQueueHandler, ThrottledTaskQueueProcess, TodBodDetails, TrackFromFixLegCalculator, TrackToFixLegCalculator, TrafficContact, TrafficEvents, TrafficInstrument, TrafficInstrumentOptions, TrafficOffScaleOobOptions, Transform2D, Transform3D, TransformPerspective, TransformingPathStream, TransformingPathStreamStack, TurnToCourseBuilder, TurnToFixLegCalculator, TurnToJoinGreatCircleAtPointBuilder, TurnToJoinGreatCircleBuilder, UiControlEventHandler, UiControlEventHandlers, UiControlPropEventHandlers, Unit, UnitFamily, UnitOfNumber, UnitType, UserFacility, UserFacilityType, UserFacilityUtils, UserSetting, UserSettingDefinition, UserSettingFromRecord, UserSettingManager, UserSettingManagerEntry, UserSettingManagerSyncData, UserSettingMap, UserSettingRecord, UserSettingSaveManager, UserSettingValue, UserSettingValueFilter, VNavAltCaptureType, VNavAvailability, VNavConstraint, VNavControlEventPublisher, VNavControlEvents, VNavDataEventPublisher, VNavDataEvents, VNavEvents, VNavLeg, VNavManager, VNavPathCalculator, VNavPathMode, VNavPlanSegment, VNavSimVarPublisher, VNavState, VNavUtils, VNavVars, VNavWaypoint, VNode, Vec2Math, Vec2Subject, Vec3Math, Vec3Subject, VecNMath, VecNSubject, Vector, VectorTurnDirection, VerticalData, VerticalFlightPhase, VerticalFlightPlan, VirtualThrottleLeverEvents, VisualFacility, VorClass, VorFacility, VorToFrom, VorToFromSetting, VorType, Wait, Warning, WarningManager, WarningType, Waypoint, WaypointDisplayBuilder, WaypointTypes, WildcardHandler, WxrMode, XMLAnnunciationFactory, XMLCircularGaugeCursor, XMLCircularGaugeProps, XMLCircularGaugeStyle, XMLCircularGaugeValuePos, XMLCylinderGaugeProps, XMLCylinderGaugeStyle, XMLDoubleHorizontalGaugeProps, XMLDoubleHorizontalGaugeStyle, XMLDoubleHorizontalGaugeValuePos, XMLDoubleVerticalGaugeProps, XMLDoubleVerticalGaugeStyle, XMLExtendedGaugeConfig, XMLFunction, XMLGaugeColorLine, XMLGaugeColorZone, XMLGaugeConfigFactory, XMLGaugeProps, XMLGaugeReferenceBug, XMLGaugeReferenceBugStyle, XMLGaugeSpec, XMLGaugeStyle, XMLGaugeType, XMLHorizontalGaugeProps, XMLHorizontalGaugeStyle, XMLHorizontalGaugeValuePos, XMLHostedLogicGauge, XMLTextColumnProps, XMLTextElementProps, XMLVerticalGaugeProps, XMLVerticalGaugeStyle, XMLVerticalGaugeValuePos, XMLWarningFactory, XPDRInstrument, XPDRMode, XPDRSimVarEvents, XPDRSimVarPublisher, registerPlugin };
